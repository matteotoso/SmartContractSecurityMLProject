"""
Aggancio delle vulnerabilità ai chunk di codice
-----------------------------------------------

Questo script ha lo scopo di associare a ciascun chunk di codice
– ottenuto dalla precedente fase di suddivisione dei contratti Solidity –
le vulnerabilità normalizzate presenti nei report generati dagli
strumenti di analisi statica (Mythril, Slither, SmartCheck).

La logica di associazione è rigorosa: una vulnerabilità viene assegnata
a un chunk solo se il suo intervallo di linee risulta completamente
contenuto all’interno di uno dei range del chunk (no overlap parziale).

Per evitare duplicazioni, all’interno di ciascun chunk si mantiene
al massimo una vulnerabilità per coppia (tool, categoria). In presenza
di più occorrenze della stessa combinazione, viene mantenuta solo quella
con severità maggiore.

Autore: Matteo Toso
Anno accademico 2025
"""

import json
import sys
from pathlib import Path

# ============================================================
# 1. Gestione input
# ============================================================

if len(sys.argv) < 2:
    print("❌ Uso corretto: python vulnPerChunk.py <report_normalizzato.jsonl>")
    sys.exit(1)

report_file = Path(sys.argv[1])
summary_file = Path("Data/chunkDivision/contractsChunkSummary.jsonl")

if not summary_file.exists():
    print(f"❌ File non trovato: {summary_file}")
    sys.exit(1)


# ============================================================
# 2. Funzioni di supporto
# ============================================================

def parse_range(s):
    """Converte '5' o '5-8' in una tupla (5, 8)."""
    if not s or s == "None":
        return None
    s = s.strip()
    if "-" in s:
        a, b = s.split("-", 1)
        return (int(a), int(b))
    return (int(s), int(s))


def vuln_in_chunk(vr, chunk_ranges):
    """True solo se la vuln è completamente contenuta in un range del chunk."""
    if not vr:
        return False

    vstart, vend = vr

    for cr in chunk_ranges:
        cstart, cend = parse_range(cr)
        if cstart is None:
            continue

        if cstart <= vstart and vend <= cend:
            return True

    return False


def load_vulns(path):
    """Carica vulnerabilità normalizzate dal file JSONL."""
    vulns = []
    with open(path, "r", encoding="utf-8") as f:
        for line in f:
            if not line.strip():
                continue
            rec = json.loads(line)
            rec["_range"] = parse_range(rec.get("lines"))
            vulns.append(rec)
    return vulns


SEV_PRIORITY = {"High": 3, "Medium": 2, "Low": 1, "Unknown": 0}


# ============================================================
# 3. Caricamento vulnerabilità normalizzate
# ============================================================

print(f"[INFO] Caricamento vulnerabilità da: {report_file}")
vulns = load_vulns(report_file)

vulns_by_contract = {}
for v in vulns:
    contract = v.get("contract")
    if contract:
        vulns_by_contract.setdefault(contract, []).append(v)


# ============================================================
# 4. Aggancio vulnerabilità ai chunk e subchunk
# ============================================================

updated_records = []

with open(summary_file, "r", encoding="utf-8") as fin:
    for line in fin:
        if not line.strip():
            continue

        data = json.loads(line)
        contract = data["contract"]
        chunks = data.get("chunks", [])

        contract_vulns = vulns_by_contract.get(contract, [])

        if not contract_vulns:
            updated_records.append(data)
            continue

        for chunk in chunks:
            chunk_ranges = chunk.get("lines_range")
            chunk_vulns = chunk.get("vulns", [])

            # Mappa (tool, categoria) → vuln (solo formato pulito)
            vuln_map = {
                (v["tool"], v["categoria"]): {
                    "tool": v["tool"],
                    "categoria": v["categoria"],
                    "severity": v["severity"]
                }
                for v in chunk_vulns
            }

            # Mappa subchunk
            sub_chunks = chunk.get("sub_chunks", [])
            sub_maps = [
                {
                    (sv["tool"], sv["categoria"]): {
                        "tool": sv["tool"],
                        "categoria": sv["categoria"],
                        "severity": sv["severity"]
                    }
                    for sv in sub.get("vulns", [])
                }
                for sub in sub_chunks
            ]

            # --- Assegnazione vulnerabilità ---
            for v in contract_vulns:
                vr = v["_range"]
                key = (v["tool"], v["categoria"])

                # Costruisci vulnerabilità pulita
                v_clean = {
                    "tool": v["tool"],
                    "categoria": v["categoria"],
                    "severity": v["severity"]
                }

                # Assegnazione al chunk
                if chunk_ranges and vuln_in_chunk(vr, chunk_ranges):

                    if key in vuln_map:
                        if SEV_PRIORITY[v["severity"]] > SEV_PRIORITY[vuln_map[key]["severity"]]:
                            vuln_map[key] = v_clean
                    else:
                        vuln_map[key] = v_clean

                # Assegnazione ai subchunk
                for idx, sub in enumerate(sub_chunks):
                    if vuln_in_chunk(vr, sub["lines_range"]):

                        if key in sub_maps[idx]:
                            if SEV_PRIORITY[v["severity"]] > SEV_PRIORITY[sub_maps[idx][key]["severity"]]:
                                sub_maps[idx][key] = v_clean
                        else:
                            sub_maps[idx][key] = v_clean

            # Ricostruzione finale
            chunk["vulns"] = list(vuln_map.values())

            for idx, sub in enumerate(sub_chunks):
                sub["vulns"] = list(sub_maps[idx].values())

        updated_records.append(data)


# ============================================================
# 5. Salvataggio
# ============================================================

with open(summary_file, "w", encoding="utf-8") as fout:
    for rec in updated_records:
        fout.write(json.dumps(rec, ensure_ascii=False) + "\n")

print(f"[✓] File aggiornato con le vulnerabilità di", report_file.name)
