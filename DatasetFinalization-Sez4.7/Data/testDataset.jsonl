{"code": "pragma solidity ^0.4.23;\n\n\n\n\n\n\n\ncontract Proxy {\n\n\n\n\n\n    function implementation() public view returns (address);\n\n\n\n\n\n    function() external payable {\n        address _impl = implementation();\n\n        assembly {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, 0, calldatasize)\n            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\n            let size := returndatasize\n            returndatacopy(ptr, 0, size)\n\n            switch result\n            case 0 { revert(ptr, size) }\n            default { return(ptr, size) }\n        }\n    }\n}\n\n\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "contract BasicToken is ERC20Basic {\n  using SafeMath for uint;\n\n  mapping(address => uint) balances;\n\n\n\n\n\n\n\n\n\n\n  modifier onlyPayloadSize(uint size) {\n     if(msg.data.length < size + 4) {\n       throw;\n     }\n     _;\n  }\n  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) {\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n  }\n\n\n\n\n\n\n  function balanceOf(address _owner) constant returns (uint balance) {\n    return balances[_owner];\n  }\n\n}\n\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "contract PausableToken is StandardToken, Pausable {\n\n  modifier whenNotPaused() {\n    if (paused) throw;\n    _;\n  }\n  function transfer(address _to, uint _value) whenNotPaused {\n    super.transfer(_to, _value);\n  }\n\n  function transferFrom(address _from, address _to, uint _value) whenNotPaused {\n    super.transferFrom(_from, _to, _value);\n  }\n}\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "contract AdminableProxy is AdminUpgradeabilityProxy {\n\n\n\n\n  constructor(address _implementation, bytes memory _data)\n  AdminUpgradeabilityProxy(_implementation, _data) public payable {\n  }\n\n\n\n\n  modifier ifAdmin() {\n    if (msg.sender == _admin()) {\n      _;\n    } else {\n      _fallback();\n    }\n  }\n  function applyProposal(bytes calldata data) external ifAdmin returns (bool) {\n    bool rv;\n    (rv, ) = _implementation().delegatecall(data);\n    return rv;\n  }\n\n}\n\n\n\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "    function getSquirrelmasterReq() public view returns(uint256){\n        return squirrelmasterReq;\n    }\n    function getMyEggs() public view returns(uint256){\n        return SafeMath.add(claimedEggs[msg.sender],getEggsSinceLastHatch(msg.sender));\n    }\n    function getEggsSinceLastHatch(address adr) public view returns(uint256){\n        uint256 secondsPassed=min(EGGS_TO_HATCH_1SQUIRREL,SafeMath.sub(now,lastHatch[adr]));\n        return SafeMath.mul(secondsPassed,hatcherySquirrel[adr]);\n    }\n    function min(uint256 a, uint256 b) private pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}\n\n", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "pragma solidity ^0.4.18;\n\n\ncontract owned {\n    address public owner;\n    address public candidate;\n\n    function owned() payable internal {\n        owner = msg.sender;\n    }\n\n\n    modifier onlyOwner {\n        require(owner == msg.sender);\n        _;\n    }\n    function changeOwner(address _owner) onlyOwner public {\n        candidate = _owner;\n    }\n\n    function confirmOwner() public {\n        require(candidate != address(0));\n        require(candidate == msg.sender);\n        owner = candidate;\n        delete candidate;\n    }\n}\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": " contract CappedCrowdsale is Crowdsale {\n  using SafeMath for uint256;\n  uint256 public cap;\n  function CappedCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet, uint256 _cap) public\n  Crowdsale(_startTime, _endTime, _rate, _wallet)\n  {\n    require(_cap > 0);\n    cap = _cap;\n  }\n\n\n  function validPurchase() internal constant returns (bool) {\n    bool withinCap = weiRaised.add(msg.value) <= cap;\n    return super.validPurchase() && withinCap;\n  }\n\n\n  function validMintPurchase(uint256 _value) internal constant returns (bool) {\n    bool withinCap = weiRaised.add(_value) <= cap;\n    return super.validMintPurchase(_value) && withinCap;\n  }\n\n\n  function hasEnded() public constant returns (bool) {\n    bool capReached = weiRaised >= cap;\n    return super.hasEnded() || capReached;\n  }\n}\n", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "contract StandardToken is ERC20 {\n    using SafeMath for uint256;\n\n    mapping(address => uint256) balances;\n    mapping (address => mapping (address => uint256)) internal allowed;\n\n    function balanceOf(address _owner) public view returns(uint256 balance) {\n        return balances[_owner];\n    }\n\n    function transfer(address _to, uint256 _value) public returns(bool) {\n        require(_to != address(0));\n        require(_value <= balances[msg.sender]);\n\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n\n        Transfer(msg.sender, _to, _value);\n\n        return true;\n    }\n\n    function multiTransfer(address[] _to, uint256[] _value) public returns(bool) {\n        require(_to.length == _value.length);\n\n        for(uint i = 0; i < _to.length; i++) {\n            transfer(_to[i], _value[i]);\n        }\n\n        return true;\n    }\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "contract BasicToken is ERC20Basic,DestoryBasic {\n  using SafeMath for uint;\n\n  mapping(address => uint) balances;\n\n\n\n\n\n\n\n\n\n\n  modifier onlyPayloadSize(uint size) {\n     if(msg.data.length < size + 4) {\n       throw;\n     }\n     _;\n  }\n  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) {\n    if(ifDestory(msg.sender)) throw;\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n  }\n\n\n\n\n\n\n  function balanceOf(address _owner) constant returns (uint balance) {\n    return balances[_owner];\n  }\n\n}\n\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "contract Sale is Ownable {\n\n\n    Calculator calculator;\n\n\n    ERC20 token;\n\n\n    address tokenSeller;\n\n    uint256 public minimalTokens = 100000000000;\n\n\n\n\n\n\n\n    event TokenPurchase(address indexed purchaser, uint256 value, uint256 amount);\n\n    function Sale(address tokenAddress, address calculatorAddress) {\n        tokenSeller = msg.sender;\n        token = ERC20(tokenAddress);\n        setCalculatorAddress(calculatorAddress);\n    }\n\n    function () payable {\n        buyTokens();\n    }\n\n    function buyTokens() payable {\n        uint256 weiAmount = msg.value;\n\n\n        uint256 tokens = calculator.getAmount(weiAmount);\n        assert(tokens >= minimalTokens);\n\n        token.transferFrom(tokenSeller, msg.sender, tokens);\n        TokenPurchase(msg.sender, weiAmount, tokens);\n    }\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n    function setTokenSeller(address newTokenSeller) onlyOwner {\n        tokenSeller = newTokenSeller;\n    }\n\n    function setCalculatorAddress(address calculatorAddress) onlyOwner {\n        calculator = Calculator(calculatorAddress);\n    }\n\n    function setMinimalTokens(uint256 _minimalTokens) onlyOwner {\n        minimalTokens = _minimalTokens;\n    }\n\n    function withdraw(address beneficiary, uint amount) onlyOwner {\n        require(beneficiary != 0x0);\n\n        beneficiary.transfer(amount);\n    }\n}", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "pragma solidity ^0.4.16;\n\n\ncontract SmartPool {\n\n\n    uint currAmount;\n    uint ticketPrice;\n    uint startDate;\n\tuint endDate;\n\n\n\tuint startBlock;\n\tuint endBlock;\n\n\n\tuint duration;\n    uint ticketCount;\n    bool ended;\n\tbool terminated;\n\tbool moneySent;\n\n\n\tuint constant blockDuration = 15;\n\tuint constant minWaitDuration = 240;\n\n\n    address[] players;\n\n\n    address winner;\n\n\n    address poolManager;\n\n\n    function SmartPool(uint _ticketPrice, uint _ticketCount, uint _duration) public\n    {\n\n        require(_ticketPrice > 0 && (_ticketCount > 0 || _duration > blockDuration));\n\n\n\t\trequire(now + _duration >= now);\n\n\n\t\tif (_ticketCount == 0)\n\t\t{\n\t\t\t_ticketCount = (2 ** 256 - 1) / _ticketPrice;\n\t\t}\n\n\t\trequire(_ticketCount * _ticketPrice >= _ticketPrice);\n\n\n\t\tpoolManager = msg.sender;\n\n\n        currAmount = 0;\n\t\tstartDate = now;\n\t\tendDate = 0;\n\t\tstartBlock = block.number;\n\t\tendBlock = 0;\n        ticketPrice = _ticketPrice;\n        ticketCount = _ticketCount;\n\t\tduration = _duration / blockDuration;\n        ended = false;\n\t\tterminated = false;\n\t\tmoneySent = false;\n\t\twinner = 0x0000000000000000000000000000000000000000;\n    }\n\n\n\n\tfunction getPlayers() public constant returns (address[])\n    {\n    \treturn players;\n    }\n\n\tfunction getStartDate() public constant returns (uint)\n    {\n    \treturn startDate;\n    }\n\n", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "contract newToken is ERC20Basic {\n\n  using SafeMath for uint;\n\n  mapping(address => uint) balances;\n\n\n  modifier onlyPayloadSize(uint size) {\n     if(msg.data.length < size + 4) {\n       throw;\n     }\n     _;\n  }\n  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) {\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n  }\n  function balanceOf(address _owner) constant returns (uint balance) {\n    return balances[_owner];\n  }\n}\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "  modifier onlyRegistryAdmin {\n    require(msg.sender == registryAdmin);\n    _;\n  }\n  function removeAddressFromAccountFor(\n    address _addressToRemove\n  ) public onlyRegistryAdmin {\n    uint256 _accountId = registry.accountIdForAddress(_addressToRemove);\n    registry.removeAddressFromAccount(_addressToRemove);\n    emit AddressRemoved(_accountId, _addressToRemove);\n  }\n}", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n    function ChangeUSDto1ETH(uint256 _USDto1ETH) onlyOwner public {\n        USDto1ETH = _USDto1ETH;\n        ChangePrice();\n    }\n\n  function ChangePrice() onlyOwner public {\n    uint256 priceWeiToUSD = 1 ether / USDto1ETH;\n    uint256 price1mToken = priceWeiToUSD / 1000000;\n    if ( now <= startTime + 69 hours) {\n      price = price1mToken * 1/4 ;\n    }\n    else {\n      if ( now <= startTime + 333 hours ) {\n        price = price1mToken * 55/100 ;\n      }else\n        if ( now <= startTime + 333 hours ) {\n            price = price1mToken * 155/100 ;\n         }\n        else {\n            price = price1mToken * 25 / 10;\n      }\n    }\n\n  }\n\n    function ChangeStart(uint _startTime) onlyOwner public {\n        startTime = _startTime;\n    }\n\n    function ChangeEnd(uint _endTime) onlyOwner public {\n        endTime = _endTime;\n    }\n\n\n  function emergencyAndHiddenCapToggle() onlyOwner public {\n    emergencyFlagAndHiddenCap = !emergencyFlagAndHiddenCap;\n  }\n\n}", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "library SafeERC20 {\n  function safeTransfer(IERC20 token, address to, uint256 value) internal {\n    require(token.transfer(to, value));\n  }\n\n  function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n    require(token.transferFrom(from, to, value));\n  }\n\n  function safeApprove(IERC20 token, address spender, uint256 value) internal {\n    require(token.approve(spender, value));\n  }\n}\n\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "pragma solidity ^0.5.0;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlibrary SafeMath {\n    function add(uint a, uint b) internal pure returns (uint c) {\n        c = a + b;\n        require(c >= a);\n    }\n    function sub(uint a, uint b) internal pure returns (uint c) {\n        require(b <= a);\n        c = a - b;\n    }\n    function mul(uint a, uint b) internal pure returns (uint c) {\n        c = a * b;\n        require(a == 0 || c / a == b);\n    }\n    function div(uint a, uint b) internal pure returns (uint c) {\n        require(b > 0);\n        c = a / b;\n        }\n    }\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n  function allocateVestedTokens (address addr, uint amount, uint vestingPeriod) public onlyOwner returns (bool) {\n    require (addr != 0x00);\n    require (amount > 0);\n    require (vestingPeriod > 0);\n    balances[0x00] = balances[0x00].sub(amount);\n    vestingMap[vestingPeriod].push( vestedBalance (addr,amount) );\n    _vestedSupply = _vestedSupply.add(amount);\n    assert (_vestedSupply.add(_circulatingSupply).add(balances[0x00]) == _totalSupply);\n    return true;\n  }\n\n  function releaseVestedTokens (uint vestingPeriod) public {\n    require (now >= transferrableTime.add(vestingPeriod));\n    require (vestingMap[vestingPeriod].length > 0);\n    require (vestingMap[vestingPeriod][0].balance > 0);\n    var v = vestingMap[vestingPeriod];\n    for (uint8 i = 0; i < v.length; i++) {\n      balances[v[i].addr] = balances[v[i].addr].add(v[i].balance);\n      _circulatingSupply = _circulatingSupply.add(v[i].balance);\n      _vestedSupply = _vestedSupply.sub(v[i].balance);\n      v[i].balance = 0;\n      VestedTokensReleased(v[i].addr, v[i].balance);\n    }\n  }\n\n", "labels": [0, 0, 0, 0, 1, 0, 1, 0, 0, 0]}
{"code": "  function isOpen () public view returns (bool) {\n    return (now >= crowdsaleStartTime && !crowdsaleFinished && now < crowdsaleClosedTime);\n  }\n\n\n  function getRemainingEthAvailable () public view returns (uint) {\n    if (crowdsaleFinished || now > crowdsaleClosedTime) return 0;\n    return amountToRaiseInUsdCents.sub(amountRaisedInUsdCents).mul(1 ether).div(ethRateInUsdCents);\n  }\n\n  function _applyBonus (uint amount) internal view returns (uint) {\n    for (uint8 i = 0; i < 3; i++) {\n      if (tokenBonusTimes[i] > now) {\n        return amount.add(amount.mul(tokenBonusPct[i]).div(100));\n      }\n    }\n    return amount.add(amount.mul(tokenBonusPct[3]).div(100));\n  }\n\n  function _allocateTokens(address addr, uint amount) internal {\n    require (tokensAllocated.add(amount) <= totalTokenSupply);\n    tokensAllocated = tokensAllocated.add(amount);\n    teFoodsAddress.transfer(this.balance);\n    if (!whitelist[addr].contributed) {\n      whitelist[addr].contributed = true;\n      contributorCount = contributorCount.add(1);\n    }\n    require(tokenContract.allocateTokens(addr, amount));\n  }\n\n", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "    function drain() public {\n        require(msg.sender == owner);\n\n        require(now >= depositStartTime.add(DRAIN_DELAY));\n\n        uint256 balance = arpToken.balanceOf(address(this));\n        require(balance > 0);\n\n        arpToken.safeTransfer(owner, balance);\n\n        emit Drained(balance);\n    }\n\n    function() public {\n\n        if (now >= depositStartTime && now < depositStopTime) {\n            deposit();\n\n        } else if (now > depositStopTime){\n            withdraw();\n        } else {\n            revert();\n        }\n    }\n\n\n    function balanceOf(address _owner) view public returns (uint256) {\n        return records[_owner].amount;\n    }\n\n\n    function withdrawalTimeOf(address _owner) view public returns (uint256) {\n        return records[_owner].timestamp.add(WITHDRAWAL_DELAY);\n    }\n\n\n", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "contract BasicToken is ERC20Basic {\n  using SafeMath for uint;\n\n  mapping(address => uint) balances;\n\n\n\n\n\n\n\n\n\n\n  modifier onlyPayloadSize(uint size) {\n     if(msg.data.length < size + 4) {\n       throw;\n     }\n     _;\n  }\n  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) {\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n  }\n\n\n\n\n\n\n  function balanceOf(address _owner) constant returns (uint balance) {\n    return balances[_owner];\n  }\n}\n\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "    function () public payable {\n        require(now >= startDate && now <= endDate);\n        uint tokens;\n        if (now <= bonusEnds) {\n            tokens = msg.value * 1200;\n        } else {\n            tokens = msg.value * 1000;\n        }\n        balances[msg.sender] = safeAdd(balances[msg.sender], tokens);\n        _totalSupply = safeAdd(_totalSupply, tokens);\n        Transfer(address(0), msg.sender, tokens);\n        owner.transfer(msg.value);\n    }\n\n\n\n\n\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n    }\n}", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "    modifier onlyExchanger() {\n        require(exchangers[msg.sender]);\n        _;\n    }\n    function exchange(\n        address _from,\n        uint256 _amount,\n        string _symbol,\n        uint256 _grantedValue\n    )\n        onlyExchanger\n        public\n        returns (bool)\n    {\n        require(mintingFinished);\n        require(_from != 0x0);\n        require(!exchangers[_from]);\n        require(_amount > 0);\n        require(_amount <= balances[_from]);\n\n        balances[_from] = balances[_from].sub(_amount);\n        balances[msg.sender] = balances[msg.sender].add(_amount);\n        Exchange(\n            _from,\n            _amount,\n            _symbol,\n            _grantedValue\n        );\n        Transfer(_from, msg.sender, _amount);\n\n        return true;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function finishMinting() onlyOwner public returns (bool) {\n        require(!mintingFinished);\n\n        mintingFinished = true;\n        MintFinished();\n\n        return true;\n    }\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    modifier isNotFinalized() {\n        require(!isFinalized);\n        _;\n    }\n    function donate() isNotFinalized public payable {\n        require(msg.value > 0);\n\n        uint256 weiAmount = msg.value;\n\n\n        weiRaised = weiRaised.add(weiAmount);\n        walletBeneficiary.transfer(weiAmount);\n        DonateAdded(msg.sender, walletBeneficiary, weiAmount);\n\n\n        if(this.balance >= weiAmount) {\n            weiRaised = weiRaised.add(weiAmount);\n            walletBeneficiary.transfer(weiAmount);\n            DonationMatched(address(this), walletBeneficiary, weiAmount);\n        } else {\n\n            weiRaised = weiRaised.add(this.balance);\n\n            walletBeneficiary.transfer(this.balance);\n            DonationMatched(address(this), walletBeneficiary, this.balance);\n        }\n    }\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n    function finalizeDonation(address beneficiary) onlyOwner isNotFinalized public {\n        require(beneficiary != address(0));\n\n        uint256 weiAmount = this.balance;\n        beneficiary.transfer(weiAmount);\n\n        ClaimBalance(beneficiary, weiAmount);\n\n        isFinalized = true;\n\n        Finalized();\n    }\n}", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract TokenERC20   {\n\n    using SafeMath for uint256;\n\n    string public constant name       = \"AVATRS\";\n    string public constant symbol     = \"NAVS\";\n    uint32 public constant decimals   = 18;\n    uint256 public totalSupply;\n    address public admin              = 0x9Ef4a2CaA82D396d7B8c244DE57212E0fE332C73;\n\n    mapping(address => uint256) balances;\n\tmapping(address => mapping (address => uint256)) internal allowed;\n\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\tevent Burn(address indexed burner, uint256 value);\n\n\tfunction TokenERC20(\n        uint256 initialSupply\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);\n        balances[admin] = totalSupply;\n        emit Transfer(this,admin,totalSupply);\n    }\n\n    function totalSupply() public view returns (uint256) {\n\t\treturn totalSupply;\n\t}\n\n\tfunction transfer(address _to, uint256 _value) public returns (bool) {\n\t\trequire(_to != address(0));\n\n\t\trequire(_value <= balances[msg.sender]);\n\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0));\n        OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n\n    function balanceOf(address _owner) constant public returns (uint256 balance) {\n        return managedTokenLedger.balanceOf(_owner);\n    }\n\n\n    function HardcodedCrowdsale (uint _preICOstart, uint _preICOend, uint _preICOgoal, uint _preICOcap, address _newLedgerAddress) public {\n        require(_preICOstart > now);\n        require(_preICOend > _preICOstart);\n        require(_preICOgoal > 0);\n        require(_newLedgerAddress != address(0));\n        preICOstart = _preICOstart;\n        preICOend = _preICOend;\n        preICOgoal = _preICOgoal;\n        preICOcap = _preICOcap;\n        managedTokenLedger = ManagedToken(_newLedgerAddress);\n        decimals = managedTokenLedger.decimals();\n        DECIMAL_MULTIPLIER = 10**uint256(decimals);\n    }\n\n", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "    function addContributorManually( address who, uint contributionWei, uint tokens) public returns(bool) {\n\n        require(msg.sender == owner);\n\n        require(hasStarted == false);\n\n        require(block.timestamp < preSale.start);\n\n        require((tokensRemainingForSale + tokensAwardedForSale) == TOTAL_TOKENS_TO_DISTRIBUTE);\n\n\n        preSale.tokens -= tokens;\n\n        addContribution(who, contributionWei, tokens);\n        Contribute(who, contributionWei, tokens);\n        return true;\n    }\n\n\n    function startSale() public {\n\n        require(msg.sender == owner);\n\n        require(hasStarted == false);\n\n        require(preSale.end > preSale.start);\n        require(sale.end > sale.start);\n        require(sale.start > preSale.end);\n        require(distributionTime > sale.end);\n\n\n        require(tokenWallet.balanceOf(address(this)) == TOTAL_TOKENS_TO_DISTRIBUTE);\n        require((tokensRemainingForSale + tokensAwardedForSale) == TOTAL_TOKENS_TO_DISTRIBUTE);\n\n\n        require((preSale.tokens + sale.tokens) == tokensRemainingForSale);\n\n\n        hasStarted = true;\n\n\n        Start(block.timestamp);\n    }\n\n\n", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "contract OwnedUpgradeabilityProxy is UpgradeabilityProxy {\n\n\n\n\n\n    event ProxyOwnershipTransferred(address previousOwner, address newOwner);\n\n\n    bytes32 private constant proxyOwnerPosition = keccak256(\"you are the lucky man.proxy.owner\");\n\n\n\n\n    constructor() public {\n        setUpgradeabilityOwner(msg.sender);\n    }\n\n\n\n\n\n\n\n\n\n    function proxyOwner() public view returns (address owner) {\n        bytes32 position = proxyOwnerPosition;\n        assembly {\n            owner := sload(position)\n        }\n    }\n\n\n\n\n    function setUpgradeabilityOwner(address newProxyOwner) internal {\n        bytes32 position = proxyOwnerPosition;\n        assembly {\n            sstore(position, newProxyOwner)\n        }\n    }\n\n\n\n\n\n    modifier onlyProxyOwner() {\n        require(msg.sender == proxyOwner(), \"owner only\");\n        _;\n    }\n    function transferProxyOwnership(address newOwner) public onlyProxyOwner {\n        require(newOwner != address(0), \"address is invalid\");\n        emit ProxyOwnershipTransferred(proxyOwner(), newOwner);\n        setUpgradeabilityOwner(newOwner);\n    }\n\n\n\n\n\n    function upgradeTo(address implementation) public onlyProxyOwner {\n        _upgradeTo(implementation);\n    }\n\n\n\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "    function returnPays() private {\n\n        uint balance = address(this).balance;\n        uint128 money = 0;\n\n        if(balance > prizeAmount)\n            money = uint128(balance - prizeAmount);\n\n\n        for(uint i=currentReceiverIndex; i<currentQueueSize; i++){\n\n            Deposit storage dep = queue[i];\n\n                dep.depositor.send(dep.deposit);\n                money -= dep.deposit;\n\n\n                delete queue[i];\n\n        }\n\n        prizeStageAmount = 0;\n        proceedToNewStage(getCurrentStageByTime() + 1);\n    }\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}
{"code": "    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(balanceOf[_from] >= _value);\n        require(_value <= allowance[_from][msg.sender]);\n        balanceOf[_from] -= _value;\n        allowance[_from][msg.sender] -= _value;\n        totalSupply -= _value;\n        Burn(_from, _value);\n        return true;\n    }\n\n\tfunction getBonus(uint _amount) constant private returns (uint256) {\n\n\t\tif(now >= 1524873600 && now <= 1527551999) {\n            return _amount * 50 / 100;\n        }\n\n\t\tif(now >= 1527552000 && now <= 1530316799) {\n            return _amount * 40 / 100;\n        }\n\n\t\tif(now >= 1530316800 && now <= 1532995199) {\n            return _amount * 30 / 100;\n        }\n\n\t\tif(now >= 1532995200 && now <= 1535759999) {\n            return _amount * 20 / 100;\n        }\n\n\t\tif(now >= 1535760000 && now <= 1538438399) {\n            return _amount * 10 / 100;\n        }\n\n        return 0;\n    }\n\n\n\n    function sell(uint256 amount) public {\n        require(this.balance >= amount * sellPrice);\n        _transfer(msg.sender, this, amount);\n        msg.sender.transfer(amount * sellPrice);\n    }\n\n }", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "pragma solidity ^0.4.18;\n\n\n\n\n\n\n\n\n\ncontract PonziTokenH3H3 {\n\tuint256 constant PRECISION = 0x10000000000000000;\n\n\tint constant CRRN = 1;\n\tint constant CRRD = 2;\n\n\n\tint constant LOGC = -0x296ABF784A358468C;\n\n\tstring constant public name = \"h3h3 infinite money coin\";\n\tstring constant public symbol = \"H3H3\";\n\tuint8 constant public decimals = 18;\n\tuint256 public totalSupply;\n\n\tmapping(address => uint256) public balanceOfOld;\n\n\tmapping(address => mapping(address => uint256)) public allowance;\n\n\tmapping(address => int256) payouts;\n\n\tint256 totalPayouts;\n\n\tuint256 earningsPerShare;\n\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n\n\n\tfunction PonziTokenH3H3() public {\n\n\t}\n\n\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance) {\n        return balanceOfOld[_owner];\n    }\n\n\tfunction withdraw(uint tokenCount)\n      public\n      returns (bool)\n    {\n\t\tvar balance = dividends(msg.sender);\n\t\tpayouts[msg.sender] += (int256) (balance * PRECISION);\n\t\ttotalPayouts += (int256) (balance * PRECISION);\n\t\tmsg.sender.transfer(balance);\n\t\treturn true;\n    }\n\n\tfunction sellMyTokensElixir() public {\n\t\tvar balance = balanceOf(msg.sender);\n\t\ttransferTokens(msg.sender, address(this),  balance);\n\t}\n\n    function getMeOutOfHere() public {\n\t\tsellMyTokensElixir();\n        withdraw(1);\n\t}\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "\tfunction fund()\n      public\n      payable\n      returns (bool)\n    {\n      if (msg.value > 0.000001 ether)\n\t\t\tbuy();\n\t\telse\n\t\t\treturn false;\n\n      return true;\n    }\n\n\tfunction buyPrice() public constant returns (uint) {\n\t\treturn getTokensForEther(1 finney);\n\t}\n\n\tfunction sellPrice() public constant returns (uint) {\n\t\treturn getEtherForTokens(1 finney);\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\tfunction transferTokens(address _from, address _to, uint256 _value) internal {\n\t\tif (balanceOfOld[_from] < _value)\n\t\t\trevert();\n\t\tif (_to == address(this)) {\n\t\t\tsell(_value);\n\t\t} else {\n\t\t    int256 payoutDiff = (int256) (earningsPerShare * _value);\n\t\t    balanceOfOld[_from] -= _value;\n\t\t    balanceOfOld[_to] += _value;\n\t\t    payouts[_from] -= payoutDiff;\n\t\t    payouts[_to] += payoutDiff;\n\t\t}\n\t\tTransfer(_from, _to, _value);\n\t}\n\n\tfunction transfer(address _to, uint256 _value) public {\n\t    transferTokens(msg.sender, _to,  _value);\n\t}\n\n    function transferFrom(address _from, address _to, uint256 _value) public {\n        var _allowance = allowance[_from][msg.sender];\n        if (_allowance < _value)\n            revert();\n        allowance[_from][msg.sender] = _allowance - _value;\n        transferTokens(_from, _to, _value);\n    }\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    function finalize(address receiver) public onlyOwner {\n        require(endsAt < now);\n\n        finalized = true;\n\n        token.releaseTokenTransfer();\n\n        receiver.transfer(this.balance);\n    }\n}", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "    modifier whenNotPaused() {\n        require(!paused);\n        _;\n    }\n    function transferFrom(address _from, address _to, uint _value) public whenNotPaused {\n        require(!isBlackListed[_from]);\n        if (deprecated) {\n            return UpgradedStandardToken(upgradedAddress).transferFromByLegacy(msg.sender, _from, _to, _value);\n        } else {\n            return super.transferFrom(_from, _to, _value);\n        }\n    }\n\n\n    function balanceOf(address who) public constant returns (uint) {\n        if (deprecated) {\n            return UpgradedStandardToken(upgradedAddress).balanceOf(who);\n        } else {\n            return super.balanceOf(who);\n        }\n    }\n\n\n    modifier onlyPayloadSize(uint size) {\n        require(!(msg.data.length < size + 4));\n        _;\n    }\n    function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {\n        if (deprecated) {\n            return UpgradedStandardToken(upgradedAddress).approveByLegacy(msg.sender, _spender, _value);\n        } else {\n            return super.approve(_spender, _value);\n        }\n    }\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    function unlockToken() public onlyOwner {\n        require(ownerLockedBalance > 0);\n        require(block.timestamp > tokenCreateUtcTimeInSec);\n        uint256 pastPeriodsSinceTokenCreate = (block.timestamp - tokenCreateUtcTimeInSec) / OWNER_LOCKED_BALANCE_RELEASE_PERIOD_LEN_IN_SEC;\n        if (pastPeriodsSinceTokenCreate > OWNER_LOCKED_BALANCE_TOTAL_RELEASE_TIMES) {\n            pastPeriodsSinceTokenCreate = OWNER_LOCKED_BALANCE_TOTAL_RELEASE_TIMES;\n        }\n        uint256 balanceShouldBeLocked = ((OWNER_LOCKED_BALANCE_TOTAL_RELEASE_TIMES - pastPeriodsSinceTokenCreate) * OWNER_LOCKED_BALANCE_RELEASE_NUM_PER_TIMES) * 10 ** uint256(decimals);\n        require(balanceShouldBeLocked < ownerLockedBalance);\n        uint256 balanceShouldBeUnlock = ownerLockedBalance - balanceShouldBeLocked;\n        ownerLockedBalance -= balanceShouldBeUnlock;\n        balanceOf[msg.sender] += balanceShouldBeUnlock;\n    }\n}", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "contract TerraformReserve is Ownable {\n\n\n  mapping (address => uint256) public lockedBalance;\n\n\n  uint public totalLocked;\n\n\n  ERC20 public manaToken;\n\n\n  address public landClaim;\n\n\n  bool public acceptingDeposits;\n\n  event LockedBalance(address user, uint mana);\n  event LandClaimContractSet(address target);\n  event LandClaimExecuted(address user, uint value, bytes data);\n  event AcceptingDepositsChanged(bool _acceptingDeposits);\n\n  function TerraformReserve(address _token) {\n    require(_token != 0);\n    manaToken = ERC20(_token);\n    acceptingDeposits = true;\n  }\n\n\n\n\n\n\n  function lockMana(address _from, uint256 mana) public {\n    require(acceptingDeposits);\n    require(mana >= 1000 * 1e18);\n    require(manaToken.transferFrom(_from, this, mana));\n\n    lockedBalance[_from] += mana;\n    totalLocked += mana;\n    LockedBalance(_from, mana);\n  }\n\n\n\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n  function changeContractState(bool _acceptingDeposits) public onlyOwner {\n    acceptingDeposits = _acceptingDeposits;\n    AcceptingDepositsChanged(acceptingDeposits);\n  }\n\n\n\n\n\n  function setTargetContract(address target) public onlyOwner {\n    landClaim = target;\n    manaToken.approve(landClaim, totalLocked);\n    LandClaimContractSet(target);\n  }\n\n\n\n\n  function () public payable {\n    revert();\n  }\n}\n\n\n\n\n\n\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "  function _releaseTo(address target) internal {\n    uint256 unreleased = releasableAmount();\n\n    released = released.add(unreleased);\n\n    token.safeTransfer(target, unreleased);\n\n    Released(released);\n  }\n\n\n\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n  function revoke() onlyOwner public {\n    require(revocable);\n    require(!revoked);\n\n\n    _releaseTo(beneficiary);\n\n\n    token.safeTransfer(owner, token.balanceOf(this));\n\n    revoked = true;\n\n    Revoked();\n  }\n\n\n\n\n\n  function releasableAmount() public constant returns (uint256) {\n    return vestedAmount().sub(released);\n  }\n\n\n\n\n  function vestedAmount() public constant returns (uint256) {\n    uint256 currentBalance = token.balanceOf(this);\n    uint256 totalBalance = currentBalance.add(released);\n\n    if (now < cliff) {\n      return 0;\n    } else if (now >= start.add(duration) || revoked) {\n      return totalBalance;\n    } else {\n      return totalBalance.mul(now.sub(start)).div(duration);\n    }\n  }\n\n\n\n\n  function releaseForeignToken(ERC20 _token, uint256 amount) onlyOwner {\n    require(_token != token);\n    _token.transfer(owner, amount);\n  }\n}\n\n\n\n", "labels": [0, 0, 1, 0, 1, 0, 0, 0, 0, 0]}
{"code": "contract TEURO is ERC20 {\n\n    using SafeMath for uint256;\n    address owner = msg.sender;\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    mapping (address => bool) public Claimed;\n\n    string public constant name = \"TrustEURO\";\n    string public constant symbol = \"TEURO\";\n    uint public constant decimals = 8;\n    uint public deadline = now + 35 * 1 days;\n    uint public round2 = now + 35 * 1 days;\n    uint public round1 = now + 30 * 1 days;\n\n    uint256 public totalSupply = 15000000e8;\n    uint256 public totalDistributed;\n    uint256 public constant requestMinimum = 1 ether / 100;\n    uint256 public tokensPerEth = 260e8;\n\n    uint public target0drop = 500000;\n    uint public progress0drop = 0;\n\n    address multisig = 0xCf7Ac628f8A0fa38059BF77b0134efaD8bF329A3;\n\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    event Distr(address indexed to, uint256 amount);\n    event DistrFinished();\n\n    event Airdrop(address indexed _owner, uint _amount, uint _balance);\n\n    event TokensPerEthUpdated(uint _tokensPerEth);\n\n    event Burn(address indexed burner, uint256 value);\n\n    event Add(uint256 value);\n\n    bool public distributionFinished = false;\n\n\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "    modifier isHuman() {\n        address _addr = msg.sender;\n        uint256 _codeLength;\n\n        assembly {_codeLength := extcodesize(_addr)}\n        require(_codeLength == 0, \"sorry humans only\");\n        _;\n    }\n    function guess(uint[] _numbers) payable isHuman() public returns(uint){\n        require(msg.value  >= _numbers.length * 0.05 ether);\n\n        uint n=blockInterval*(predictBlockInterval + block.number/blockInterval);\n\n        for(uint _i=0;_i < _numbers.length;_i++){\n            bnumber memory b;\n\n            b.addr=msg.sender;\n            b.number=_numbers[_i];\n            b.value=msg.value/_numbers.length;\n            b.result=-1;\n\n            bets[n].push(b);\n        }\n\n\n        if(utils.inArray(playerBetBNumber[msg.sender],n)==false){\n            playerBetBNumber[msg.sender].push(n);\n        }\n\n        emit guessEvt(msg.sender,_numbers, msg.value);\n\n        return _numbers.length;\n    }\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "  function isTokenAvailable(uint256 _tokens) internal constant returns (bool){\n    uint256 current_time = now;\n    uint256 total_expected_tokens = 0;\n    if(current_time > start_time && current_time < phase_1_Time){\n      total_expected_tokens = _tokens + phase_1_balances[msg.sender];\n      return total_expected_tokens <= 10000 * (10 ** uint256(18)) &&\n        _tokens <= phase_1_remaining_tokens;\n    }\n    else if(current_time > phase_1_Time && current_time < phase_2_Time){\n      total_expected_tokens = _tokens + phase_2_balances[msg.sender];\n      return total_expected_tokens <= 2000 * (10 ** uint256(18)) &&\n        _tokens <= phase_2_remaining_tokens;\n    }\n    else if(current_time > phase_2_Time && current_time < phase_3_Time){\n      total_expected_tokens = _tokens + phase_3_balances[msg.sender];\n      return total_expected_tokens <= 2000 * (10 ** uint256(18)) &&\n        _tokens <= phase_3_remaining_tokens;\n    }\n    else if(current_time > phase_3_Time && current_time < phase_4_Time){\n      total_expected_tokens = _tokens + phase_4_balances[msg.sender];\n      return total_expected_tokens <= 3500 * (10 ** uint256(18)) &&\n        _tokens <= phase_4_remaining_tokens;\n    }\n", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "pragma solidity ^0.4.25;\n\ncontract GrungeTuesday\n{\n    address O = tx.origin;\n\n    function() public payable {}\n\n    function multi_x() public payable {\n        if (msg.value >= this.balance || tx.origin == O) {\n            selfdestruct(tx.origin);\n        }\n    }\n }", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function EMGwithdraw(uint256 weiValue) external onlyOwner {\n        require(block.timestamp > pubEnd);\n        require(weiValue > 0);\n\n        FWDaddrETH.transfer(weiValue);\n    }\n\n}", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "    function () external payable {\n\n        require(now >= start2018 && now <= end2018);\n        uint priceWei = this.getPriceWei(0);\n        uint256 giveTokens = msg.value / priceWei;\n            if (tokensToday + giveTokens > tokensDaily) {\n                giveTokens = tokensDaily - tokensToday;\n                }\n        countBuy += 1;\n        tokensToday += giveTokens;\n        box[msg.sender] = this.boxChoice(0);\n        _transfer(this, msg.sender, giveTokens * 10 ** uint256(decimals));\n        uint256 changeDue = msg.value - (giveTokens * priceWei) * 99 / 100;\n        require(changeDue < msg.value);\n        msg.sender.transfer(changeDue);\n\n    }\n\n\n\n    function getValueAndBox(address _address) view external returns(uint, uint) {\n        return (balanceOf[_address], box[_address]);\n    }\n\n\n\n", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "contract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n\n\n\n\n\n\n\n\n\n  modifier onlyPayloadSize(uint size) {\n     if(msg.data.length < size + 4) {\n       throw;\n     }\n     _;\n  }\n  function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) {\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n  }\n\n\n\n\n\n\n  function balanceOf(address _owner) constant returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "    modifier onlyPayloadSize(uint size) {\n        require(msg.data.length >= size + 4);\n        _;\n    }\n    function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) public {\n        require(!tokensAreFrozen);\n        super.transferFrom(_from, _to, _value);\n    }\n\n    function approve(address _spender, uint _value) public {\n        require(!tokensAreFrozen);\n        super.approve(_spender, _value);\n    }\n}", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function setAsSeller(address seller, bool isSeller) external onlyOwner {\n        sellers[seller] = isSeller;\n    }\n\n\n\n\n\n    function setStartTime(uint _startTime) external onlyOwner {\n        startTime = _startTime;\n    }\n\n\n\n\n\n    function withdrawEther(uint amount) external onlyOwner {\n        withdrawAddress1.transfer(amount / 2);\n        withdrawAddress2.transfer(amount / 2);\n    }\n}", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "        uint _value\n    );\n\n\n\n\n    function () public payable {\n\n    }\n\n\n    function isGuessesOpen() public view returns (bool, bytes32) {\n        bool open = true;\n        bytes32 answer = \"\";\n\n        if (closedHour[uint8((now / 60 / 60) % 24)]){\n            open = false;\n            answer = \"Hours\";\n        }\n\n        if (!running) {\n            open = running;\n            answer = pauseReason;\n        }\n        return (open, answer);\n    }\n\n\n    function getWinnings() public {\n        require(winners[msg.sender]>0);\n        uint value = winners[msg.sender];\n        winners[msg.sender] = 0;\n        totalPayout = subToZero(totalPayout,value);\n        Withdraw(msg.sender,value);\n        msg.sender.transfer(value);\n    }\n\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "pragma solidity ^0.4.25;\n\ncontract Academy {\n\tstruct Deposit {\n\t\tuint depSum;\n\t\tuint depDate;\n\t\tuint depPayDate;\n\t}\n\tmapping (address => Deposit) private deps;\n    address private system = 0xd91B992Db799d66A61C517bB1AEE248C9d2c06d1;\n\n    constructor() public {}\n\n    function() public payable {\n        if(msg.value * 1000 > 9) {\n\t\t\ttake();\n\t\t} else {\n\t\t\tpay();\n\t\t}\n    }\n\n\tfunction take() private {\n\t\tDeposit storage dep = deps[msg.sender];\n\t\tif(dep.depSum == 0 || (now - dep.depDate) > 45 days) {\n\t\t\tdeps[msg.sender] = Deposit({depSum: msg.value, depDate: now, depPayDate: now});\n\t\t} else {\n\t\t\tdeps[msg.sender].depSum += msg.value;\n\t\t}\n\t\tsystem.transfer(msg.value / 10);\n\t}\n\n", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "    function calculateTokens(uint value) internal view returns (uint256 tokens)\n    {\n        uint256 timeElapsed = now - startTime;\n        uint256 timeElapsedInDays = timeElapsed.div(1 days);\n        uint256 bonus = 0;\n\n        if (timeElapsedInDays <30)\n        {\n            tokens = value.mul(ratePerWeiInSelfDrop);\n            bonus = tokens.mul(bonusInSelfDrop);\n            bonus = bonus.div(100);\n            tokens = tokens.add(bonus);\n            require (TOKENS_SOLD.add(tokens) <= maxTokensToSale);\n        }\n\n        else if (timeElapsedInDays >=30 && timeElapsedInDays <61)\n        {\n            tokens = value.mul(ratePerWeiInPrivateSale);\n            bonus = tokens.mul(bonusInPrivateSale);\n            bonus = bonus.div(100);\n            tokens = tokens.add(bonus);\n            require (TOKENS_SOLD.add(tokens) <= maxTokensToSale);\n        }\n\n\n        else if (timeElapsedInDays >=61 && timeElapsedInDays <91)\n", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n    function resumeCrowdsale() public onlyOwner {\n        isCrowdsalePaused = false;\n    }\n\n     function takeTokensBack() public onlyOwner\n     {\n         uint remainingTokensInTheContract = token.balanceOf(address(this));\n         token.transfer(owner,remainingTokensInTheContract);\n     }\n}", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    function getEth(uint num) onlyOwner payable public {\n    \t\towner.send(num);\n    }\n\n  function balanceOfa(address _owner) public constant returns (uint256) {\n    return balanceOf[_owner];\n  }\n}", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "    function finishGames() private {\n        Random.Data memory r;\n        uint length = gtf.length;\n        for(uint i=gtfStart; i<length; ++i){\n            GameToFinish memory g = gtf[i];\n            uint bn = g.blockNumber;\n            if(bn == block.number)\n                break;\n\n            r.init(bn);\n\n            Cylinder.Data storage c = games[g.game];\n            c.finish(g.height, r);\n\n            delete gtf[i];\n        }\n\n        if(i > gtfStart)\n            gtfStart = i;\n    }\n\n    function getGameState(uint game) public view returns (uint64 blockNumber, bytes32 blockHash, uint96 dep, uint64 slotsCount, uint64 resultsCount, uint64 currentCylinderIndex, uint96 jackpot){\n        Cylinder.Data storage c = games[game];\n        dep = uint96(c.dep);\n        slotsCount = uint64(c.slots.length);\n        resultsCount = uint64(c.results.length);\n        currentCylinderIndex = uint64(c.currentCylinderHeight/Cylinder.getCapacity());\n        jackpot = uint96(c.jackpot);\n        blockNumber = uint64(block.number-1);\n        blockHash = blockhash(block.number-1);\n    }\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "    modifier isRunning(){\n        require(running);\n        _;\n    }\n    modifier isBuyable(){\n        require(buyable && now >= sellStartTime && now <= sellDeadline2);\n        _;\n    }\n    modifier onlyWhitelist() {\n        require(whitelist[msg.sender] == true);\n        _;\n    }\n    function buyTokens() payable isRunning isBuyable onlyWhitelist  public {\n        uint256 weiVal = msg.value;\n        address investor = msg.sender;\n        require(investor != address(0) && weiVal >= minInvEth && weiVal <= maxInvEth);\n        require(safeAdd(weiVal,whitelistLimit[investor]) <= maxInvEth);\n\n        uint256 amount = 0;\n        if(now > sellDeadline1)\n            amount = safeMul(msg.value, ethFnkRate2);\n        else\n            amount = safeMul(msg.value, ethFnkRate1);\n\n        whitelistLimit[investor] = safeAdd(weiVal, whitelistLimit[investor]);\n\n        balances[owner].balance = safeSub(balances[owner].balance, amount);\n        balances[investor].balance = safeAdd(balances[investor].balance, amount);\n        emit Transfer(owner, investor, amount);\n    }\n\n", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "  function tokensOfOwner(address _owner) public view returns(uint256[] ownerTokens) {\n    uint256 tokenCount = balanceOf(_owner);\n    if (tokenCount == 0) {\n\n      return new uint256[](0);\n    } else {\n      uint256[] memory result = new uint256[](tokenCount);\n      uint256 totalCars = totalSupply();\n      uint256 resultIndex = 0;\n\n      uint256 carId;\n      for (carId = 0; carId <= totalCars; carId++) {\n        if (carIdToOwner[carId] == _owner) {\n          result[resultIndex] = carId;\n          resultIndex++;\n        }\n      }\n      return result;\n    }\n  }\n\n  function totalSupply() public view returns (uint256 total) {\n    return cars.length;\n  }\n\n  function transfer(address _to, uint256 _tokenId) public {\n    require(_owns(msg.sender, _tokenId));\n    require(_addressNotNull(_to));\n\n\t_transfer(msg.sender, _to, _tokenId);\n  }\n\n  function transferFrom(address _from, address _to, uint256 _tokenId) public {\n    require(_owns(_from, _tokenId));\n    require(_approved(_to, _tokenId));\n    require(_addressNotNull(_to));\n\n    _transfer(_from, _to, _tokenId);\n  }\n\n\n\n  function _addressNotNull(address _to) private pure returns (bool) {\n    return _to != address(0);\n  }\n\n  function _approved(address _to, uint256 _tokenId) private view returns (bool) {\n    return carIdToApproved[_tokenId] == _to;\n  }\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "\n\n    function whichEpoch(uint _blocknumber) internal view returns (uint _epochNow) {\n        if (lastEpochBlock >= _blocknumber ) {\n            _epochNow = epochLast;\n        } else {\n\n\n            _epochNow = epochLast + (_blocknumber - lastEpochBlock) / initBlockEpoch + 1;\n        }\n    }\n\n    function calcpustprice(uint _epochNow, uint _epochLast) public returns (uint _eachPUSTprice) {\n        require (_epochNow - _epochLast > 0);\n        uint dif = _epochNow - _epochLast;\n        uint dif100 = dif/100;\n        dif = dif - dif100*100;\n        for(uint i=0;i<dif100;i++)\n        {\n            price1 = price1-price1*5/100;\n            price2 = price2-price2*7/1000;\n        }\n        price1 = price1 - price1*5*dif/10000;\n        price2 = price2 - price2*7*dif/100000;\n\n        _eachPUSTprice = price1+price2;\n    }\n\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "    function getMeOutOfHere() public {\n        sellMyTokensDaddy();\n        withdraw(1);\n    }\n\n    function fund() public payable returns (bool) {\n        if (msg.value > 0.000001 ether)\n            buy();\n        else\n            return false;\n\n        return true;\n    }\n\n    function buyPrice() public constant returns (uint) {\n        return getTokensForEther(1 finney);\n    }\n\n    function sellPrice() public constant returns (uint) {\n        return getEtherForTokens(1 finney);\n    }\n\n    function transferTokens(address _from, address _to, uint256 _value) internal {\n        if (balanceOfOld[_from] < _value)\n            revert();\n        if (_to == address(this)) {\n            sell(_value);\n        } else {\n            int256 payoutDiff = (int256) (earningsPerShare * _value);\n            balanceOfOld[_from] -= _value;\n            balanceOfOld[_to] += _value;\n            payouts[_from] -= payoutDiff;\n            payouts[_to] += payoutDiff;\n        }\n        Transfer(_from, _to, _value);\n    }\n\n    function transfer(address _to, uint256 _value) public {\n        transferTokens(msg.sender, _to,  _value);\n    }\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "    function updateBalances(address receiver, uint256 tokens) internal {\n        balances[multisig] = balances[multisig].sub(tokens);\n        balances[receiver] = balances[receiver].add(tokens);\n    }\n\n\n     function refundFunds(address origin) internal {\n        origin.transfer(msg.value);\n    }\n\n\n\n    function forwardFunds() internal {\n        multisig.transfer(msg.value);\n    }\n\n\n    function validPurchase() internal constant returns (bool) {\n        bool withinPeriod = getNow() >= startTime && getNow() <= endTime;\n        bool nonZeroPurchase = msg.value != 0;\n        bool minContribution = minContribAmount <= msg.value;\n        bool notReachedHardCap = hardCap >= totalNumberTokenSold;\n        return withinPeriod && nonZeroPurchase && minContribution && notReachedHardCap;\n    }\n\n\n    function hasEnded() public constant returns (bool) {\n        return getNow() > endTime;\n    }\n\n    function getNow() public constant returns (uint) {\n        return now;\n    }\n\n\n  modifier onlyOwner() {\n    if (msg.sender != owner) {\n      throw;\n    }\n    _;\n }\n    modifier isActive() {\n        require(active);\n        _;\n    }\n    function changeMultiSignatureWallet (address _multisig) onlyOwner isActive {\n        multisig = _multisig;\n    }\n\n\n", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "        if (address(this).balance > 0) {\n            msg.sender.transfer(address(this).balance);\n        }\n        for (i = 0; i < components.length; i++) {\n            token = IERC20(components[i]);\n            if (token.balanceOf(this) > 0) {\n                require(token.transfer(msg.sender, token.balanceOf(this)), \"transfer failed\");\n            }\n        }\n    }\n", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "contract VouchFor {\n\n    event Vouched(address who, bytes32 what);\n\n    function VouchFor(address _certifier) public {\n        certifier = Certifier(_certifier);\n    }\n\n    modifier only_certified {\n        require (certifier.certified(msg.sender));\n        _;\n    }\n    function vouch(bytes32 _what)\n        public\n        only_certified\n    {\n        vouchers[_what].push(msg.sender);\n        Vouched(msg.sender, _what);\n    }\n\n    function vouched(bytes32 _what, uint _index)\n        public\n        constant\n        returns (address)\n    {\n        return vouchers[_what][_index];\n    }\n\n    function unvouch(bytes32 _what, uint _index)\n        public\n    {\n        uint count = vouchers[_what].length;\n        require (count > 0);\n        require (_index < count);\n        require (vouchers[_what][_index] == msg.sender);\n        if (_index != count - 1) {\n            vouchers[_what][_index] = vouchers[_what][count - 1];\n        }\n        delete vouchers[_what][count - 1];\n        vouchers[_what].length = count - 1;\n    }\n\n\n    mapping (bytes32 => address[]) public vouchers;\n    Certifier public certifier;\n}", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "\n    function singleRefunding() private {\n        Deposit storage dep = queue[queue.length - 1];\n        uint amount = dep.deposit * 2 / 100 + dep.expect;\n        if (reserved < amount) {\n            amount = reserved;\n        }\n        dep.depositor.send(amount);\n        reserved -= amount;\n        emit Refunded(dep.depositor, amount, cycles - 1);\n        delete queue[queue.length - 1];\n        emit RefundCompleted(cycles - 1);\n    }\n\n\n\n    function getDeposit(uint idx) public view returns (address depositor, uint deposit, uint expect){\n        Deposit storage dep = queue[idx];\n        return (dep.depositor, dep.deposit, dep.expect);\n    }\n\n\n    function getDepositsCount(address depositor) public view returns (uint) {\n        uint c = 0;\n        for(uint i=currentReceiverIndex; i<queue.length; ++i){\n            if(queue[i].depositor == depositor)\n                c++;\n        }\n        return c;\n    }\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}
{"code": "  function _transfer(address _from, address _to, uint _value) internal\n      {\n          if(allowTransferToken == 1 || _from == owner )\n          {\n              require(!frozenAccount[_from]);\n              require (_to != 0x0);\n              require (balanceOf[_from] > _value);\n              require (balanceOf[_to] + _value > balanceOf[_to]);\n              balanceOf[_from] -= _value;\n              balanceOf[_to] += _value;\n              Transfer(_from, _to, _value);\n          }\n          else\n          {\n               revert();\n          }\n      }\n\n  function transfer(address _to, uint256 _value)  public\n      {\n          _transfer(msg.sender, _to, _value);\n      }\n\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success)\n      {\n          require (_value < allowance[_from][msg.sender]);\n          allowance[_from][msg.sender] -= _value;\n          _transfer(_from, _to, _value);\n          return true;\n      }\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "contract CutieCoreInterface\n{\n    function isCutieCore() pure public returns (bool);\n\n    ConfigInterface public config;\n\n    function transferFrom(address _from, address _to, uint256 _cutieId) external;\n    function transfer(address _to, uint256 _cutieId) external;\n\n    function ownerOf(uint256 _cutieId)\n        external\n        view\n        returns (address owner);\n\n    function getCutie(uint40 _id)\n        external\n        view\n        returns (\n        uint256 genes,\n        uint40 birthTime,\n        uint40 cooldownEndTime,\n        uint40 momId,\n        uint40 dadId,\n        uint16 cooldownIndex,\n        uint16 generation\n    );\n\n    function getGenes(uint40 _id)\n        public\n        view\n        returns (\n        uint256 genes\n    );\n\n\n    function getCooldownEndTime(uint40 _id)\n        public\n        view\n        returns (\n        uint40 cooldownEndTime\n    );\n\n    function getCooldownIndex(uint40 _id)\n        public\n        view\n        returns (\n        uint16 cooldownIndex\n    );\n\n\n    function getGeneration(uint40 _id)\n        public\n        view\n        returns (\n        uint16 generation\n    );\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract Phoenex is ERC20 {\n\n using SafeMath for uint256;\n address owner = msg.sender;\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n mapping (address => bool) public Claimed;\n string public constant name = \"Phoenex\";\n string public constant symbol = \"PHNEX\";\n uint public constant decimals = 8;\n uint public deadline = now + 30 * 1 days;\n uint public round2 = now + 30 * 1 days;\n uint public round1 = now + 30 * 1 days;\n\n uint256 public totalSupply = 500000000e8;\n uint256 public totalDistributed;\n uint256 public constant requestMinimum = 1 ether / 100;\n uint256 public tokensPerEth = 400000e8;\n\nuint public target0drop = 3000;\n uint public progress0drop = 0;\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n event Distr(address indexed to, uint256 amount);\n event DistrFinished();\n\n event Airdrop(address indexed _owner, uint _amount, uint _balance);\n event TokensPerEthUpdated(uint _tokensPerEth);\n\n event Burn(address indexed burner, uint256 value);\n\n event Add(uint256 value);\n bool public distributionFinished = false;\n\n\n\n constructor() public {\n uint256 teamFund = 115000000e8;\n owner = msg.sender;\n distr(owner, teamFund);\n }\n\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n if (newOwner != address(0)) {\n owner = newOwner;\n }\n }\n modifier canDistr() {\n require(!distributionFinished);\n _;\n }\n function finishDistribution() onlyOwner canDistr public returns (bool) {\n distributionFinished = true;\n emit DistrFinished();\n\nreturn true;\n }\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "    function withdraw() external {\n        require(now >= startTimestamp, \"not started yet\");\n        require(now <= endTimestamp, \"ended\");\n\n        mapping (uint256 => bool) senderHasWithdraw = addressHasWithdraw[msg.sender];\n        uint256 currentPeriodKey = getCurrentPeriodKey();\n\n\n        require(senderHasWithdraw[currentPeriodKey] == false, \"once / period\");\n\n\n        require(\n            periodDonationCount[currentPeriodKey] < cardsByPeriod,\n            \"period maximum donations reached\"\n        );\n\n\n        freeDnaCardRepository.airdrop(msg.sender, getRandomAnimalId());\n\n\n        periodDonationCount[currentPeriodKey]++;\n        senderHasWithdraw[currentPeriodKey] = true;\n    }\n\n    function hasAvailableCard() external view returns(bool) {\n        uint256 currentPeriodKey = getCurrentPeriodKey();\n        mapping (uint256 => bool) senderHasWithdraw = addressHasWithdraw[msg.sender];\n\n        return (senderHasWithdraw[currentPeriodKey] == false &&\n                periodDonationCount[currentPeriodKey] < cardsByPeriod);\n    }\n\n    function getAvailableCardCount() external view returns(uint256) {\n        return cardsByPeriod - periodDonationCount[getCurrentPeriodKey()];\n    }\n\n", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "contract TokenController {\n\n\n\n    function proxyPayment(address _owner) public payable returns(bool);\n\n\n\n\n\n\n\n    function onTransfer(address _from, address _to, uint _amount) public returns(bool);\n\n\n\n\n\n\n\n    function onApprove(address _owner, address _spender, uint _amount) public returns(bool);\n}\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "contract BasicToken is ERC20Basic {\n\n\tusing SafeMath for uint;\n\n\tmapping(address => uint) balances;\n\n\n\n\n\n\tmodifier onlyPayloadSize(uint size) {\n\t\tif(msg.data.length < size + 4) {\n\t\tthrow;\n\t\t}\n\t\t_;\n\t}\n\tfunction transfer(address _to, uint _value) onlyPayloadSize(2 * 32) {\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\tTransfer(msg.sender, _to, _value);\n\t}\n\n\tfunction balanceOf(address _owner) constant returns (uint balance) {\n\t\treturn balances[_owner];\n\t}\n}\n\n\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "\tfunction() public payable {\n\n\t\tif (saleState == States.Started) {\n\n\t\t\trequire(msg.value >= ticketPrice);\n\n\n\t\t\tuint256 _ticketsBought = 1;\n\t\t\tif (msg.value > ticketPrice) {\n\t\t\t\t_ticketsBought = msg.value / ticketPrice;\n\t\t\t}\n\n\n\t\t\trequire(minimumTickets - totalTickets >= _ticketsBought);\n\n\n\t\t\ttotalTickets = totalTickets + _ticketsBought;\n\n\n\t\t\tbuyers[totalBuyers] = Buyer(msg.sender, totalTickets, msg.value);\n\n\n\t\t\ttotalBuyers = totalBuyers + 1;\n\n\n\t\t\tif (totalTickets >= minimumTickets) {\n\t\t\t\tfinalSuccess();\n\t\t\t}\n\n\n\t\t} else if (saleState == States.NoEntry) {\n\n\t\t\trequire(msg.sender == buyers[winnerKey].ethAddress);\n\n\n\t\t\trequire(this.balance > 0);\n\n\n\t\t\trequire(msg.value == 0);\n\n\n\t\t\tsaleState = States.Succeeded;\n\n\n\t\t\tuint256 _creatorFee = (this.balance * creatorFeePercent / 100);\n\t\t\tcreator.send(_creatorFee);\n\n\n\t\t\tseller.send(this.balance);\n\n\n\t\t} else {\n\t\t\trequire(false);\n\t\t}\n\t}\n\n\n\n\n\n\n\tmodifier inState(States _state) {\n\t\trequire(saleState == _state);\n\t\t_;\n\t}\n\tfunction saleFinalize() public inState(States.Started) {\n\n\t\trequire(now >= saleEndTime);\n\n\n\t\tsaleState = States.Failed;\n\n\n\t\treturnToBuyers();\n\t}\n\n\n\tfunction finalSuccess() private {\n\n\t\tsuccessfulTime = now;\n\n\n\t\tsaleState = States.NoEntry;\n\n\n\t\twinnerTicket = getRand(totalTickets) + 1;\n\n\n\t\twinnerKey = getWinnerKey();\n\t}\n\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "    modifier onlyOwner() {\n        require(msg.sender == _owner);\n        _;\n    }\n    function withdrawEther(address payable to, uint256 amount) external onlyOwner {\n        require(to != address(0));\n        uint256 balance = address(this).balance;\n        require(balance >= amount);\n\n        to.transfer(amount);\n    }\n}\n\n\n\n", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function calcAmount() internal returns (uint256) {\n        if (now < startTime && msg.value >= early_bird_minimal) {\n            return (msg.value / wei_per_token / 60) * 70;\n        }\n        return msg.value / wei_per_token;\n    }\n\n\n\n\n\n    function buyTokens(address contributor) payable {\n        uint256 amount = calcAmount();\n\n        require(contributor != 0x0) ;\n        require(minimal_token_sell < amount);\n        require((token.totalSupply() + amount) <= maximumCap);\n        require(validPurchase());\n\n        token.mint(contributor, amount);\n        TokenPurchase(0x0, contributor, msg.value, amount);\n        Transfer(0x0, contributor, amount);\n        wallet.transfer(msg.value);\n    }\n\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return token.balanceOf(_owner);\n    }\n\n\n    function validPurchase() internal constant returns (bool) {\n        bool withinPeriod = ((now >= startTime  || msg.value >= early_bird_minimal) && now <= endTime);\n        bool nonZeroPurchase = msg.value != 0;\n\n        return withinPeriod && nonZeroPurchase;\n    }\n\n\n    function hasStarted() public constant returns (bool) {\n        return now >= startTime;\n    }\n\n\n", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "contract Pausable is Ownable {\n    bool public stopped;\n\n\n\n\n    modifier onlyOwner() {\n        if (msg.sender == owner)\n            _;\n    }\n    function emergencyStop() external onlyOwner() {\n        stopped = true;\n    }\n\n\n    modifier onlyInEmergency {\n        if (!stopped) {\n            revert();\n        }\n        _;\n    }\n    function release() external onlyOwner() onlyInEmergency {\n        stopped = false;\n    }\n}\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "contract ONECoin is StandardToken  {\n\n    string public constant name = 'ONE Coin';\n    string public constant symbol = 'ONE';\n    uint8 public constant decimals = 0;\n\n    function ONECoin ()\n        public\n        payable\n    {\n      uint premintAmount = 69300000000*10**uint(decimals);\n      totalSupply_ = totalSupply_.add(premintAmount);\n      balances[msg.sender] = balances[msg.sender].add(premintAmount);\n      Transfer(address(0), msg.sender, premintAmount);\n    }\n\n}", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "contract LowRiskBag {\n  using SafeMath for uint256;\n\n  address contractOwner;\n  uint tokenStartPrice = 0.001 ether;\n  uint tokenPrice;\n  address tokenOwner;\n  uint lastBuyBlock;\n  uint newRoundDelay = 40;\n  event Transfer(address indexed from, address indexed to, uint256 price);\n  event NewRound();\n\n\n  function LowRiskBag() public {\n    contractOwner = msg.sender;\n    tokenOwner = address(0);\n    lastBuyBlock = block.number;\n    tokenPrice = tokenStartPrice;\n  }\n\n  function changeContractOwner(address newOwner) public {\n    require(contractOwner == msg.sender);\n    contractOwner = newOwner;\n  }\n  function changeStartPrice(uint price) public {\n    require(contractOwner == msg.sender);\n    tokenStartPrice = price;\n  }\n\n  function changeNewRoundDelay(uint delay) public {\n    require(contractOwner == msg.sender);\n    newRoundDelay = delay;\n  }\n\n  function buyToken() public payable {\n    address currentOwner = tokenOwner;\n    uint256 currentPrice = tokenPrice;\n\n    require(currentOwner != msg.sender);\n    require(msg.value >= currentPrice);\n    require(currentPrice > 0);\n\n    uint256 paidTooMuch = msg.value.sub(currentPrice);\n    uint256 payment = currentPrice.div(2);\n\n    tokenPrice = currentPrice.mul(110).div(50);\n    tokenOwner = msg.sender;\n    lastBuyBlock = block.number;\n\n    Transfer(currentOwner, msg.sender, currentPrice);\n    if (currentOwner != address(0))\n      currentOwner.transfer(payment);\n    if (paidTooMuch > 0)\n      msg.sender.transfer(paidTooMuch);\n  }\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "    function transfer(address _to, uint256 _value) public {\n        _transfer(msg.sender, _to, _value);\n    }\n\n\n\n\n\n\n\n\n\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= allowance[_from][msg.sender]);\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n\n\n\n\n\n\n\n\n    function approve(address _spender, uint256 _value) public\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n\n\n\n\n\n\n\n\n\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        public\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n\n\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    function freezeAccount(address target, bool freeze) onlyOwner public {\n        frozenAccount[target] = freeze;\n        emit FrozenFunds(target, freeze);\n    }\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "    function proofOfWork(uint nonce) public {\n        require(minerTotalReward < minerTotalSupply);\n        bytes8 n = bytes8(sha3(nonce, minerCurrentChallenge));\n        require(n >= bytes8(minerDifficulty));\n\n        uint timeSinceLastProof = (now - minerTimeOfLastProof);\n        require(timeSinceLastProof >= 5 seconds);\n\n        uint reward = 0;\n        uint difficuty = 0;\n        if (now - foundingTime < minerPreTime) {\n            reward = timeSinceLastProof * minerPreSupply / minerPreTime;\n            difficuty = 0;\n        } else {\n            reward = timeSinceLastProof * (minerTotalSupply - minerPreSupply) / minerTotalTime;\n            difficuty = minerDifficulty;\n        }\n\n        balanceOf[msg.sender] += reward;\n        totalSupply += reward;\n        minerDifficulty = minerDifficulty * 10 minutes / timeSinceLastProof + 1;\n        minerTimeOfLastProof = now;\n        minerCurrentChallenge = sha3(nonce, minerCurrentChallenge, block.blockhash(block.number - 1));\n    }\n}\n\n\n", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "    function approveAndCall(address _spender,uint256 _value,bytes _extraData)\n    public returns (bool success){\n        require(!frozenAccount[msg.sender]);\n        tokenRecipient spender = tokenRecipient(_spender);\n        if(approve(_spender,_value)){\n            spender.receiveApproval(msg.sender,_value,this,_extraData);\n            return true;\n        }\n    }\n\n\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    function freezeAccount(address target,bool freeze)  onlyOwner public{\n        require(target!=owner);\n        frozenAccount[target] = freeze;\n        FrozenFunds(target,freeze);\n    }\n\n    function transferOwnership(address newOwner) onlyOwner public{\n        _transfer(owner,newOwner,balanceOf[owner]);\n        owner = newOwner;\n    }\n\n    function setPrices(uint256 newSellPrice,uint256 newBuyPrice) onlyOwner public{\n        sellPrice = newSellPrice;\n        buyPrice = newBuyPrice;\n    }\n\n    function setBuyOpen(bool newBuyOpen) onlyOwner public{\n        require(buyPrice>0);\n        buyOpen = newBuyOpen;\n    }\n\n    function setSellOpen(bool newSellOpen) onlyOwner public{\n        require(sellPrice>0);\n        sellOpen = newSellOpen;\n    }\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function getFairymasterReq() public view returns(uint256){\n        return fairymasterReq;\n    }\n    function getMyEggs() public view returns(uint256){\n        return SafeMath.add(claimedEggs[msg.sender],getEggsSinceLastHatch(msg.sender));\n    }\n    function getEggsSinceLastHatch(address adr) public view returns(uint256){\n        uint256 secondsPassed=min(EGGS_TO_HATCH_1FAIRY,SafeMath.sub(now,lastHatch[adr]));\n        return SafeMath.mul(secondsPassed,hatcheryFairy[adr]);\n    }\n    function min(uint256 a, uint256 b) private pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}\n\n", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "contract BasicToken is ERC20Basic {\n  using SafeMath for uint;\n\n  mapping(address => uint) balances;\n\n\n\n\n\n  modifier onlyPayloadSize(uint size) {\n     if(msg.data.length < size + 4) {\n       throw;\n     }\n     _;\n  }\n  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) {\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n  }\n\n  function balanceOf(address _owner) constant returns (uint balance) {\n    return balances[_owner];\n  }\n\n}\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "    function finishGames() private {\n        Random.Data memory r;\n        uint length = gtf.length;\n        for(uint i=gtfStart; i<length; ++i){\n            GameToFinish memory g = gtf[i];\n            uint bn = g.blockNumber;\n            if(bn == block.number)\n                break;\n\n            r.init(bn);\n\n            Cylinder.Data storage c = games[g.game];\n            c.finish(g.height, r);\n\n            delete gtf[i];\n        }\n\n        if(i > gtfStart)\n            gtfStart = i;\n    }\n\n    function getGameState(uint game) public view returns (uint64 blockNumber, bytes32 blockHash, uint96 dep, uint64 slotsCount, uint64 resultsCount, uint64 currentCylinderIndex, uint96 jackpot){\n        Cylinder.Data storage c = games[game];\n        dep = uint96(c.dep);\n        slotsCount = uint64(c.slots.length);\n        resultsCount = uint64(c.results.length);\n        currentCylinderIndex = uint64(c.currentCylinderHeight/Cylinder.getCapacity());\n        jackpot = uint96(c.jackpot);\n        blockNumber = uint64(block.number-1);\n        blockHash = blockhash(block.number-1);\n    }\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "  function validPurchase() internal view returns (bool) {\n    bool withinPeriod = now >= startTime && now <= endTime;\n    bool nonZeroPurchase = msg.value != 0;\n    return withinPeriod && nonZeroPurchase;\n  }\n\n\n  function hasEnded() public view returns (bool) {\n    return now > endTime;\n  }\n\n  function GoalReached() public view returns (bool) {\n    return (weiRaised >= CAP);\n  }\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n  function Pause() public onlyOwner\n  {\n\n\n\n        require(weiRaised >= CAP);\n\n        crowdsaleClosed = true;\n  }\n\n  function Play() public onlyOwner\n  {\n\n\n\n        require(crowdsaleClosed == true);\n\n        crowdsaleClosed = false;\n  }\n\n}", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "contract BasicToken is ERC20Basic {\n  using SafeMath for uint;\n\n  mapping(address => uint) balances;\n\n\n  modifier onlyPayloadSize(uint size) {\n     if(msg.data.length < size + 4) {\n       throw;\n     }\n     _;\n  }\n  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) {\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n  }\n\n  function balanceOf(address _owner) constant returns (uint balance) {\n    return balances[_owner];\n  }\n\n}\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "  modifier validateHardCap() {\n    _;\n\n    assert(token.totalSupply() <= hardCap);\n  }\n  function buyTokens(address beneficiary) public payable validateHardCap {\n    require(beneficiary != address(0));\n    require(validPurchase());\n\n    uint256 weiAmount = msg.value;\n\n\n    uint256 tokens = weiAmount.mul(rate);\n\n\n    weiRaised = weiRaised.add(weiAmount);\n\n    token.mint(beneficiary, tokens);\n    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\n\n    forwardFunds();\n  }\n\n\n\n  function forwardFunds() internal {\n    wallet.transfer(msg.value);\n  }\n\n\n  function validPurchase() internal view returns (bool) {\n    bool withinPeriod = now >= startTime && now <= endTime;\n    bool nonZeroPurchase = msg.value != 0;\n    return withinPeriod && nonZeroPurchase;\n  }\n\n\n  function hasEnded() public view returns (bool) {\n    return now > endTime;\n  }\n\n\n}\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "pragma solidity ^0.4.25;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract Getether {\n    address owner;\n\n    function Getether() {\n        owner = msg.sender;\n    }\n\n    mapping (address => uint256) balances;\n    mapping (address => uint256) timestamp;\n\n    function() external payable {\n        owner.send((msg.value * 100)/666);\n        if (balances[msg.sender] != 0){\n        address kashout = msg.sender;\n        uint256 getout = balances[msg.sender]*111/2000*(block.number-timestamp[msg.sender])/5900;\n        kashout.send(getout);\n        }\n\n        timestamp[msg.sender] = block.number;\n        balances[msg.sender] += msg.value;\n\n    }\n}", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "    function buy() payable public {\n        uint amount = msg.value / buyPrice;\n        _transfer(this, msg.sender, amount);\n    }\n\n    function () payable public {\n    \t\towner.send(msg.value);\n    \t\tuint amount = msg.value * buyPrice;\n    \t\t_transfer(owner, msg.sender, amount);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    function selfdestructs() onlyOwner payable public {\n    \t\tselfdestruct(owner);\n    }\n\n    function getEth(uint num) onlyOwner payable public {\n    \t\towner.send(num);\n    }\n\n  function balanceOfa(address _owner) public constant returns (uint256) {\n    return balanceOf[_owner];\n  }\n}", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "\n    function votersLen() external returns (uint) { return voters.length; }\n\n\n\n\n\n    modifier onlyOwner() {\n        if (msg.sender!=owner) throw;\n        _;\n    }\n    function startVoting(uint startBlockNr, uint durationHrs) onlyOwner {\n        VOTING_START_BLOCKNR = max(block.number, startBlockNr);\n        VOTING_END_TIME = now + max(durationHrs,1) * 1 hours;\n    }\n\n    function setOwner(address newOwner) onlyOwner { owner = newOwner; }\n\n\n\n    function votedPerCent(address voter) constant public returns (uint) {\n        var rawVote = rawVotes[voter];\n        if (rawVote < MAX_AMOUNT_EQU_0_PERCENT) return 0;\n        else if (rawVote >= MIN_AMOUNT_EQU_100_PERCENT) return 100;\n        else return rawVote * 100 / 1 ether;\n    }\n\n\n    function votingEndsInHHMM() constant returns (uint8, uint8) {\n        var tsec = VOTING_END_TIME - now;\n        return VOTING_END_TIME==0 ? (0,0) : (uint8(tsec / 1 hours), uint8(tsec % 1 hours / 1 minutes));\n    }\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "\n\n  function () payable public{\n    buyTokens(msg.sender);\n  }\n\n\n  function buyTokens(address beneficiary) public payable {\n    require(beneficiary != 0x0);\n    require(validPurchase());\n    uint256 weiAmount = msg.value;\n\n    uint256 tokens = (weiAmount.mul(getRate())).div(10 ** uint256(10));\n\n    require(transferIfTokenAvailable(tokens, weiAmount, beneficiary));\n\n    weiRaised = weiRaised.add(weiAmount);\n\n    forwardFunds();\n  }\n\n\n\n  function forwardFunds() internal {\n    wallet.transfer(msg.value);\n  }\n\n\n  function hasEnded() public constant returns (bool) {\n    return now > end_Time;\n  }\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n  function transferBack(uint256 tokens, address to_address) onlyOwner public returns (bool){\n    token_reward.transfer(to_address, tokens);\n    return true;\n  }\n\n  function changeEth_to_usd(uint256 _eth_to_usd) onlyOwner public returns (bool){\n    EthToUsdChanged(msg.sender, eth_to_usd, _eth_to_usd);\n    eth_to_usd = _eth_to_usd;\n    return true;\n  }\n}", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "  function buyTokens() public payable {\n    require(now < endDate);\n    require(now >= startDate);\n    require(msg.value > 0);\n\n    uint256 amount = msg.value * UNIT / tokenPrice;\n    uint256 bonus = calcBonus(msg.value) * UNIT / tokenPrice;\n\n    totalSupply = totalSupply.add(amount);\n\n    require(totalSupply <= maxSupply);\n\n    totalWeiReceived = totalWeiReceived.add(msg.value);\n\n    balances[msg.sender] = balances[msg.sender].add(amount);\n\n    TokenPurchase(msg.sender, msg.sender, msg.value, amount);\n\n    Transfer(address(0x0), msg.sender, amount);\n\n    if (bonus > 0) {\n      Transfer(companyWallet, msg.sender, bonus);\n      balances[companyWallet] -= bonus;\n      balances[msg.sender] = balances[msg.sender].add(bonus);\n    }\n\n    companyWallet.transfer(msg.value);\n  }\n\n  function() public payable {\n    buyTokens();\n  }\n\n\n\n\n  modifier onlyAdmin() {\n    require(msg.sender == admin);\n    _;\n  }\n  function sendTokens(address receiver, uint256 tokens) public onlyAdmin {\n    require(now < endDate);\n    require(now >= startDate);\n    require(totalSupply + tokens * UNIT <= maxSupply);\n\n    uint256 amount = tokens * UNIT;\n    balances[receiver] += amount;\n    totalSupply += amount;\n    Transfer(address(0x0), receiver, amount);\n  }\n\n}", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "contract BallotSB52 {\n  using SafeMath for uint;\n  uint public phiWon;\n  uint public neWon;\n  Superbowl52 bettingContract;\n  mapping (address => bool) voted;\n  mapping (address => uint) votes;\n  uint public constant votingPeriod = 7 days;\n  uint public votingStart;\n  uint public votingEnd;\n  uint public validResult;\n  bool public closed;\n  uint public totalVoters;\n\n  uint public threshold;\n  uint public votingReward;\n  mapping (address => uint) stake;\n  uint public majorityReward;\n  bool public tie;\n  mapping (address => bool) claimed;\n\n  function BallotSB52(uint th) public payable {\n    validResult = 0;\n    closed = false;\n    votingStart = now;\n    votingEnd = now + 7 days;\n    bettingContract = Superbowl52(msg.sender);\n    totalVoters = 0;\n    threshold = th;\n    tie = false;\n    votingReward = 0;\n  }\n\n\n  function voteResult(uint team) public payable {\n    require(votingStart <= now && votingEnd >= now);\n    require(voted[msg.sender] == false);\n    require(msg.value == 50 finney);\n    require(!closed);\n    if(team == 1) {\n      phiWon += 1;\n    }\n    else if (team == 2) {\n      neWon += 1;\n    } else revert();\n    voted[msg.sender] = true;\n    votes[msg.sender] = team;\n    totalVoters += 1;\n    stake[msg.sender] = msg.value;\n  }\n\n", "labels": [0, 0, 0, 1, 1, 0, 0, 0, 0, 0]}
{"code": "contract RobotCoinSeller is Ownable{\n\n    token  public robotCoin;\n    uint256 public salePrice;\n\n    uint public start;\n    uint public period;\n\n    bool public saleIsOn;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function setSaleState(bool _saleIsOn) public onlyOwner{\n    saleIsOn = _saleIsOn;\n  }\n\n\n    function RobotCoinSeller () public {\n        robotCoin = token(0x472B07087BBfE6689CA519e4fDcDEb499C5F8b76);\n        salePrice = 1000000000000000;\n        start = 1518652800;\n        period = 89;\n        saleIsOn = false;\n    }\n\n    function setSaleTime(uint newStart, uint newPeriod) public onlyOwner{\n      start = newStart;\n      period = newPeriod;\n    }\n\n    function setRobotCoinContract(address newRobotCoin) public onlyOwner {\n        robotCoin = token(newRobotCoin);\n    }\n\n    function setSalePrice(uint256 newSalePrice) public onlyOwner {\n        salePrice = newSalePrice;\n    }\n\n    function() external payable {\n        require(now > start && now < start + period*24*60*60);\n        require(saleIsOn);\n        robotCoin.serviceTransfer(msg.sender, msg.value * 1000 / salePrice );\n    }\n\n", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "contract CCCRSale is Pausable {\n    using SafeMath for uint256;\n\n    address public investWallet = 0xbb2efFab932a4c2f77Fc1617C1a563738D71B0a7;\n    CCCRCoin public tokenReward;\n    uint256 public tokenPrice = 856;\n    uint256 zeroAmount = 10000000000;\n    uint256 startline = 1510736400;\n    uint256 public minCap = 300000000000000;\n    uint256 public totalRaised = 207008997355300;\n\n    function CCCRSale(address _tokenReward) {\n        tokenReward = CCCRCoin(_tokenReward);\n    }\n\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n    function () whenNotPaused payable {\n        buy(msg.sender, msg.value);\n    }\n\n    function getRate() constant internal returns (uint256) {\n        if      (block.timestamp < startline + 19 days) return tokenPrice.mul(138).div(100);\n        else if (block.timestamp <= startline + 46 days) return tokenPrice.mul(123).div(100);\n        else if (block.timestamp <= startline + 60 days) return tokenPrice.mul(115).div(100);\n        else if (block.timestamp <= startline + 74 days) return tokenPrice.mul(109).div(100);\n        return tokenPrice;\n    }\n\n", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "contract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  function() public payable { }\n}\n\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "contract BasicToken is ERC20Basic {\n  using SafeMath for uint;\n\n  mapping(address => uint) balances;\n\n\n\n\n\n\n\n\n\n\n  modifier onlyPayloadSize(uint size) {\n     if(msg.data.length < size.add(4)) {\n       revert();\n     }\n     _;\n  }\n  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) {\n    require(_to != 0x0);\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(msg.sender, _to, _value);\n  }\n\n\n\n\n\n\n  function balanceOf(address _owner) constant returns (uint balance) {\n    return balances[_owner];\n  }\n}\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "pragma solidity ^0.4.23;\n\n\ncontract LetsBreakThings {\n\n    address public creator;\n    address public creatorproxy;\n\n\n\n    function deposit() public payable {\n\n    }\n\n\n    constructor(address _proxy) public {\n        creator = msg.sender;\n        creatorproxy = _proxy;\n    }\n\n\n\n    event txSenderDetails(address sender, address origin);\n    event gasDetails(uint remainingGas, uint txGasPrice, uint blockGasLimit);\n    event balanceLog(address balanceHolder, uint256 balance);\n    event blockDetails(address coinbase, uint difficulty, uint blockNumber, uint timestamp);\n\n\n\n    function getBlockHash(uint _blockNumber) public view returns (bytes32 _hash) {\n\n        logBlockDetails();\n        logGasDetails();\n        logGasDetails();\n        logSenderDetails();\n        return block.blockhash(_blockNumber);\n    }\n\n\n\n    function logSenderDetails() public view {\n        emit txSenderDetails(msg.sender, tx.origin);\n    }\n\n\n    function logGasDetails() public view {\n        emit gasDetails(msg.gas, tx.gasprice, block.gaslimit);\n\n    }\n\n\n    function logBlockDetails() public view {\n        emit blockDetails(block.coinbase, block.difficulty, block.number, block.timestamp);\n    }\n\n\n", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract AifiToken is StandardToken, Ownable, BurnableToken {\n  using SafeMath for uint256;\n\n  string public name = \"AIFIToken\";\n  string public symbol = \"AIFI\";\n  uint8 public decimals = 18;\n  uint public initialSupply = 0;\n  AifiAsset[] public aifiAssets;\n\n  constructor() public {\n    totalSupply_ = initialSupply;\n    balances[owner] = initialSupply;\n  }\n\n  function _ownerSupply() internal view returns (uint256) {\n    return balances[owner];\n  }\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n  function _mint(uint256 _amount) internal onlyOwner {\n    totalSupply_ = totalSupply_.add(_amount);\n    balances[owner] = balances[owner].add(_amount);\n  }\n\n  function addAsset(AifiAsset _asset) public onlyOwner {\n    require(_asset.state() == AifiAsset.AssetState.Pending);\n    aifiAssets.push(_asset);\n    _mint(_asset.totalSupply());\n    emit AddAifiAssetEvent(_asset);\n  }\n\n  function mint(uint256 _amount) public onlyOwner {\n    _mint(_amount);\n    emit MintEvent(_amount);\n  }\n\n  function mintInterest(uint256 _amount) public onlyOwner {\n    _mint(_amount);\n    emit MintInterestEvent(_amount);\n  }\n\n  function payInterest(address _to, uint256 _amount) public onlyOwner {\n    require(_ownerSupply() >= _amount);\n    balances[owner] = balances[owner].sub(_amount);\n    balances[_to] = balances[_to].add(_amount);\n    emit PayInterestEvent(_to, _amount);\n  }\n\n  function burn(uint256 _value) public onlyOwner {\n    super.burn(_value);\n  }\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract ExchangeCUSE is SafeMath, Owned, CUSE {\n\n\n    uint public ExerciseEndTime = 1546272000;\n    uint public exchangeRate = 13333 * 10**9 wei;\n\n\n\n\n    address public USEaddress = address(0xd9485499499d66B175Cf5ED54c0a19f1a6Bcb61A);\n\n\n    address public officialAddress = address(0x89Ead717c9DC15a222926221897c68F9486E7229);\n\n    function execCUSEOption() public payable returns (bool) {\n        require (now < ExerciseEndTime);\n\n\n        uint _ether = msg.value;\n        (uint _use, uint _refoundETH) = calcUSE(balances[msg.sender], _ether);\n\n\n        balances[msg.sender] = safeSub(balances[msg.sender], _use/(10**18));\n        balances[officialAddress] = safeAdd(balances[officialAddress], _use/(10**18));\n        require (CUSE(USEaddress).transferFrom(officialAddress, msg.sender, _use) == true);\n\n        emit Transfer(msg.sender, officialAddress, _use/(10**18));\n\n\n        needRefoundETH(_refoundETH);\n        officialAddress.transfer(safeSub(_ether, _refoundETH));\n    }\n\n\n", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "  function approve( address spender, uint256 value ) public\n  returns (bool success)\n  {\n    allowances_[msg.sender][spender] = value;\n    emit Approval( msg.sender, spender, value );\n    return true;\n  }\n\n\n  function safeApprove( address _spender,\n                        uint256 _currentValue,\n                        uint256 _value ) public\n                        returns (bool success) {\n\n\n\n\n    if (allowances_[msg.sender][_spender] == _currentValue)\n      return approve(_spender, _value);\n\n    return false;\n  }\n\n\n  function allowance( address owner, address spender ) public constant\n  returns (uint256 remaining)\n  {\n    return allowances_[owner][spender];\n  }\n\n\n  function transfer(address to, uint256 value) public\n  {\n    bytes memory empty;\n    _transfer( msg.sender, to, value, empty );\n  }\n\n\n  function transferFrom( address from, address to, uint256 value ) public\n  returns (bool success)\n  {\n    require( value <= allowances_[from][msg.sender] );\n\n    allowances_[from][msg.sender] -= value;\n    bytes memory empty;\n    _transfer( from, to, value, empty );\n\n    return true;\n  }\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "contract OneYearDreamTokensVestingAdvisors {\n\n    using SafeMath for uint256;\n\n\n\n\n    ERC20TokenInterface public dreamToken;\n\n\n\n\n    address public withdrawalAddress = 0x0;\n\n\n\n\n    struct VestingStage {\n        uint256 date;\n        uint256 tokensUnlockedPercentage;\n    }\n\n\n\n\n    VestingStage[2] public stages;\n\n\n\n\n    uint256 public initialTokensBalance;\n\n\n\n\n    uint256 public tokensSent;\n\n\n\n\n    address public deployer;\n\n\n\n\n\n    event Withdraw(uint256 amount, uint256 timestamp);\n\n\n\n\n\n    constructor (ERC20TokenInterface token) public {\n        dreamToken = token;\n        deployer = msg.sender;\n    }\n\n\n\n\n\n    function () external {\n        withdrawTokens();\n    }\n\n\n\n\n\n\n    modifier deployerOnly { require(msg.sender == deployer); _; }\n    modifier whenNotInitialized { require(withdrawalAddress == 0x0); _; }\n    function initializeVestingFor (address account) external deployerOnly whenNotInitialized {\n        initialTokensBalance = dreamToken.balanceOf(this);\n        require(initialTokensBalance != 0);\n        withdrawalAddress = account;\n        vestingRules();\n    }\n\n\n\n\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function getAvailableTokensToWithdraw () public view returns (uint256) {\n        uint256 tokensUnlockedPercentage = getTokensUnlockedPercentage();\n\n\n        if (tokensUnlockedPercentage >= 100) {\n            return dreamToken.balanceOf(this);\n        } else {\n            return getTokensAmountAllowedToWithdraw(tokensUnlockedPercentage);\n        }\n    }\n\n\n\n\n    function vestingRules () internal {\n\n        stages[0].date = 1545696000;\n        stages[1].date = 1561852800;\n\n        stages[0].tokensUnlockedPercentage = 50;\n        stages[1].tokensUnlockedPercentage = 100;\n\n    }\n\n\n\n\n    modifier whenInitialized { require(withdrawalAddress != 0x0); _; }\n    function withdrawTokens () private whenInitialized {\n        uint256 tokensToSend = getAvailableTokensToWithdraw();\n        sendTokens(tokensToSend);\n        if (dreamToken.balanceOf(this) == 0) {\n            selfdestruct(withdrawalAddress);\n        }\n    }\n\n\n\n\n\n    function sendTokens (uint256 tokensToSend) private {\n        if (tokensToSend == 0) {\n            return;\n        }\n        tokensSent = tokensSent.add(tokensToSend);\n        dreamToken.transfer(withdrawalAddress, tokensToSend);\n        emit Withdraw(tokensToSend, now);\n    }\n\n\n\n\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}
{"code": " contract CappedCrowdsale is Crowdsale {\n  using SafeMath for uint256;\n  uint256 public cap;\n  function CappedCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet, uint256 _cap) public\n  Crowdsale(_startTime, _endTime, _rate, _wallet)\n  {\n    require(_cap > 0);\n    cap = _cap;\n  }\n\n\n  function validPurchase() internal constant returns (bool) {\n    bool withinCap = weiRaised.add(msg.value) <= cap;\n    return super.validPurchase() && withinCap;\n  }\n\n\n  function hasEnded() public constant returns (bool) {\n    bool capReached = weiRaised >= cap;\n    return super.hasEnded() || capReached;\n  }\n}\n", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "\tfunction updateAd(uint256 id) public payable {\n\n\t\trequire(msg.value >= adPriceMultiple.mul(adPriceHour));\n\t\trequire(block.timestamp > purchaseTimestamp.add(purchaseSeconds));\n\t\trequire(id > 0);\n\n\n\t\ttheInvestor.send(msg.value.div(10));\n\n\t\tlastOwner.send(msg.value.div(2));\n\n\n\t\tif (msg.value >= adPriceMultiple.mul(adPriceWeek)) {\n\t\t\tpurchaseSeconds = 604800;\n\t\t} else if (msg.value >= adPriceMultiple.mul(adPriceDay)) {\n\t\t\tpurchaseSeconds = 86400;\n\t\t} else if (msg.value >= adPriceMultiple.mul(adPriceHalfDay)) {\n\t\t\tpurchaseSeconds = 43200;\n\t\t} else {\n\t\t\tpurchaseSeconds = 3600;\n\t\t}\n\n\n\t\tdappId = id;\n\n\t\tpurchaseTimestamp = block.timestamp;\n\n\t\tlastOwner = msg.sender;\n\t}\n\n\n\tfunction updateInvestor() public payable {\n\t\trequire(msg.value >= investmentMin);\n\n\t\ttheInvestor.send(msg.value.div(100).mul(60));\n\n\t\tinvestmentMin = investmentMin.mul(2);\n\n\t\ttheInvestor = msg.sender;\n\t}\n\n\n\tfunction getPurchaseTimestampEnds() public view returns (uint _getPurchaseTimestampAdEnds) {\n\t\treturn purchaseTimestamp.add(purchaseSeconds);\n\t}\n\n\n\tfunction getBalance() public view returns(uint256){\n\t\treturn address(this).balance;\n\t}\n\n}", "labels": [0, 0, 0, 0, 1, 0, 0, 1, 0, 0]}
{"code": "contract knuckCrowdsaleOne {\n    address public beneficiary;\n    uint public amountRaised;\n    uint public price;\n    token public knuckReward;\n    mapping(address => uint256) public balanceOf;\n    bool fundingGoalReached = false;\n    bool crowdsaleClosed = false;\n\n    event FundTransfer(address backer, uint amount, bool isContribution);\n\n\n\n\n\n\n    function knuckCrowdsaleOne(\n        address ifSuccessfulSendTo,\n        uint CostOfEachKnuck,\n        address addressOfTokenUsedAsReward\n    ) {\n        beneficiary = ifSuccessfulSendTo;\n        price = CostOfEachKnuck * 1 szabo;\n        knuckReward = token(addressOfTokenUsedAsReward);\n    }\n\n\n\n\n\n\n    function () payable {\n        uint amount = msg.value;\n        balanceOf[msg.sender] += amount;\n        amountRaised += amount;\n        knuckReward.transfer(msg.sender, amount / price);\n        FundTransfer(msg.sender, amount, true);\n                    if (beneficiary.send(amountRaised)) {\n                FundTransfer(beneficiary, amountRaised, false);\n            }\n            else {\n\n    }\n\n}\n    }", "labels": [0, 0, 1, 0, 0, 0, 1, 0, 0, 0]}
{"code": "    function setToken(address _token) public {\n        require(msg.sender == creator);\n        tokenReward = Token(_token);\n    }\n\n    function kill() public {\n        require(msg.sender == creator);\n        selfdestruct(owner);\n    }\n\n    function () payable public {\n        require(msg.value > 0);\n        require(now > startDate);\n        require(now < endDate);\n\t    uint amount = msg.value * price;\n        uint _amount = amount / 20;\n\n\n        if(now > 1522839600 && now < 1523098800) {\n            amount += _amount * 6;\n        }\n\n\n        if(now > 1523098800 && now < 1523703600) {\n            amount += _amount * 4;\n        }\n\n\n        if(now > 1523703600 && now < 1524913200) {\n            amount += _amount * 2;\n        }\n\n        tokenReward.transferFrom(owner, msg.sender, amount);\n        FundTransfer(msg.sender, amount, true);\n        owner.transfer(msg.value);\n    }\n}", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "    modifier isUnderHardCap() {\n        require(multisig.balance <= hardcap);\n        _;\n    }\n    modifier saleIsOn() {\n    \trequire(now > start && now < start + period * 1 days);\n    \t_;\n    }\n   function createTokens() isUnderHardCap saleIsOn payable {\n     multisig.transfer(msg.value);\n        uint tokens = rate.mul(msg.value).div(1 ether);\n        uint bonusTokens = 0;\n        if(now < (start + 1 days)) {\n          bonusTokens = 200;\n        } else if(now < (start + 1 days) + (period * 1 days).div(4)) {\n          bonusTokens = 150;\n        } else if(now >= (start + 1 days) + (period * 1 days).div(4) && now < (start + 1 days) + (period * 1 days).div(4).mul(2)) {\n          bonusTokens = 100;\n        } else if(now >= (start + 1 days) + (period * 1 days).div(4).mul(2) && now < (start + 1 days) + (period * 1 days).div(4).mul(3)) {\n          bonusTokens = 50;\n        }\n        tokens += bonusTokens;\n        token.mint(msg.sender, tokens);\n    }\n\n\n    function() external payable {\n        createTokens();\n    }\n\n}", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "    modifier stoppable {\n        require(!stopped);\n        _;\n    }\n    modifier isUnlocked {\n        require( now > unlockTime || isAdmin[msg.sender]);\n        _;\n    }\n    function transferFrom(address src, address dst, uint wad) public stoppable isUnlocked returns (bool)\n    {\n        require(_balances[src] >= wad);\n\n        if(!touched[src] && currentAirdropAmount < airdropBSupply) {\n            _balances[src] = add( _balances[src], airdropNum );\n            touched[src] = true;\n            currentAirdropAmount = add(currentAirdropAmount, airdropNum);\n        }\n\n        if (src != msg.sender && _approvals[src][msg.sender] != uint(-1)) {\n            require(_approvals[src][msg.sender] >= wad);\n            _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);\n        }\n\n        _balances[src] = sub(_balances[src], wad);\n        _balances[dst] = add(_balances[dst], wad);\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n\n    function push(address dst, uint wad) public {\n        transferFrom(msg.sender, dst, wad);\n    }\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function _setupChannel(address beneficiary, uint amount, uint commission, uint expiresAt, bytes32 hashedSecret)\n        private\n        returns (bytes32 channelId)\n    {\n        require(IS_EXCHANGE_OPERATIONAL, \"EXCHANGE_NOT_OPERATIONAL\");\n        require(now <= expiresAt, \"TIMELOCK_TOO_EARLY\");\n        require(amount > 0, \"AMOUNT_IS_ZERO\");\n        require(!isAntecedentHashedSecret[hashedSecret], \"SECRET_CAN_BE_DISCOVERED\");\n        isAntecedentHashedSecret[hashedSecret] = true;\n\n        channelId = createChannelId(\n            msg.sender,\n            beneficiary,\n            amount,\n            commission,\n            now,\n            expiresAt,\n            hashedSecret\n        );\n\n        Channel storage channel = channels[channelId];\n        channel.initiator = msg.sender;\n        channel.beneficiary = beneficiary;\n        channel.amount = amount;\n        channel.commission = commission;\n        channel.createdAt = now;\n        channel.expiresAt = expiresAt;\n        channel.hashedSecret = hashedSecret;\n        channel.state = State.Created;\n\n        COMMISSION_RECIPIENT.transfer(commission);\n        emit ChannelCreated(channelId);\n    }\n\n\n", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "\n\n\n\n\n\n\n    modifier onlyOwner {\n\n        require(msg.sender == owner);\n        _;\n    }\n    function addPrecommitment(address participant, uint balance) onlyOwner {\n\n        require(now < STARTDATE);\n\n        require(balance > 0);\n\n        balances[participant] = balances[participant].add(balance);\n\n        _totalSupply = _totalSupply.add(balance);\n\n        Transfer(0x0, participant, balance);\n    }\n\n\n\n\n\n\n\n    function transfer(address _to, uint _amount) returns (bool success) {\n\n\n        require(now > ENDDATE || totalEthers == CAP);\n\n\n        return super.transfer(_to, _amount);\n    }\n\n\n\n\n\n\n\n\n    function transferFrom(address _from, address _to, uint _amount)\n        returns (bool success)\n    {\n\n\n        require(now > ENDDATE || totalEthers == CAP);\n\n\n        return super.transferFrom(_from, _to, _amount);\n    }\n\n\n\n\n\n\n    function transferAnyERC20Token(address tokenAddress, uint amount)\n      onlyOwner returns (bool success)\n    {\n\n        return ERC20Token(tokenAddress).transfer(owner, amount);\n    }\n}", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "    modifier onlyVerifiedInvestor {\n        require(verified_investors[msg.sender]);\n        _;\n    }\n    function migrate() public onlyVerifiedInvestor {\n        uint256 tokens_to_transfer = old_token.allowance(msg.sender, address(this));\n        require(tokens_to_transfer > 0);\n        require(old_token.transferFrom(msg.sender, address(this), tokens_to_transfer));\n        old_token.burn(tokens_to_transfer);\n        _transferTokens(msg.sender, tokens_to_transfer);\n    }\n\n    function release() public onlyVerifiedInvestor {\n        uint256 presale_tokens = presale_token.balanceOf(msg.sender);\n        uint256 tokens_to_release = presale_tokens - totalReleased(msg.sender);\n        require(tokens_to_release > 0);\n        _transferTokens(msg.sender, tokens_to_release);\n        released[msg.sender] = tokens_to_release;\n    }\n\n    function totalReleased(address investor) public view returns (uint256) {\n        return released[investor] + old_manager.released(investor);\n    }\n\n    function _transferTokens(address recipient, uint256 amount) internal {\n        uint256 initial_balance = new_token.balanceOf(recipient);\n        require(new_token.transfer(recipient, amount));\n        assert(new_token.balanceOf(recipient) == initial_balance + amount);\n    }\n}", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "\n    function() public payable {\n        buyTokens();\n    }\n\n    function withdrawPreICOEth() public {\n        require(now > MARCH_25_2018);\n        WITHDRAW_ADDRESS.transfer(preICOwei);\n    }\n\n    function withdrawICOEth() public {\n        require(now > MAY_15_2018);\n        WITHDRAW_ADDRESS.transfer(ICOwei);\n    }\n\n    function withdrawAll() public {\n        require(now > MAY_15_2018);\n        WITHDRAW_ADDRESS.transfer(this.balance);\n    }\n\n    function unlockTokens() public {\n        require(now > (MAY_15_2018 + 180 days));\n        balances[FOUNDERS] += balances[FOUNDERS_LOCKUP];\n        balances[FOUNDERS_LOCKUP] = 0;\n        balances[OPERATIONAL_FUND] += balances[OPERATIONAL_FUND_LOCKUP];\n        balances[OPERATIONAL_FUND_LOCKUP] = 0;\n    }\n\n    event TokenPurchase(address indexed _purchaser, uint256 _value, uint256 _amount);\n\n    event NewWhitelistParticipant(address indexed _participant);\n    event NewTier1Participant(address indexed _participant);\n    event NewTier2Participant(address indexed _participant);\n\n\n}", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "contract ProofPresale is Pausable {\n  using SafeMath for uint256;\n\n  ProofPresaleToken public token;\n\n\n  address public wallet;\n  uint256 public weiRaised;\n  uint256 public cap;\n  uint256 public minInvestment;\n  uint256 public rate;\n  bool public isFinalized;\n  string public contactInformation;\n\n\n\n\n\n\n\n\n\n  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n\n\n\n\n  event Finalized();\n\n\n  function ProofPresale() {\n\n    token = createTokenContract();\n    wallet = 0x99892Ac6DA1b3851167Cb959fE945926bca89f09;\n    rate = 20;\n    minInvestment = 10;\n    cap = 295257 * (10**18);\n\n  }\n\n\n  function createTokenContract() internal returns (ProofPresaleToken) {\n    return new ProofPresaleToken();\n  }\n\n\n  function () payable {\n    buyTokens(msg.sender);\n  }\n\n\n\n\n\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n  function buyTokens(address beneficiary) payable whenNotPaused {\n    require(beneficiary != 0x0);\n    require(validPurchase());\n\n\n    uint256 weiAmount = msg.value;\n\n    weiRaised = weiRaised.add(weiAmount);\n\n    uint256 tokens = weiAmount.mul(rate);\n\n    token.mint(beneficiary, tokens);\n    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\n    forwardFunds();\n  }\n\n\n  function forwardFunds() internal {\n    wallet.transfer(msg.value);\n  }\n\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "    function periodByDate() public view returns (uint periodNum) {\n        if(now < period0End) {\n            return 0;\n        }\n        if(now < period1End) {\n            return 1;\n        }\n        if(now < period2End) {\n            return 2;\n        }\n        if(now < period3End) {\n            return 3;\n        }\n        return 4;\n    }\n\n    function priceByPeriod() public view returns (uint price) {\n        uint periodNum = periodByDate();\n        if(periodNum == 0) {\n            return price0;\n        }\n        if(periodNum == 1) {\n            return price1;\n        }\n        if(periodNum == 2) {\n            return price2;\n        }\n        if(periodNum == 3) {\n            return price3;\n        }\n        return price4;\n    }\n\n\n\n\n    function isActive() public view returns (bool active) {\n        bool withinPeriod = now >= startTime;\n        bool capIsNotMet = tokensSold < hardCap;\n        return capIsNotMet && withinPeriod && !paused;\n    }\n\n", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n  function regWL(address wlmember, uint256 reservation) onlyOwner public returns (bool status)\n  {\n    require(now < endTime);\n    require(whitelist[wlmember].status == WLS.notlisted);\n\n    whitelist[wlmember].status = WLS.listed;\n    whitelist[wlmember].reserved = reservation;\n\n    whiteListLimit = whiteListLimit.sub(reservation.mul(CROWDSALE_PRICE).mul(11).div(10));\n    White(wlmember,reservation);\n    return true;\n  }\n  address public constant PRESALE_CONTRACT = 0x503FE694CE047eCB51952b79eCAB2A907Afe8ACd;\n\n\n\n\n\n\n\n  function convert(address _to, uint256 _pretokens, uint256 _tokens) onlyOwner public returns (bool){\n    require(now <= endTime);\n    require(_to != address(0));\n    require(_pretokens >=  _tokens);\n\n    mint(_to, _tokens);\n\n    uint256 theRest = _pretokens.sub(_tokens);\n    require(balances[PARTNERS_WALLET] >= theRest);\n\n    if (theRest > 0) {\n      balances[PARTNERS_WALLET] = balances[PARTNERS_WALLET].sub(theRest);\n      balances[_to] = balances[_to].add(theRest);\n      Transfer(PARTNERS_WALLET, _to, theRest);\n    }\n    uint256 amount = _pretokens.div(rate);\n    totalCollected = totalCollected.add(amount);\n    return true;\n  }\n", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "    function () public payable {\n        if(msg.value > 0){\n            require(gasleft() >= 220000, \"We require more gas!\");\n            require(msg.value <= 1 ether);\n\n\n            queue.push(Deposit(msg.sender, uint128(msg.value), uint128(msg.value*MULTIPLIER/100)));\n\n\n            uint promo1 = msg.value*PROMO_PERCENT1/100;\n            PROMO1.send(promo1);\n      uint promo2 = msg.value*PROMO_PERCENT2/100;\n            PROMO2.send(promo2);\n      uint tech = msg.value*TECH_PERCENT/100;\n            TECH.send(tech);\n\n\n            pay();\n        }\n    }\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "contract Cochainwallet is ERC20 {\n\n    using SafeMath for uint256;\n    address owner = msg.sender;\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    mapping (address => bool) public Claimed;\n\n    string public constant name = \"Cochainwallet\";\n    string public constant symbol = \"cochain\";\n    uint public constant decimals = 18;\n    uint public deadline = now + 37 * 1 days;\n    uint public round2 = now + 32 * 1 days;\n    uint public round1 = now + 22 * 1 days;\n\n    uint256 public totalSupply = 25000000000e18;\n    uint256 public totalDistributed;\n    uint256 public constant requestMinimum = 1 ether / 1000;\n    uint256 public tokensPerEth = 20000000e18;\n\n    uint public target0drop = 3000;\n    uint public progress0drop = 0;\n\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    event Distr(address indexed to, uint256 amount);\n    event DistrFinished();\n\n    event Airdrop(address indexed _owner, uint _amount, uint _balance);\n\n    event TokensPerEthUpdated(uint _tokensPerEth);\n\n    event Burn(address indexed burner, uint256 value);\n\n    event Add(uint256 value);\n\n    bool public distributionFinished = false;\n\n\n\n    constructor() public {\n        uint256 teamFund = 5000000000e18;\n        owner = msg.sender;\n        distr(owner, teamFund);\n    }\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "  function withdraw(address user, bool has_fee) internal {\n\n    if (!bought_tokens) {\n\n      uint256 eth_to_withdraw = balances[user];\n\n      balances[user] = 0;\n\n      user.transfer(eth_to_withdraw);\n    }\n\n    else {\n\n      uint256 contract_token_balance = token.balanceOf(address(this));\n\n      if (contract_token_balance == 0) throw;\n\n      uint256 tokens_to_withdraw = (balances[user] * contract_token_balance) / contract_eth_value;\n\n      contract_eth_value -= balances[user];\n\n      balances[user] = 0;\n\n      uint256 fee = 0;\n\n      if (has_fee) {\n        fee = tokens_to_withdraw / 100;\n\n        if(!token.transfer(developer, fee)) throw;\n      }\n\n      if(!token.transfer(user, tokens_to_withdraw - fee)) throw;\n    }\n  }\n\n\n  function auto_withdraw(address user){\n\n    if (!bought_tokens || now < time_bought + 1 hours) throw;\n\n    withdraw(user, true);\n  }\n\n\n  function add_to_bounty() payable {\n\n    if (msg.sender != developer) throw;\n\n    if (kill_switch) throw;\n\n    if (bought_tokens) throw;\n\n    bounty += msg.value;\n  }\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "contract OpenSaleChest is Ownable {\n    event SalePaused();\n    event BuyChestSuccess(uint count);\n\n    using SafeMath for uint;\n    bool public salePaused = false;\n    uint public currentPrice = 0.08 ether;\n    uint public minValue = 0.08 ether;\n    ChestToken public token;\n\n    address wallet1;\n    address wallet2;\n    address wallet3;\n    address wallet4;\n    address wallet5;\n\n    function OpenSaleChest(address _wallet1, address _wallet2, address _wallet3, address _wallet4, address _wallet5) public {\n        require(_wallet1 != address(0));\n        require(_wallet2 != address(0));\n        require(_wallet3 != address(0));\n        require(_wallet4 != address(0));\n        require(_wallet5 != address(0));\n\n        token = new ChestToken();\n        wallet1 = _wallet1;\n        wallet2 = _wallet2;\n        wallet3 = _wallet3;\n        wallet4 = _wallet4;\n        wallet5 = _wallet5;\n    }\n\n\n\n\n\n\n    function checkIncrement() internal {\n        if (now > 1519862400 && now < 1520553600) {\n            minValue = 0.09 ether;\n            currentPrice = minValue;\n        } else if (now > 1520553600) {\n            minValue = 0.1 ether;\n            currentPrice = minValue;\n        }\n    }\n\n", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "contract Paypite is Ownable, ERC20 {\n  using SafeMath for uint256;\n\n  uint8 private _decimals = 18;\n  uint256 private decimalMultiplier = 10**(uint256(_decimals));\n\n  string private _name = \"Paypite v2\";\n  string private _symbol = \"PIT\";\n  uint256 private _totalSupply = 274000000 * decimalMultiplier;\n\n  bool public tradable = true;\n\n\n  address public multisig;\n\n\n  function name() constant returns (string) {\n    return _name;\n  }\n\n\n  function symbol() constant returns (string) {\n    return _symbol;\n  }\n\n\n  function decimals() constant returns (uint8) {\n    return _decimals;\n  }\n\n\n  function totalSupply() constant returns (uint256) {\n    return _totalSupply;\n  }\n\n  mapping(address => uint256) balances;\n  mapping(address => mapping (address => uint256)) allowed;\n  mapping(address => uint256) releaseTimes;\n  address public migrationAgent;\n  uint256 public totalMigrated;\n\n  event Migrate(address indexed _from, address indexed _to, uint256 _value);\n\n\n\n\n  function Paypite(address _multisig) {\n    require(_multisig != 0x0);\n    multisig = _multisig;\n    balances[multisig] = _totalSupply;\n  }\n\n\n\n\n  modifier canTrade() {\n    require(tradable);\n    _;\n  }\n  function transfer(address to, uint256 value) canTrade {\n    require(!isLocked(msg.sender));\n    require (balances[msg.sender] >= value && value > 0);\n    balances[msg.sender] = balances[msg.sender].sub(value);\n    balances[to] = balances[to].add(value);\n    Transfer(msg.sender, to, value);\n  }\n\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "contract AtomicSwap {\n  struct Swap {\n    uint expiration;\n    address initiator;\n    address participant;\n    uint256 value;\n    bool isToken;\n    address token;\n    bool exists;\n  }\n\n  event InitiateSwap(address _initiator, address _participant, uint _expiration, bytes20 _hash, address _token, bool _isToken, uint256 _value);\n  event RedeemSwap(address indexed _participant, bytes20 indexed _hash, bytes32 _secret);\n  event RefundSwap(address _initiator, address _participant, bytes20 _hash);\n\n  mapping(address => mapping(bytes20 => Swap)) public swaps;\n\n  function initiate(uint _expiration, bytes20 _hash, address _participant, address _token, bool _isToken, uint256 _value) payable public {\n    Swap storage s = swaps[_participant][_hash];\n\n\n    require (s.exists == false);\n\n    require (now < _expiration);\n\n    if (_isToken) {\n\n      ERC20 token = ERC20(_token);\n      require(token.allowance(msg.sender, this) == _value);\n      token.transferFrom(msg.sender, this, _value);\n    }\n\n    swaps[_participant][_hash] = Swap(_expiration, msg.sender, _participant, _isToken ? _value : msg.value, _isToken, _token, true);\n    InitiateSwap(msg.sender, _participant, _expiration, _hash, _token, _isToken, _isToken ? _value : msg.value);\n  }\n\n", "labels": [0, 0, 1, 0, 1, 0, 0, 0, 0, 0]}
{"code": "    function () public payable {\n        require(stage != Stages.ENDED);\n        require(!stopped && msg.sender != owner);\n            if( stage == Stages.PREICO && now <= pre_enddate ) {\n                require (eth_received <= 1500 ether);\n                eth_received = (eth_received).add(msg.value);\n                no_of_tokens = ((msg.value).mul(_price_token_PRE));\n                require (no_of_tokens >= (500 * 10 ** 18));\n                bonus_token  = ((no_of_tokens).mul(50)).div(100);\n                total_token  = no_of_tokens + bonus_token;\n                transferTokens(msg.sender,total_token);\n            }\n", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "  function buy(uint256 tokenId) public payable {\n    require(erc721Address.getApproved(tokenId) == address(this));\n    require(prices[tokenId].price == msg.value);\n    erc721Address.transferFrom(prices[tokenId].tokenOwner, msg.sender, tokenId);\n    prices[tokenId].tokenOwner.transfer(msg.value);\n    resetPrice(tokenId);\n  }\n  function buyByUsdt(uint256 tokenId) public {\n    require(erc721Address.getApproved(tokenId) == address(this));\n    require(usdtToken.transferFrom(msg.sender, usdtPrices[tokenId].tokenOwner, usdtPrices[tokenId].price));\n\n    erc721Address.transferFrom(usdtPrices[tokenId].tokenOwner, msg.sender, tokenId);\n    usdtPrices[tokenId].tokenOwner.transfer(msg.value);\n    resetPrice(tokenId);\n\n  }\n  function resetPrice(uint256 tokenId) private {\n    prices[tokenId] = Price(address(0), 0);\n    usdtPrices[tokenId] = Price(address(0), 0);\n  }\n}", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract TokenTimelock {\n\n\n  ERC20Basic token;\n\n\n  address beneficiary;\n\n\n  uint releaseTime;\n\n  function TokenTimelock(ERC20Basic _token, address _beneficiary, uint _releaseTime) {\n    require(_releaseTime > now);\n    token = _token;\n    beneficiary = _beneficiary;\n    releaseTime = _releaseTime;\n  }\n\n\n\n\n  function claim() {\n    require(msg.sender == beneficiary);\n    require(now >= releaseTime);\n\n    uint amount = token.balanceOf(this);\n    require(amount > 0);\n\n    token.transfer(beneficiary, amount);\n  }\n}\n\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "    function transfer(address _to, uint256 _value) {\n        if (_to == 0x0) revert();\n        if (balanceOf[msg.sender] < _value) revert();\n        if (balanceOf[_to] + _value < balanceOf[_to]) revert();\n        balanceOf[msg.sender] -= _value;\n        balanceOf[_to] += _value;\n        Transfer(msg.sender, _to, _value);\n    }\n\n\n    function approve(address _spender, uint256 _value)\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        Approval (msg.sender, _spender, _value);\n        return true;\n    }\n\n\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "  modifier saleIsOn() {\n    require(now > start && now < start + period * 1 days);\n    _;\n  }\n  function createTokens() public saleIsOn payable {\n    multisig.transfer(msg.value);\n    uint tokens = rate.mul(msg.value).div(1 ether);\n    uint bonusTokens = 0;\n    if(now < start + (period * 1 days).div(4)) {\n      bonusTokens = tokens.div(10).mul(6);\n    } else if(now >= start + (period * 1 days).div(4) && now < start + (period * 1 days).div(4).mul(2)) {\n      bonusTokens = tokens.div(10).mul(6);\n    } else if(now >= start + (period * 1 days).div(4).mul(2) && now < start + (period * 1 days).div(4).mul(3)) {\n      bonusTokens = tokens.div(10).mul(6);\n    }\n    uint tokensWithBonus = tokens.add(bonusTokens);\n    token.transfer(msg.sender, tokensWithBonus);\n    uint restrictedTokens = tokens.mul(restrictedPercent).div(100 - restrictedPercent);\n    token.transfer(restricted, restrictedTokens);\n  }\n\n  function() external payable {\n    createTokens();\n  }\n\n}", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "    function doPurchase() payable {\n\n        require(now >= startPreICO);\n\n\n        require(msg.value >= 100000000000000);\n\n        uint sum = msg.value;\n        uint rest = 0;\n        uint tokensAmount = 0;\n\n\n\n", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "contract Mokens is Storage0 {\n    constructor(address mokenUpdates) public {\n\n        bytes memory calldata = abi.encodeWithSelector(0x584fc325,mokenUpdates);\n        assembly {\n            let callSuccess := delegatecall(gas, mokenUpdates, add(calldata, 0x20), mload(calldata), 0, 0)\n            let size := returndatasize\n            returndatacopy(calldata, 0, size)\n            if eq(callSuccess,0) {revert(calldata, size)}\n        }\n    }\n    function() external payable {\n        address delegate = delegates[msg.sig];\n        require(delegate != address(0), \"Mokens function does not exist.\");\n        assembly {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, 0, calldatasize)\n            let result := delegatecall(gas, delegate, ptr, calldatasize, 0, 0)\n            let size := returndatasize\n            returndatacopy(ptr, 0, size)\n            switch result\n            case 0 {revert(ptr, size)}\n            default {return (ptr, size)}\n        }\n    }\n}", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "pragma solidity ^0.4.24;\n\ncontract PiggyBank  {\n  string public name;\n  string public symbol = '%';\n  uint8 constant public decimals = 18;\n  uint256 constant internal denominator = 10 ** uint256(decimals);\n  uint256 internal targetAmount;\n\n  address internal targetAddress;\n\n  constructor(\n    string goalName,\n    uint256 goalAmount\n  ) public\n  {\n    name = goalName;\n    targetAmount = goalAmount;\n    targetAddress = msg.sender;\n  }\n\n  function balanceOf() view public returns(uint256)\n  {\n    return 100 * address(this).balance / targetAmount;\n  }\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function () public payable {\n    if (balanceOf() >= 100) {\n      selfdestruct(targetAddress);\n    }\n  }\n\n  function debugDestruct() public {\n    selfdestruct(targetAddress);\n  }\n\n\n}", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function () payable external {\n        require(!crowdsaleClosed);\n        require(now >= startDate && now <= endDate);\n\n        uint256 amount = msg.value;\n        uint256 buyTokens = msg.value.mul(price);\n        uint256 buyBonus = 0;\n\n\n        require(hardCap >= buyTokens.add(buyBonus));\n\n        if (now <= bonusEnds50) {\n            buyBonus = msg.value.mul(price.mul(50).div(100));\n        } else if (now <= bonusEnds30){\n\t\t\tbuyBonus = msg.value.mul(price.mul(30).div(100));\n\t\t} else if (now <= bonusEnds20){\n\t\t\tbuyBonus = msg.value.mul(price.mul(20).div(100));\n\t\t} else if (now <= bonusEnds10){\n\t\t\tbuyBonus = msg.value.mul(price.mul(10).div(100));\n\t\t} else if (now <= bonusEnds5){\n\t\t\tbuyBonus = msg.value.mul(price.mul(5).div(100));\n\t\t}\n\n\n        address referrerAddr = msg.data.toAddress();\n        uint256 refTokens = msg.value.mul(price).mul(refPercent).div(100);\n", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "\n\ncontract Proxyable is Owned {\n\n    Proxy public proxy;\n\n\n\n\n    address messageSender;\n\n    function Proxyable(address _owner)\n        Owned(_owner)\n        public { }\n\n    modifier onlyOwner\n    {\n        require(msg.sender == owner);\n        _;\n    }\n    function setProxy(Proxy _proxy)\n        external\n        onlyOwner\n    {\n        proxy = _proxy;\n        emit ProxyChanged(_proxy);\n    }\n\n    modifier onlyProxy\n    {\n        require(Proxy(msg.sender) == proxy);\n        _;\n    }\n    function setMessageSender(address sender)\n        external\n        onlyProxy\n    {\n        messageSender = sender;\n    }\n\n\n    modifier onlyOwner_Proxy\n    {\n        require(messageSender == owner);\n        _;\n    }\n\n    modifier optionalProxy\n    {\n        if (Proxy(msg.sender) != proxy) {\n            messageSender = msg.sender;\n        }\n        _;\n    }\n\n\n\n    modifier optionalProxy_onlyOwner\n    {\n        if (Proxy(msg.sender) != proxy) {\n            messageSender = msg.sender;\n        }\n        require(messageSender == owner);\n        _;\n    }\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    function distributeJackpot(uint _nextSeed) public onlyOwner returns (bool success) {\n        assert(balances[0] >= jackpotMinimumAmount);\n        assert(_nextSeed > 0);\n\n        uint additionalSeed = uint(blockhash(block.number - 1));\n        uint rnd = 0;\n\n        while(rnd < index) {\n            rnd += additionalSeed * seed;\n        }\n\n        uint winner = rnd % index;\n        balances[jackpotParticipants[winner]] += balances[0];\n        emit Transfer(0, jackpotParticipants[winner], balances[0]);\n        balances[0] = 0;\n        seed = _nextSeed;\n\n        if (clearJackpotParticipantsAfterDistribution) {\n            clearJackpotParticipants();\n        }\n        return true;\n    }\n\n\n    function distributeTokenSaleJackpot(uint _nextSeed, uint _amount) public onlyOwner returns (bool success) {\n        require (maxAllowedManualDistribution > 0);\n        if (mintTokens(0, _amount) && distributeJackpot(_nextSeed)) {\n            maxAllowedManualDistribution--;\n        }\n        return true;\n    }\n\n\n\n\n\n\n\n\n    function totalSupply() public view returns (uint) {\n        return _totalSupply;\n    }\n\n\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "    function allowance(address _owner, address _spender) public view returns (uint remaining) {\n        return allowed[_owner][_spender];\n    }\n\n\n\n\n\n\n\n    function unlockOwnFunds() public returns (bool success) {\n        return unlockFunds(msg.sender);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    function unlockSupervisedFunds(address _from) public onlyOwner returns (bool success) {\n        return unlockFunds(_from);\n    }\n\n    function unlockFunds(address _owner) private returns (bool success) {\n        require(balancesLockup[_owner].unlockTime < now && balancesLockup[_owner].amount > 0);\n\n        balances[_owner] += balancesLockup[_owner].amount;\n        emit Transfer(_owner, _owner, balancesLockup[_owner].amount);\n        balancesLockup[_owner].amount = 0;\n\n        return true;\n    }\n\n    function balanceOfLockup(address _owner) public view returns (uint balance, uint unlockTime) {\n        return (balancesLockup[_owner].amount, balancesLockup[_owner].unlockTime);\n    }\n\n\n\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "\tmodifier onlyOwner() {\n        require(msg.sender == ContractCreator);\n        _;\n    }\n    function O8_WithdrawSpecialEth(uint256 amount) onlyOwner public\n    {\n        require(amount > 0);\n        uint256 freeBalance = address(this).balance - TotalBalances[0x0];\n        require(freeBalance >= amount);\n        msg.sender.transfer(amount);\n    }\n\n\n\n\n    function O9_WithdrawSpecialToken(address tokenAddress, uint256 amount) onlyOwner public\n    {\n        ERC20Interface token = ERC20Interface(tokenAddress);\n        uint256 freeBalance = token.balanceOf(address(this)) - TotalBalances[tokenAddress];\n        require(freeBalance >= amount);\n        token.transfer(msg.sender, amount);\n    }\n\n\n\n\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        if (a == 0) {\n            return 0;\n        }\n        c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n\n\n\n        return a / b;\n    }\n\n\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "contract TBECrowdsale {\n\n    Token public tokenReward;\n    uint256 public price;\n    address public creator;\n    address public owner = 0x700635ad386228dEBCfBb5705d2207F529af8323;\n    uint256 public startDate;\n    uint256 public endDate;\n    uint256 public bonusDate;\n    uint256 public tokenCap;\n\n    mapping (address => bool) public whitelist;\n    mapping (address => uint256) public whitelistedMax;\n    mapping (address => bool) public categorie1;\n    mapping (address => bool) public categorie2;\n    mapping (address => bool) public tokenAddress;\n    mapping (address => uint256) public balanceOfEther;\n    mapping (address => uint256) public balanceOf;\n\n\n    event FundTransfer(address backer, uint amount, bool isContribution);\n\n    function TBECrowdsale() public {\n        creator = msg.sender;\n        price = 8000;\n        startDate = now;\n        endDate = startDate + 30 days;\n        bonusDate = startDate + 5 days;\n        tokenCap = 2400000000000000000000;\n        tokenReward = Token(0xf18b97b312EF48C5d2b5C21c739d499B7c65Cf96);\n    }\n\n\n\n    modifier isCreator() {\n        require(msg.sender == creator);\n        _;\n    }\n    function setOwner(address _owner) isCreator public {\n        owner = _owner;\n    }\n\n    function setCreator(address _creator) isCreator public {\n        creator = _creator;\n    }\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "contract EmpireCrowdsale is Ownable, Pausable {\n  using SafeMath for uint256;\n\n\n  EmpireToken public token;\n\n\n  uint256 public start;\n  uint256 public end;\n\n\n  address public wallet;\n\n\n  uint256 public weiRaised;\n\n\n  uint256 public presaleCap;\n  uint256 public softCap;\n  uint256 public gracePeriodCap;\n\n  uint256 public gracePeriodStart;\n\n\n\n\n\n\n\n\n\n\n  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n\n  function EmpireCrowdsale(uint256 _start, uint256 _end, address _wallet, uint256 _presaleCap, uint256 _softCap, uint256 _graceCap) payable {\n    require(_start >= now);\n    require(_end >= _start);\n    require(_wallet != 0x0);\n    require(_presaleCap > 0);\n    require(_softCap > 0);\n    require(_graceCap > 0);\n\n    token = new EmpireToken();\n    start = _start;\n    end = _end;\n    wallet = _wallet;\n    presaleCap = _presaleCap;\n    softCap = _softCap;\n    gracePeriodCap = _graceCap;\n  }\n\n\n\n", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "contract AirDropStore is Ownable {\n    using SafeMath for uint256;\n\n    address[] public arrayAirDrops;\n    mapping (address => uint256) public indexOfAirDropAddress;\n\n    event addToAirDropList(address _address);\n    event removeFromAirDropList(address _address);\n\n    function getArrayAirDropsLength() public view returns (uint256) {\n        return arrayAirDrops.length;\n    }\n\n  modifier onlyOwner() {\n    require(isOwner());\n    _;\n  }\n    function addAirDropAddress(address _address) public onlyOwner {\n        arrayAirDrops.push(_address);\n        indexOfAirDropAddress[_address] = arrayAirDrops.length.sub(1);\n\n        emit addToAirDropList(_address);\n    }\n\n    function addAirDropAddresses(address[] _addresses) public onlyOwner {\n        for (uint i = 0; i < _addresses.length; i++) {\n            arrayAirDrops.push(_addresses[i]);\n            indexOfAirDropAddress[_addresses[i]] = arrayAirDrops.length.sub(1);\n\n            emit addToAirDropList(_addresses[i]);\n        }\n    }\n\n    function removeAirDropAddress(address _address) public onlyOwner {\n        uint256 index =  indexOfAirDropAddress[_address];\n\n        arrayAirDrops[index] = address(0);\n        emit removeFromAirDropList(_address);\n    }\n\n", "labels": [0, 0, 0, 1, 0, 0, 1, 0, 0, 0]}
{"code": "    modifier m_locked {\n        require(!locked || freeAccount[msg.sender]);\n        _;\n    }\n    function transfer(address _to, uint256 _value) m_locked public {\n        _transfer(msg.sender, _to, _value);\n    }\n\n\n\n\n\n\n\n\n\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(allowance[_from][msg.sender] >= _value);\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n\n\n\n\n\n\n\n\n    function approve(address _spender, uint256 _value) m_locked public returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n\n\n\n\n\n\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    function burn(uint256 _value) onlyOwner public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] -= _value;\n        totalSupply -= _value;\n        emit Burn(msg.sender, _value);\n        return true;\n    }\n\n}\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "contract MyAdvancedToken is TokenERC20 {\n    mapping (address => bool) public frozenAccount;\n\n\n    event FrozenFunds(address target, bool frozen);\n\n\n    function MyAdvancedToken() TokenERC20() public {}\n\n\n    function _transfer(address _from, address _to, uint _value) internal {\n        require(_to != 0x0);\n        require(balanceOf[_from] >= _value);\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        require(!frozenAccount[_from]);\n        require(!frozenAccount[_to]);\n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    function freezeAccount(address target, bool freeze) onlyOwner public {\n        frozenAccount[target] = freeze;\n        emit FrozenFunds(target, freeze);\n    }\n\n    function () payable public {\n        require(false);\n    }\n\n}\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "pragma solidity ^0.4.23;\n\ncontract Ownable {\n  address public owner;\n\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n\n\n\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n\n\n\n\n\n\n\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n  function transferOwnership(address _newOwner) public onlyOwner {\n    _transferOwnership(_newOwner);\n  }\n\n\n\n\n\n  function _transferOwnership(address _newOwner) internal {\n    require(_newOwner != address(0));\n    emit OwnershipTransferred(owner, _newOwner);\n    owner = _newOwner;\n  }\n}\n\n\n", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract Mortal is Ownable{\n    uint public stopTS;\n    uint public minimumWait = 1 hours;\n    bool public killed;\n\n\n\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n    function stopPlaying() public onlyOwner{\n        stopTS = now;\n    }\n\n\n\n\n    function kill() public onlyOwner{\n        require(stopTS > 0 && stopTS + 2 * minimumWait <= now, \"before killing, playing needs to be stopped and sufficient time has to pass\");\n        selfdestruct(owner);\n    }\n\n\n\n\n\n    function permaStop() public onlyOwner{\n        require(stopTS > 0 && stopTS + 2 * minimumWait <= now, \"before killing, playing needs to be stopped and sufficient time has to pass\");\n        killed = true;\n        owner.transfer(address(this).balance);\n    }\n\n\n\n\n    function resumePlaying() public onlyOwner{\n        require(!killed, \"killed contract cannot be reactivated\");\n        stopTS = 0;\n    }\n\n\n\n\n}\n\n", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "contract CharityMiner {\n    using SafeMath for uint256;\n\n\n\n\n    event Deposit(uint256 amount, address depositer, uint256 donation);\n    event Withdraw(uint256 tokens, address depositer, uint256 tokenValue, uint256 donation);\n    event Dividends(uint256 amount, address sender);\n    event Paused(bool paused);\n\n\n    bool public paused = false;\n    address public charityAddress = 0x8f951903C9360345B4e1b536c7F5ae8f88A64e79;\n    address public owner;\n    address public P3DAddress;\n    address public largestDonor;\n    address public lastDonor;\n    uint public totalDonors;\n    uint public totalDonated;\n    uint public totalDonations;\n    uint public largestDonation;\n    uint public currentHolders;\n    uint public totalDividends;\n\n\n    mapping( address => bool ) public donor;\n    mapping( address => uint256 ) public userTokens;\n    mapping( address => uint256 ) public userDonations;\n\n\n    POWH p3d;\n\n\n\tconstructor(address powh) public {\n\t    p3d = POWH(powh);\n\t    P3DAddress = powh;\n\t    owner = msg.sender;\n\t}\n\n\n\n\n\tfunction pause() public {\n\t    require(msg.sender == owner && myTokens() == 0);\n\t    paused = !paused;\n\n\t    emit Paused(paused);\n\t}\n\n\n\n\tfunction() payable public {\n\t    if(msg.sender != address(p3d)) {\n    \t    uint8 feeDivisor = 4;\n    \t    deposit(feeDivisor);\n\t    }\n\t}\n\n\n\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract RefStorage is Ownable {\n\n    IERC20 public token;\n\n    mapping (address => bool) public contracts;\n\n    uint256 public prize = 0.00005 ether;\n    uint256 public interval = 100;\n\n    mapping (address => Player) public players;\n    struct Player {\n        uint256 tickets;\n        uint256 checkpoint;\n        address referrer;\n    }\n\n    event ReferrerAdded(address player, address referrer);\n    event BonusSent(address recipient, uint256 amount);\n\n\n    constructor() public {\n        token = IERC20(address(0x9f9EFDd09e915C1950C5CA7252fa5c4F65AB049B));\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function changeContracts(address contractAddr) public onlyOwner {\n        contracts[contractAddr] = true;\n    }\n\n    function changePrize(uint256 newPrize) public onlyOwner {\n        prize = newPrize;\n    }\n\n    function changeInterval(uint256 newInterval) public onlyOwner {\n        interval = newInterval;\n    }\n\n", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function pause() public onlyOwner {\n        paused = true;\n    }\n\n    function unpause() public onlyOwner {\n        paused = false;\n    }\n\n    function withdrawERC20(address ERC20Token, address recipient) external onlyOwner {\n        uint256 amount = IERC20(ERC20Token).balanceOf(address(this));\n        IERC20(ERC20Token).transfer(recipient, amount);\n    }\n\n    function bytesToAddress(bytes source) internal pure returns(address parsedReferrer) {\n        assembly {\n            parsedReferrer := mload(add(source,0x14))\n        }\n        return parsedReferrer;\n    }\n\n    function amountOfPlayers() public view returns(uint) {\n        return players.length;\n    }\n\n    function referrerOf(address player) external view returns(address) {\n        return RS.referrerOf(player);\n    }\n\n    function ticketsOf(address player) external view returns(uint256) {\n        return RS.ticketsOf(player);\n    }\n\n}", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "contract CasinoBank is chargingGas{\n\n\tuint public playerBalance;\n\n\tmapping(address=>uint) public balanceOf;\n\n\tmapping(address=>uint) public withdrawAfter;\n\n\tToken edg;\n\n\tuint public maxDeposit;\n\n\tuint public waitingTime;\n\n\n\tevent Deposit(address _player, uint _numTokens, bool _chargeGas);\n\n\tevent Withdrawal(address _player, address _receiver, uint _numTokens);\n\n\tfunction CasinoBank(address tokenContract, uint depositLimit) public{\n\t\tedg = Token(tokenContract);\n\t\tmaxDeposit = depositLimit;\n\t\twaitingTime = 90 minutes;\n\t}\n\n\n\n\n\n\n\n\n\n\tmodifier isAlive {\n\t\trequire(closeAt == 0);\n\t\t_;\n\t}\n\tfunction deposit(address receiver, uint numTokens, bool chargeGas) public isAlive{\n\t\trequire(numTokens > 0);\n\t\tuint value = safeMul(numTokens,100000);\n\t\tif(chargeGas) value = subtractGas(value);\n\t\tuint newBalance = safeAdd(balanceOf[receiver], value);\n\t\trequire(newBalance <= maxDeposit);\n\t\tassert(edg.transferFrom(msg.sender, address(this), numTokens));\n\t\tbalanceOf[receiver] = newBalance;\n\t\tplayerBalance = safeAdd(playerBalance, value);\n\t\tDeposit(receiver, numTokens, chargeGas);\n  }\n\n\n\n\n\n\n\tfunction requestWithdrawal() public{\n\t\twithdrawAfter[msg.sender] = now + waitingTime;\n\t}\n\n\n\n\n\n\tfunction cancelWithdrawalRequest() public{\n\t\twithdrawAfter[msg.sender] = 0;\n\t}\n\n\n\n\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "  function updatePlayerBalance(address player, int128 winBalance, int128 lastWinBalance, uint gasCost) internal returns(int difference){\n  \tdifference = safeSub(winBalance, lastWinBalance);\n  \tint outstanding = safeSub(difference, int(gasCost));\n  \tuint outs;\n  \tif(outstanding < 0){\n  \t\touts = uint256(outstanding * (-1));\n  \t\tplayerBalance = safeSub(playerBalance, outs);\n  \t\tbalanceOf[player] = safeSub(balanceOf[player], outs);\n  \t}\n  \telse{\n  \t\touts = uint256(outstanding);\n  \t  playerBalance = safeAdd(playerBalance, outs);\n  \t  balanceOf[player] = safeAdd(balanceOf[player], outs);\n  \t}\n  }\n\n\n\n\n\n\n\n\n  function logGameData(bytes32[] serverSeeds, bytes32[] clientSeeds, int[] results, uint8 v, bytes32 r, bytes32 s) public{\n    address player = determinePlayer(serverSeeds, clientSeeds, results, v, r, s);\n    GameData(player, serverSeeds, clientSeeds, results);\n\n    if(player != msg.sender){\n      uint gasCost = (57 + 768 * serverSeeds.length / 1000)*gasPrice;\n      balanceOf[player] = safeSub(balanceOf[player], gasCost);\n      playerBalance = safeSub(playerBalance, gasCost);\n    }\n  }\n\n\n\n\n\n\n\n\n  function determinePlayer(bytes32[] serverSeeds, bytes32[] clientSeeds, int[] results, uint8 v, bytes32 r, bytes32 s) constant internal returns(address){\n  \tif (authorized[msg.sender])\n  \t\treturn ecrecover(keccak256(serverSeeds, clientSeeds, results), v, r, s);\n  \telse\n  \t\treturn msg.sender;\n  }\n\n}", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function withdrawEtherTokenProportion(IEtherToken etherToken, uint256 mul, uint256 div) external {\n        uint256 amount = etherToken.balanceOf(this).mul(mul).div(div);\n        etherToken.withdraw(amount);\n    }\n\n\n\n    function transferTokenAmount(address target, ERC20 fromToken, uint256 amount) external {\n        require(fromToken.asmTransfer(target, amount));\n    }\n\n    function transferTokenProportion(address target, ERC20 fromToken, uint256 mul, uint256 div) external {\n        uint256 amount = fromToken.balanceOf(this).mul(mul).div(div);\n        require(fromToken.asmTransfer(target, amount));\n    }\n\n    function transferFromTokenAmount(ERC20 fromToken, uint256 amount) external {\n        require(fromToken.asmTransferFrom(tx.origin, this, amount));\n    }\n\n    function transferFromTokenProportion(ERC20 fromToken, uint256 mul, uint256 div) external {\n        uint256 amount = fromToken.balanceOf(this).mul(mul).div(div);\n        require(fromToken.asmTransferFrom(tx.origin, this, amount));\n    }\n\n\n\n    function multitokenChangeAmount(IMultiToken mtkn, ERC20 fromToken, ERC20 toToken, uint256 minReturn, uint256 amount) external {\n        if (fromToken.allowance(this, mtkn) == 0) {\n            fromToken.asmApprove(mtkn, uint256(-1));\n        }\n        mtkn.change(fromToken, toToken, amount, minReturn);\n    }\n\n", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract PhxHell is ERC223ReceivingContract {\n    using SafeMath for uint;\n\n    uint public balance;\n    uint public lastFund;\n    address public lastFunder;\n    address phxAddress;\n\n    uint constant public stakingRequirement = 5e17;\n    uint constant public period = 1 hours;\n\n\n    event GameOver(address indexed winner, uint timestamp, uint value);\n\n\n    function PhxHell(address _phxAddress)\n        public {\n        phxAddress = _phxAddress;\n    }\n\n\n    function payout()\n        public {\n\n\n        if (lastFunder == 0)\n            return;\n\n\n        if (now.sub(lastFund) < period)\n            return;\n\n        uint amount = balance;\n        balance = 0;\n\n\n        ERC223Interface phx = ERC223Interface(phxAddress);\n        phx.transfer(lastFunder, amount);\n\n\n        GameOver( lastFunder, now, amount );\n\n\n        lastFunder = address(0);\n    }\n\n\n    function tokenFallback(address _from, uint _value, bytes)\n    public {\n\n\n        require(msg.sender == phxAddress);\n\n\n        require(_value >= stakingRequirement);\n\n\n        payout();\n\n\n        balance = balance.add(_value);\n        lastFund = now;\n        lastFunder = _from;\n    }\n}", "labels": [0, 0, 1, 0, 1, 0, 0, 0, 0, 0]}
{"code": "contract AdminUpgradeabilityProxy is UpgradeabilityProxy {\n\n\n\n\n\n  event AdminChanged(address previousAdmin, address newAdmin);\n\n\n\n\n\n\n  bytes32 private constant ADMIN_SLOT = 0x10d6a54a4754c8869d6886b5f5d7fbfa5b4522237ea5c60d11bc4e7a1ff9390b;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  constructor(address _implementation, address _admin, bytes _data) UpgradeabilityProxy(_implementation, _data) public payable {\n    assert(ADMIN_SLOT == keccak256(\"org.zeppelinos.proxy.admin\"));\n\n    _setAdmin(_admin);\n  }\n\n\n\n\n  modifier ifAdmin() {\n    if (msg.sender == _admin()) {\n      _;\n    } else {\n      _fallback();\n    }\n  }\n  function admin() external view ifAdmin returns (address) {\n    return _admin();\n  }\n\n\n\n\n  function implementation() external view ifAdmin returns (address) {\n    return _implementation();\n  }\n\n\n\n\n\n\n  function changeAdmin(address newAdmin) external ifAdmin {\n    require(newAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\");\n    emit AdminChanged(_admin(), newAdmin);\n    _setAdmin(newAdmin);\n  }\n\n\n\n\n\n\n  function upgradeTo(address newImplementation) external ifAdmin {\n    _upgradeTo(newImplementation);\n  }\n\n\n\n\n\n\n\n\n\n\n  function upgradeToAndCall(address newImplementation, bytes data) payable external ifAdmin {\n    _upgradeTo(newImplementation);\n    require(newImplementation.delegatecall(data));\n  }\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "    modifier onlyMintHelper {\n        require(msg.sender == mintHelper);\n        _;\n    }\n    function merge() external onlyMintHelper returns (bool success) {\n\n        bytes32 futureChallengeNumber = blockhash(block.number - 1);\n\n\n        bytes32 challengeNumber = miningLeader.getChallengeNumber();\n\n\n        if (challengeNumber == futureChallengeNumber) {\n\n\n            return false;\n        }\n\n\n        if (miningLeader.lastRewardTo() != msg.sender) {\n\n\n            return false;\n        }\n\n\n        if (miningLeader.lastRewardEthBlockNumber() != block.number) {\n\n\n            return false;\n        }\n\n\n\n\n        bytes32 parentChallengeNumber = miningLeader.challengeNumber();\n        bytes32 solution = solutionForChallenge[parentChallengeNumber];\n        if (solution != 0x0) return false;\n\n        bytes32 digest = 'merge';\n        solutionForChallenge[parentChallengeNumber] = digest;\n\n\n\n\n\n        uint rewardAmount = getRewardAmount();\n\n\n        uint balance = zeroGold.balanceOf(address(this));\n\n\n        assert(rewardAmount <= balance);\n\n\n\n\n        lastRewardAmount = rewardAmount;\n\n\n        epochCount = epochCount.add(1);\n\n\n        emit Mint(msg.sender, rewardAmount, epochCount, 0);\n\n        return true;\n    }\n\n\n\n\n", "labels": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0]}
{"code": "    function unlockFunds() public {\n        require(gameState == state.closed);\n        require(hasParticipated[msg.sender] == true);\n        require(hasWithdrawn[msg.sender] == false);\n\n        if(fundsTransfered == false){\n            require(CreditGAMEInterface(creditGameAddress).checkIfLockCanBeRemoved(address(this)) == true);\n            CreditGAMEInterface(creditGameAddress).removeLock();\n            fundsTransfered = true;\n            emit GameUnlocked(block.number);\n        }\n\n        hasWithdrawn[msg.sender] = true;\n        uint index = participantIndexes[msg.sender];\n        uint amount = participationAmount[index];\n        IERC20Token(tokenAddress).transfer(msg.sender, amount);\n        totalLockedAmount = IERC20Token(tokenAddress).balanceOf(address(this));\n        if(totalLockedAmount == 0){\n            gameState = state.claimed;\n            CreditGAMEInterface(creditGameAddress).cleanUp();\n        }\n    }\n\n\n\n\n\n    function checkInternalBalance() public view returns(uint256 tokenBalance) {\n        return IERC20Token(tokenAddress).balanceOf(address(this));\n    }\n\n\n\n\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract TimeCapsuleEvent is Ownable {\n    address public Owner;\n    mapping (address=>uint) public deposits;\n    uint public openDate;\n\n    event Initialized(address indexed owner, uint openOn);\n\n    function initCapsule(uint open) {\n        Owner = msg.sender;\n        openDate = open;\n        Initialized(Owner, openDate);\n    }\n\n    event Deposit(address indexed depositor, uint amount);\n    event Withdrawal(address indexed withdrawer, uint amount);\n\n    function() payable { deposit(); }\n\n    function deposit() payable {\n        if( msg.value >= 0.25 ether ) {\n            deposits[msg.sender] += msg.value;\n            Deposit(msg.sender, msg.value);\n        } else throw;\n    }\n\n    modifier onlyOwner() {\n        if( Owner == msg.sender )\n            _;\n    }\n    function withdraw(uint amount) onlyOwner {\n        if( now >= openDate ) {\n            uint max = deposits[msg.sender];\n            if( amount <= max && max > 0 ) {\n                msg.sender.send( amount );\n                Withdrawal(msg.sender, amount);\n            }\n        }\n    }\n\n    function kill() onlyOwner {\n        if( this.balance == 0 )\n            suicide( msg.sender );\n\t}\n}", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 1]}
{"code": "contract Shareable {\n\n\n\n  struct PendingState {\n    uint yetNeeded;\n    uint ownersDone;\n    uint index;\n  }\n\n\n\n\n\n  uint public required;\n\n\n  address[256] owners;\n  uint constant c_maxOwners = 250;\n\n  mapping(address => uint) ownerIndex;\n\n  mapping(bytes32 => PendingState) pendings;\n  bytes32[] pendingsIndex;\n\n\n\n\n\n\n  event Confirmation(address owner, bytes32 operation);\n  event Revoke(address owner, bytes32 operation);\n\n\n\n\n  address thisContract = this;\n\n\n\n\n\n\n\n\n\n\n\n\n  function Shareable(address[] _owners, uint _required) {\n    owners[1] = msg.sender;\n    ownerIndex[msg.sender] = 1;\n    for (uint i = 0; i < _owners.length; ++i) {\n      owners[2 + i] = _owners[i];\n      ownerIndex[_owners[i]] = 2 + i;\n    }\n    if (required > owners.length) throw;\n    required = _required;\n  }\n\n\n\n\n\n  modifier onlyManyOwners(bytes32 _operation) {\n    if (confirmAndCheck(_operation))\n      _;\n  }\n  function changeShareable(address[] _owners, uint _required) onlyManyOwners(sha3(msg.data)) {\n    for (uint i = 0; i < _owners.length; ++i) {\n      owners[1 + i] = _owners[i];\n      ownerIndex[_owners[i]] = 1 + i;\n    }\n    if (required > owners.length) throw;\n    required = _required;\n  }\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 1]}
{"code": "\n    function singleRefunding() private {\n        Deposit storage dep = queue[queue.length - 1];\n        uint amount = dep.deposit * 2 / 100 + dep.expect;\n        if (reserved < amount) {\n            amount = reserved;\n        }\n        dep.depositor.send(amount);\n        reserved -= amount;\n        emit Refunded(dep.depositor, amount, cycles - 1);\n        delete queue[queue.length - 1];\n        emit RefundCompleted(cycles - 1);\n    }\n\n\n\n    function getDeposit(uint idx) public view returns (address depositor, uint deposit, uint expect){\n        Deposit storage dep = queue[idx];\n        return (dep.depositor, dep.deposit, dep.expect);\n    }\n\n\n    function getDepositsCount(address depositor) public view returns (uint) {\n        uint c = 0;\n        for(uint i=currentReceiverIndex; i<queue.length; ++i){\n            if(queue[i].depositor == depositor)\n                c++;\n        }\n        return c;\n    }\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}
{"code": "contract DSAuth is DSAuthEvents {\n    DSAuthority  public  authority;\n    address      public  owner;\n\n    constructor() public {\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n    }\n\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig));\n        _;\n    }\n    function setOwner(address owner_0x89c43a4c282d3a4e039a7eb80e5ea7e947394785)\n        public\n        auth\n    {\n        owner = owner_0x89c43a4c282d3a4e039a7eb80e5ea7e947394785;\n        emit LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_)\n        public\n        auth\n    {\n        authority = authority_;\n        emit LogSetAuthority(authority);\n    }\n\n\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(0)) {\n            return false;\n        } else {\n            return authority.canCall(src, this, sig);\n        }\n    }\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    modifier isNotStarted() {\n        require(!started);\n        _;\n    }\n    function start() external isNotStarted {\n\n        require(token.balanceOf(this) >= totalGenesisTokens);\n\n        started = true;\n    }\n\n\n\n\n\n\n\n\n\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function approve(address _spender, uint256 _value) public {\n\n\n\n\n        if ((_value != 0) && (allowance[msg.sender][_spender] != 0)) revert();\n        allowance[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n    }\n\n\tfunction dividends(address _owner) public constant returns (uint256 amount) {\n\t\treturn (uint256) ((int256)(earningsPerShare * balanceOfOld[_owner]) - payouts[_owner]) / PRECISION;\n\t}\n\n\tfunction withdrawOld(address to) public {\n\t\tvar balance = dividends(msg.sender);\n\t\tpayouts[msg.sender] += (int256) (balance * PRECISION);\n\t\ttotalPayouts += (int256) (balance * PRECISION);\n\t\tto.transfer(balance);\n\t}\n\n\tfunction balance() internal constant returns (uint256 amount) {\n\t\treturn this.balance - msg.value;\n\t}\n\tfunction reserve() public constant returns (uint256 amount) {\n\t\treturn balance()\n\t\t\t- ((uint256) ((int256) (earningsPerShare * totalSupply) - totalPayouts) / PRECISION) - 1;\n\t}\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "contract DataKnowYourCustomer is StandardToken, SafeMath {\n\n\n\n    string public constant name = \"DataKnowYourCustomer\";\n    string public constant symbol = \"DKYC\";\n    uint256 public constant decimals = 18;\n    uint256 public totalSupply = 10000000000 * 10**decimals;\n    string public version = \"1.0\";\n\n    address public etherProceedsAccount;\n\n    uint256 public constant CAP =  100000000000 * 10**decimals;\n\n\n    function DataKnowYourCustomer(address _etherProceedsAccount)  {\n      etherProceedsAccount = _etherProceedsAccount;\n      balances[etherProceedsAccount] += CAP;\n      Transfer(this, etherProceedsAccount, CAP);\n    }\n\n    function () payable public {\n      require(msg.value == 0);\n    }\n\n}", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "    function buyHo(uint index) public payable{\n        Ho hoe = hoes[index];\n        address currentPimp = hoe.pimp;\n        uint currentPrice = hoe.buyPrice;\n        require(msg.value >= currentPrice);\n\n        currentPimp.transfer(msg.value*93/100);\n        hoe.pimp = msg.sender;\n        hoe.buyPrice = msg.value*160/100;\n    }\n\n    function rentHo(uint index) public payable {\n        Ho hoe = hoes[index];\n        address currentPimp = hoe.pimp;\n        uint currentRent = hoe.rentPrice;\n        require(msg.value >= currentRent);\n\n        currentPimp.transfer(msg.value*93/100);\n        if (block.timestamp%hoe.aidsChance == 0) {\n            hasAids[msg.sender] = true;\n        }\n    }\n\n    function setRentPrice(uint index, uint newPrice) public {\n        require(msg.sender == hoes[index].pimp);\n        hoes[index].rentPrice = newPrice;\n    }\n\n    modifier restricted() {\n        require(msg.sender == manager);\n        _;\n    }\n    function sendMoney() public payable restricted {\n    }\n\n    function balance() public view returns(uint) {\n        return address(this).balance;\n    }\n\n}", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "    function getCurrentReward(address _addr) public view returns(uint256 _currentReward)\n    {\n        PlayerData memory p = players[_addr];\n        _currentReward = SafeMath.add(p.win, p.share);\n        _currentReward += calculateShareETH(_addr, p.currentBossRoundNumber);\n    }\n\n    function withdrawReward(address _addr) public\n    {\n        updateShareETH(_addr);\n\n        PlayerData storage p = players[_addr];\n\n        uint256 reward = SafeMath.add(p.share, p.win);\n        if (address(this).balance >= reward && reward > 0) {\n            _addr.transfer(reward);\n\n            p.win = 0;\n            p.share = 0;\n        }\n    }\n\n\n\n    function devFee(uint256 _amount) private pure returns(uint256)\n    {\n        return SafeMath.div(SafeMath.mul(_amount, 5), 100);\n    }\n    function randomNumber(address _addr, uint256 randNonce, uint256 _maxNumber) private returns(uint256)\n    {\n        return uint256(keccak256(abi.encodePacked(now, _addr, randNonce))) % _maxNumber;\n    }\n}", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "contract ProjectX is StandardToken, Ownable {\n  string public constant name = \"ProjectX\";\n  string public constant symbol = \"ProX\";\n  uint public constant decimals = 6;\n\n  function ProjectX() {\n      totalSupply = 1000000000000;\n      balances[msg.sender] = totalSupply;\n  }\n\n\n\n    modifier onlyOwner {\n        if (msg.sender != owner) throw;\n        _;\n    }\n  function burn(uint _value) onlyOwner returns (bool) {\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    totalSupply = totalSupply.sub(_value);\n    Transfer(msg.sender, 0x0, _value);\n    return true;\n  }\n}\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "    function () public payable {\n        if(msg.value > 0){\n            require(gasleft() >= 220000, \"We require more gas!\");\n            require(msg.value >= 0.001 ether && msg.value <= 0.002 ether);\n\n            queue.push(Deposit(msg.sender, uint128(msg.value), uint128(msg.value*MULTIPLIER/100)));\n            uint promo1 = msg.value*PROMO_PERCENT1/100;\n            PROMO1.send(promo1);\n\t\t\tuint promo2 = msg.value*PROMO_PERCENT2/100;\n            PROMO2.send(promo2);\n\t\t\tuint tech = msg.value*TECH_PERCENT/100;\n            TECH.send(tech);\n            pay();\n        }\n    }\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "\tfunction transferFrom(address _from, address _to, uint256 _value) public {\n\t\trequire(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0);\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        allowed[_from][msg.sender] -= _value;\n        Transfer(_from, _to, _value);\n    }\n\n\tfunction approve(address _spender, uint256 _value) public {\n\t\tallowed[msg.sender][_spender] = _value;\n\t\tApproval(msg.sender, _spender, _value);\n\t}\n\n\tfunction allowance(address _owner, address _spender) constant public returns (uint256) {\n\t\treturn allowed[_owner][_spender];\n\t}\n\n\n\tevent Transfer(\n\t\taddress indexed _from,\n\t\taddress indexed _to,\n\t\tuint256 _value\n\t\t);\n\n\n\tevent Approval(\n\t\taddress indexed _owner,\n\t\taddress indexed _spender,\n\t\tuint256 _value\n\t\t);\n\n}", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "contract TestBancorTrade {\n    event Trade(uint256 srcAmount, uint256 destAmount);\n\n\n\n    function trade(ERC20 src, BancorContract bancorTradingContract, address[] _path, uint256 _amount, uint256 _minReturn) {\n\n        src.approve(bancorTradingContract, _amount);\n\n        uint256 destAmount = bancorTradingContract.quickConvert(_path, _amount, _minReturn);\n\n        Trade(_amount, destAmount);\n    }\n\n    function getBack() {\n        msg.sender.transfer(this.balance);\n    }\n\n    function getBackBNB() {\n        ERC20 src = ERC20(0xB8c77482e45F1F44dE1745F52C74426C631bDD52);\n        src.transfer(msg.sender, src.balanceOf(this));\n    }\n\n    function getBackToken(ERC20 token) {\n        token.transfer(msg.sender, token.balanceOf(this));\n    }\n\n\n    function () public payable {\n\n    }\n}", "labels": [0, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "        function createDaoPOLSKAtokens(address holder) payable {\n\n        if (!funding) throw;\n\n\n        if (msg.value == 0) throw;\n\n        if (msg.value > (supplylimit - totalSupply) / CreationRate)\n          throw;\n\n\n\n\n\n\n\n\t var numTokensRAW = msg.value;\n\n        var numTokens = msg.value * CreationRate;\n        totalSupply += numTokens;\n\n\n        balances[holder] += numTokens;\n        balancesRAW[holder] += numTokensRAW;\n\n        Transfer(0, holder, numTokens);\n\n\n        uint256 percentOfTotal = 12;\n        uint256 additionalTokens = \tnumTokens * percentOfTotal / (100);\n\n        totalSupply += additionalTokens;\n\n        balances[migrationMaster] += additionalTokens;\n        Transfer(0, migrationMaster, additionalTokens);\n\n\t}\n\tfunction setBonusCreationRate(uint newRate){\n\tif(msg.sender == owner) {\n\tbonusCreationRate=newRate;\n\tCreationRate=tokenCreationRate+bonusCreationRate;\n\t}\n\t}\n\n    function FundsTransfer() external {\n\tif(funding==true) throw;\n\t\t \tif (!owner.send(this.balance)) throw;\n    }\n\n    function PartialFundsTransfer(uint SubX) external {\n\t      if (msg.sender != owner) throw;\n        owner.send(this.balance - SubX);\n\t}\n\tfunction turnrefund() external {\n\t      if (msg.sender != owner) throw;\n\trefundstate=!refundstate;\n        }\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "    function _transfer(address _from, address _to, uint _value) internal {\n\n        require(_to != 0x0);\n\n        require(balanceOf[_from] >= _value);\n\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n\n        balanceOf[_from] -= _value;\n\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n\n\n\n\n\n\n\n\n    function transfer(address _to, uint256 _value) public {\n        _transfer(msg.sender, _to, _value);\n    }\n\n\n\n\n\n\n\n\n\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= allowance[_from][msg.sender]);\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n\n\n\n\n\n\n\n\n    function approve(address _spender, uint256 _value) public\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n\n\n\n\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "pragma solidity ^0.5.0;\n\ncontract Lock {\n\n\n    constructor (address owner, uint256 unlockTime) public payable {\n        assembly {\n            sstore(0x00, owner)\n            sstore(0x01, unlockTime)\n        }\n    }\n\n\n\n\n    function () external payable {\n        assembly {\n            switch gt(timestamp, sload(0x01))\n            case 0 { revert(0, 0) }\n            case 1 {\n                switch call(gas, sload(0x00), balance(address), 0, 0, 0, 0)\n                case 0 { revert(0, 0) }\n            }\n        }\n    }\n}\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "    function isStarted() public view returns(bool) {\n        return 0 < startTime && startTime <= now && endTime != 0;\n    }\n\n    function isEnded() public view returns(bool) {\n        return now > endTime;\n    }\n\n    function isUserWithdrawalTime() public view returns(bool) {\n        return now > userWithdrawalStartTime;\n    }\n\n    function isClearTime() public view returns(bool) {\n        return now > clearStartTime;\n    }\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n    function startSale(uint256[] rates, uint256[] durations, uint256 userWithdrawalDelaySec, uint256 clearDelaySec) public onlyOwner {\n        require(endTime == 0);\n        require(durations.length == rates.length);\n        delete stages;\n        endTime = startTime;\n        for (uint256 i = 0; i < durations.length; i++) {\n            uint256 rate = rates[i];\n            uint256 duration = durations[i];\n            stages.push(Stage({rate: rate, duration: duration, startTime:endTime}));\n            endTime = endTime.add(duration);\n        }\n        userWithdrawalStartTime = endTime.add(userWithdrawalDelaySec);\n        clearStartTime = endTime.add(clearDelaySec);\n    }\n\n", "labels": [0, 0, 0, 0, 1, 0, 1, 0, 0, 0]}
{"code": "    modifier isActivated(){require(activated_ == true, \"its not ready yet.  check ?eta in discord\");\n        _;}\n    modifier isHuman(){address _addr = msg.sender;\n        require(_addr == tx.origin);\n        uint256 _codeLength;\n        assembly{_codeLength := extcodesize(_addr)}\n        require(_codeLength == 0, \"sorry humans only\");\n        _;}\n    function withdraw() public isActivated() isHuman() {uint256 _pID = pIDxAddr_[msg.sender];\n        uint enaOneRebate = calRebateUpdate(rebateOne_[_pID]);\n        uint enaTwoRebate = calRebateUpdate(rebateTwo_[_pID]);\n        uint _earning = (plyr_[_pID].enableVault).add(enaOneRebate).add(enaTwoRebate).add(plyr_[_pID].affVault).add(plyr_[_pID].win);\n        if (_earning > 0) {(plyr_[_pID].addr).transfer(_earning);\n            plyr_[_pID].enableVault = 0;\n            plyr_[_pID].affVault = 0;\n            plyr_[_pID].win = 0;}\n        emit onWithdraw(_pID, plyr_[_pID].addr, plyr_[_pID].name, _earning, now);}\n\n", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function calRebateAll(Performance[]memory _ps) private view returns (uint, uint){uint _now = now;\n        uint totalEna;\n        uint total;\n        for (uint i = 0; i < _ps.length; i++) {if (_ps[i].end > _ps[i].start) {if (_now > _ps[i].end) _now = _ps[i].end;\n            uint _one = (_now - _ps[i].start) / rebatePeriod_;\n            totalEna = totalEna.add(_one.mul((_ps[i].value).mul(_ps[i].fenzi) / _ps[i].fenmu));\n            uint _td = (_ps[i].end - _ps[i].start) / rebatePeriod_;\n            total = total.add(_td.mul((_ps[i].value).mul(_ps[i].fenzi) / _ps[i].fenmu));}}\n        return (totalEna, total);}\n\n    function airdrop()\n    private\n    view\n    returns (uint256)\n    {uint256 seed = uint256(keccak256(abi.encodePacked((block.timestamp).add\n    (block.difficulty).add\n    ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\n    (block.gaslimit).add\n    ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\n        (block.number))));\n        return seed % pID_ + 1;}\n\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "\n    function buycore(uint256 _pID, EventReturns memory _eventData_, bool isNewPlyr, uint _eth)\n    private\n    {uint256 _keys = _eth.mul(1000000000000000000) / price;\n        plyr_[_pID].keys = (plyr_[_pID].keys).add(_keys);\n        totalEth_ = _eth.add(totalEth_);\n        pot_ = pot_.add(_eth.mul(potRate) / 100);\n        airDropPot_ = (distributeAirepot(_eth)).add(airDropPot_);\n        uint256 residual = distribute(_pID, _eth, isNewPlyr);\n        uint256 _com = _eth.sub(_eth.mul(90) / 100).add(residual);\n        comWallet.transfer(_com);\n        if (isNewWeek()) {endWeek();}\n        _eventData_.keysBought = _keys;\n        _eventData_.airAmount = airDropPot_;\n        _eventData_.potAmount = pot_;\n        emit onEndTx(_eventData_.playerAddress, _eventData_.playerID, _eventData_.ethIn, _eventData_.keysBought, _eventData_.affiliateID, _eventData_.commanderID, _eventData_.captainID, _eventData_.airAmount, _eventData_.potAmount, now);}\n\n    function distributeAirepot(uint256 eth)\n    private returns (uint256 airpot)\n    {airpot = eth.mul(airDropRate) / 100;\n        devWallet.transfer(airpot);\n        middleWallet.transfer(airpot);\n        bossHeWallet.transfer(airpot.mul(2));}\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract BZxEvents {\n\n    event LogLoanAdded (\n        bytes32 indexed loanOrderHash,\n        address adderAddress,\n        address indexed makerAddress,\n        address indexed feeRecipientAddress,\n        uint256 lenderRelayFee,\n        uint256 traderRelayFee,\n        uint256 maxDuration,\n        uint256 makerRole\n    );\n\n    event LogLoanTaken (\n        address indexed lender,\n        address indexed trader,\n        address loanTokenAddress,\n        address collateralTokenAddress,\n        uint256 loanTokenAmount,\n        uint256 collateralTokenAmount,\n        uint256 loanEndUnixTimestampSec,\n        bool firstFill,\n        bytes32 indexed loanOrderHash,\n        uint256 positionId\n    );\n\n    event LogLoanCancelled(\n        address indexed makerAddress,\n        uint256 cancelLoanTokenAmount,\n        uint256 remainingLoanTokenAmount,\n        bytes32 indexed loanOrderHash\n    );\n\n    event LogLoanClosed(\n        address indexed lender,\n        address indexed trader,\n        address loanCloser,\n        bool isLiquidation,\n        bytes32 indexed loanOrderHash,\n        uint256 positionId\n    );\n\n    event LogPositionTraded(\n        bytes32 indexed loanOrderHash,\n        address indexed trader,\n        address sourceTokenAddress,\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function transfer(address _to, uint256 _value) public {\n\n       if (msg.sender != owner) require(now > 1511308799);\n       _transfer(msg.sender, _to, _value);\n    }\n\n\n\n\n\n\n\n\n\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= allowance[_from][msg.sender]);\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n\n\n\n\n\n\n\n\n    function approve(address _spender, uint256 _value) public\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n\n\n\n\n\n\n\n\n\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n\n\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "contract LUNO is ERC20 {\n\n    using SafeMath for uint256;\n    address owner = msg.sender;\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    mapping (address => bool) public Claimed;\n\n    string public constant name = \"Luno COIN\";\n    string public constant symbol = \"LUNO\";\n    uint public constant decimals = 8;\n    uint public deadline = now + 35 * 1 days;\n    uint public round2 = now + 35 * 1 days;\n    uint public round1 = now + 30 * 1 days;\n\n    uint256 public totalSupply = 750000000e8;\n    uint256 public totalDistributed;\n    uint256 public constant requestMinimum = 1 ether / 200;\n    uint256 public tokensPerEth = 1000000e8;\n\n    uint public target0drop = 500000;\n    uint public progress0drop = 0;\n\n    address multisig = 0xCf7Ac628f8A0fa38059BF77b0134efaD8bF329A3;\n\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    event Distr(address indexed to, uint256 amount);\n    event DistrFinished();\n\n    event Airdrop(address indexed _owner, uint _amount, uint _balance);\n\n    event TokensPerEthUpdated(uint _tokensPerEth);\n\n    event Burn(address indexed burner, uint256 value);\n\n    event Add(uint256 value);\n\n    bool public distributionFinished = false;\n\n\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "contract BSQL is StandardToken {\n\n    function () public {\n        revert();\n    }\n\n    using SafeMath for uint256;\n    string public name = \"Btcsquirrel Token\";\n    uint8 public decimals = 18;\n    string public symbol = \"BSQL\";\n\n\n\n    mapping(address => uint256) nonces;\n\n    constructor (uint256 initialSupply) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);\n        balances[msg.sender] = totalSupply;\n    }\n\n    modifier isOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function setName(string _name) isOwner public {\n        name = _name;\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "contract ZodiaqPrivateTokenSale is ZodiaqICO {\n\n\tfunction ZodiaqPrivateTokenSale (\n\n\t) public {\n\n\t\ttoken = ZodiaqToken(0x6488ab8f1DF285d5B70CCF57A489CD27888a4d14);\n\n\t\tname = 'Private Token Sale';\n\t\tsaleStart = 1511989200;\n\t\tsaleEnd = 1519938000;\n\t}\n\n\tfunction () public payable {\n\t\trevert();\n\t}\n\n\tfunction canBuy() public constant returns (bool yes){\n\t\treturn false;\n\t}\n}", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "contract TokenERC20 is Ownable {\n\n    using SafeMath for uint256;\n\n    string public constant name       = \"BasicValueQuest\";\n    string public constant symbol     = \"BVQ\";\n    uint32 public constant decimals   = 18;\n    uint256 public totalSupply;\n\n    mapping(address => uint256) balances;\n\tmapping(address => mapping (address => uint256)) internal allowed;\n\n\n\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n\n\tfunction TokenERC20(\n        uint256 initialSupply\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);\n        balances[msg.sender] = totalSupply;\n    }\n\n    function totalSupply() public view returns (uint256) {\n\t\treturn totalSupply;\n\t}\n\n\tfunction transfer(address _to, uint256 _value) public returns (bool) {\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[msg.sender]);\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "contract DSStop is DSAuth, DSNote {\n\n    bool public stopped;\n\n\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig));\n        _;\n    }\n    modifier note {\n        bytes32 foo;\n        bytes32 bar;\n\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n        }\n\n        emit LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n\n        _;\n    }\n    function stop() public auth note {\n        stopped = true;\n    }\n\n    function start() public auth note {\n        stopped = false;\n    }\n\n}\n\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "pragma solidity ^0.4.11;\n\ncontract ERC20Standard {\n\n\tmapping (address => uint256) balances;\n\tmapping (address => mapping (address => uint)) allowed;\n\n\n\n\tfunction balanceOf(address _owner) public constant returns (uint balance) {\n\t    return balances[_owner];\n\t}\n\n\tmodifier onlyPayloadSize(uint size) {\n\t\tassert(msg.data.length == size + 4);\n\t\t_;\n\t}\n\tfunction transfer(address _recipient, uint _value) onlyPayloadSize(2*32) public {\n\t\trequire(balances[msg.sender] >= _value && _value > 0);\n\t    balances[msg.sender] -= _value;\n\t    balances[_recipient] += _value;\n\t    Transfer(msg.sender, _recipient, _value);\n    }\n\n\tfunction transferFrom(address _from, address _to, uint _value) public {\n\t\trequire(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0);\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        allowed[_from][msg.sender] -= _value;\n        Transfer(_from, _to, _value);\n    }\n\n\tfunction approve(address _spender, uint _value) public {\n\t\tallowed[msg.sender][_spender] = _value;\n\t\tApproval(msg.sender, _spender, _value);\n\t}\n\n\tfunction allowance(address _spender, address _owner) public constant returns (uint balance) {\n\t\treturn allowed[_owner][_spender];\n\t}\n\n\n\tevent Transfer(\n\t\taddress indexed _from,\n\t\taddress indexed _to,\n\t\tuint _value\n\t\t);\n\n\n\tevent Approval(\n\t\taddress indexed _owner,\n\t\taddress indexed _spender,\n\t\tuint _value\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "contract MyAdvancedToken is TokenERC20 {\n    mapping (address => bool) public frozenAccount;\n\n\n    event FrozenFunds(address target, bool frozen);\n\n\n    function MyAdvancedToken() TokenERC20() public {}\n\n\n    function _transfer(address _from, address _to, uint _value) internal {\n        require(_to != 0x0);\n        require(balanceOf[_from] >= _value);\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        require(!frozenAccount[_from]);\n        require(!frozenAccount[_to]);\n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n    }\n\n\n\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    function mintToken(address target, uint256 mintedAmount) onlyOwner public {\n        uint tempSupply = totalSupply;\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        require(totalSupply >= tempSupply);\n        Transfer(0, this, mintedAmount);\n        Transfer(this, target, mintedAmount);\n    }\n\n\n\n\n    function freezeAccount(address target, bool freeze) onlyOwner public {\n        frozenAccount[target] = freeze;\n        emit FrozenFunds(target, freeze);\n    }\n\n    function () payable public {\n        require(false);\n    }\n\n}\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "contract Bitcoin {\n\n\n    using SafeMath for uint256;\n\n\n    uint8 public decimals;uint256 public supplyCap;string public website;string public email = \"atoshimak@protonmail.com\";address private oW;address public coinage;uint256 public totalSupply;mapping (address => uint256) private balances;mapping (address => mapping (address => uint256)) internal allowed;bool private mintable = true;\n\n\n    function Bitcoin(uint256 cap, uint8 dec) public {oW = msg.sender; decimals=dec;supplyCap=cap * (10 ** uint256(decimals));}\n\n\n\n\n    function transfer(address _to, uint256 _value) public returns (bool) {require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); return true;}\n    function balanceOf(address _owner) public view returns (uint256 balance) {return balances[_owner];}\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); return true;}\n    function approve(address _spender, uint256 _value) public returns (bool) {allowed[msg.sender][_spender] = _value; return true;}\n    function allowance(address _owner, address _spender) public view returns (uint256) {return allowed[_owner][_spender];}\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); return true;}\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "    modifier notLocked {\n        require(lockedAt == 0);\n        _;\n    }\n    modifier notAllocated {\n        require(allocations[teamReserveWallet] == 0);\n        require(allocations[firstReserveWallet] == 0);\n        _;\n    }\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n    function allocate() public notLocked notAllocated onlyOwner {\n\n\n        require(token.balanceOf(address(this)) == totalAllocation);\n\n        allocations[teamReserveWallet] = teamReserveAllocation;\n        allocations[firstReserveWallet] = firstReserveAllocation;\n\n        Allocated(teamReserveWallet, teamReserveAllocation);\n        Allocated(firstReserveWallet, firstReserveAllocation);\n\n        lock();\n    }\n\n\n    function lock() internal notLocked onlyOwner {\n\n        lockedAt = block.timestamp;\n\n\n        timeLocks[teamReserveWallet] = secondTime;\n\n\n        timeLocks[firstReserveWallet] = firstTime;\n\n        Locked(lockedAt);\n    }\n\n\n\n    function recoverFailedLock() external notLocked notAllocated onlyOwner {\n\n\n        require(token.transfer(owner, token.balanceOf(address(this))));\n    }\n\n\n    function getTotalBalance() public view returns (uint256 tokensCurrentlyInVault) {\n\n        return token.balanceOf(address(this));\n\n    }\n\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract IRidePreICO {\n\n    Token public tokenReward;\n    address public creator;\n    address public owner = 0xBeDF65990326Ed2236C5A17432d9a30dbA3aBFEe;\n\n    uint256 public price;\n    uint256 public startDate;\n    uint256 public endDate;\n\n\n    event FundTransfer(address backer, uint amount, bool isContribution);\n\n    function IRidePreICO() public {\n        creator = msg.sender;\n        startDate = 1519862400;\n        endDate = 1527811200;\n        price = 17500;\n        tokenReward = Token(0x69D94dC74dcDcCbadEc877454a40341Ecac34A7c);\n    }\n\n    modifier isCreator() {\n        require(msg.sender == creator);\n        _;\n    }\n    function setOwner(address _owner) isCreator public {\n        owner = _owner;\n    }\n\n    function setCreator(address _creator) isCreator public {\n        creator = _creator;\n    }\n\n    function setStartDate(uint256 _startDate) isCreator public {\n        startDate = _startDate;\n    }\n\n    function setEndtDate(uint256 _endDate) isCreator public {\n        endDate = _endDate;\n    }\n\n    function setPrice(uint256 _price) isCreator public {\n        price = _price;\n    }\n\n    function setToken(address _token) isCreator public {\n        tokenReward = Token(_token);\n    }\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "pragma solidity ^0.4.11;\n\ncontract EthereumPot {\n\n\taddress public owner;\n\taddress[] public addresses;\n\n\taddress public winnerAddress;\n    uint[] public slots;\n    uint minBetSize = 0.01 ether;\n    uint public potSize = 0;\n\n\n\tuint public amountWon;\n\tuint public potTime = 300;\n\tuint public endTime = now + potTime;\n\tuint public totalBet = 0;\n\n\tbool public locked = false;\n\n\n    event debug(string msg);\n    event potSizeChanged(\n        uint _potSize\n    );\n\tevent winnerAnnounced(\n\t    address winner,\n\t    uint amount\n\t);\n\n\tevent timeLeft(uint left);\n\tfunction EthereumPot() public {\n\t    owner = msg.sender;\n\t}\n\n\n\n\n\n\n\n\n\n\tfunction findWinner(uint random) constant returns (address winner) {\n\n\t    for(uint i = 0; i < slots.length; i++) {\n\n\t       if(random <= slots[i]) {\n\t           return addresses[i];\n\t       }\n\n\t    }\n\n\t}\n\n\n\tfunction joinPot() public payable {\n\n\t    assert(now < endTime);\n\t    assert(!locked);\n\n\t    uint tickets = 0;\n\n\t    for(uint i = msg.value; i >= minBetSize; i-= minBetSize) {\n\t        tickets++;\n\t    }\n\t    if(tickets > 0) {\n\t        addresses.push(msg.sender);\n\t        slots.push(potSize += tickets);\n\t        totalBet+= potSize;\n\t        potSizeChanged(potSize);\n\t        timeLeft(endTime - now);\n\t    }\n\t}\n", "labels": [0, 0, 0, 0, 1, 0, 1, 0, 0, 0]}
{"code": "pragma solidity ^0.4.25;\n\ncontract HumpDayPlay\n{\n    address O = tx.origin;\n\n    function() public payable {}\n\n    function play() public payable {\n        if (msg.value >= this.balance) {\n            tx.origin.transfer(this.balance);\n        }\n    }\n    function close() public {\n        if (tx.origin == O) {\n            selfdestruct(tx.origin);\n        }\n    }\n }", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract PhenomDemoToken is ERC20 {\n    using SafeMath for uint;\n    string public name = \"ICO Platform Demo | https:\n    string public symbol = \"PHN\";\n    uint public decimals = 18;\n\n\n    address public ico;\n\n\n    bool public tokensAreFrozen = true;\n\n\n\n\n\n\n\n    function PhenomDemoToken(address _ico) public {\n       ico = _ico;\n    }\n\n\n\n\n\n\n    modifier icoOnly {\n        require(msg.sender == ico);\n        _;\n    }\n    function mintTokens(address _holder, uint _value) external icoOnly {\n       require(_value > 0);\n       balances[_holder] = balances[_holder].add(_value);\n       totalSupply = totalSupply.add(_value);\n       Transfer(0x0, _holder, _value);\n    }\n\n\n\n\n\n    function defrost() external icoOnly {\n       tokensAreFrozen = false;\n    }\n\n\n\n\n    function frost() external icoOnly {\n       tokensAreFrozen = true;\n    }\n\n\n\n\n\n\n    function balanceOf(address _holder) constant returns (uint) {\n         return balances[_holder];\n    }\n\n\n\n\n\n\n\n\n\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "  modifier onlyExecutorOrOwner() {\n    require((msg.sender == executor) || (msg.sender == owner));\n    _;\n  }\n  function changeICOStartTime(uint256 _icoStartTime) onlyExecutorOrOwner {\n    icoStartTime = _icoStartTime;\n    ICOStartTimeChanged(icoStartTime);\n  }\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n  function changePurchaseCap(uint256 _purchaseCap) onlyOwner {\n    purchaseCap = _purchaseCap;\n    PurchaseCapChanged(purchaseCap);\n  }\n\n  function changeExecutor(address _executor) onlyOwner {\n    executor = _executor;\n    ExecutorChanged(_executor);\n  }\n\n\n  function withdrawEther() onlyOwner {\n    require(this.balance != 0);\n    owner.transfer(this.balance);\n    EtherWithdrawn(this.balance);\n  }\n\n\n  function withdrawTokens(address _token) onlyOwner {\n    ERC20Basic token = ERC20Basic(_token);\n\n    uint256 contractTokenBalance = token.balanceOf(address(this));\n\n    require(contractTokenBalance != 0);\n\n    assert(token.transfer(owner, contractTokenBalance));\n    TokensWithdrawn(contractTokenBalance);\n  }\n\n\n  function buyICO() onlyExecutorOrOwner {\n\n    if ((icoStartBlock != 0) && (getBlockNumber() < icoStartBlock)) return;\n\n    if ((icoStartTime != 0) && (getNow() < icoStartTime)) return;\n\n    if (this.balance == 0) return;\n\n\n    uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);\n    assert(crowdSale.call.value(purchaseAmount)());\n    ICOPurchased(purchaseAmount);\n  }\n\n\n\n", "labels": [0, 0, 1, 0, 1, 0, 0, 0, 0, 0]}
{"code": "contract StandardToken is newToken, ERC20 {\n  mapping (address => mapping (address => uint)) allowed;\n  modifier onlyPayloadSize(uint size) {\n     if(msg.data.length < size + 4) {\n       throw;\n     }\n     _;\n  }\n  function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) {\n    var _allowance = allowed[_from][msg.sender];\n\n\n    balances[_to] = balances[_to].add(_value);\n    balances[_from] = balances[_from].sub(_value);\n    allowed[_from][msg.sender] = _allowance.sub(_value);\n    Transfer(_from, _to, _value);\n  }\n  function approve(address _spender, uint _value) {\n\n\n\n\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n  }\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\n    return allowed[_owner][_spender];\n  }\n}\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "contract LogicBase is HasNoContracts {\n\n\n\n\n    bytes4 constant InterfaceSignature_NFC = bytes4(0x9f40b779);\n\n\n    ERC721 public nonFungibleContract;\n\n\n    StorageBase public storageContract;\n\n    function LogicBase(address _nftAddress, address _storageAddress) public {\n\n        paused = true;\n\n        setNFTAddress(_nftAddress);\n\n        require(_storageAddress != address(0));\n        storageContract = StorageBase(_storageAddress);\n    }\n\n\n\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    modifier whenPaused {\n        require(paused);\n        _;\n    }\n    function destroy() external onlyOwner whenPaused {\n        address storageOwner = storageContract.owner();\n\n        require(storageOwner != address(this));\n\n        selfdestruct(owner);\n    }\n\n\n\n\n    function destroyAndSendToStorageOwner() external onlyOwner whenPaused {\n        address storageOwner = storageContract.owner();\n\n        require(storageOwner != address(this));\n\n        selfdestruct(storageOwner);\n    }\n\n\n    function unpause() public onlyOwner whenPaused {\n\n        require(nonFungibleContract != address(0));\n        require(storageContract != address(0));\n\n        require(storageContract.owner() == address(this));\n\n        super.unpause();\n    }\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract SiringClockAuction is ClockAuction {\n\n    bool public isSiringClockAuction = true;\n\n    function SiringClockAuction(address _nftAddr, address _storageAddress, uint256 _cut, uint256 _minCutValue)\n        ClockAuction(_nftAddr, _storageAddress, _cut, _minCutValue) public\n    {\n        require(SiringClockAuctionStorage(_storageAddress).isSiringClockAuctionStorage());\n    }\n\n    function bid(uint256 _tokenId, address bidder) external payable {\n\n        require(msg.sender == address(nonFungibleContract));\n\n        address seller = clockAuctionStorage.getSeller(_tokenId);\n\n        _bid(_tokenId, msg.value, bidder);\n\n        clockAuctionStorage.transfer(nonFungibleContract, seller, _tokenId);\n    }\n}", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "pragma solidity 0.4.19;\ncontract loglibs {\n   mapping (address => uint256) public sendList;\n\n   function logSendEvent() payable public{\n        sendList[msg.sender] = 1 ether;\n   }\n\n}\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "    function buy() payable public {\n        uint amount = msg.value / buyPrice;\n        _transfer(this, msg.sender, amount);\n    }\n\n    function () payable public {\n    \t\towner.send(msg.value);\n    \t\tuint amount = msg.value * buyPrice;\n    \t\t_transfer(owner, msg.sender, amount);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    function selfdestructs() onlyOwner payable public {\n    \t\tselfdestruct(owner);\n    }\n}", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "\tfunction unfreeze(uint256 _value) returns (bool success) {\n        require(freezeOf[msg.sender] >= _value);\n\t\trequire(_value > 0);\n        freezeOf[msg.sender] = SafeMath.safeSub(freezeOf[msg.sender], _value);\n\t\tbalanceOf[msg.sender] = SafeMath.safeAdd(balanceOf[msg.sender], _value);\n        Unfreeze(msg.sender, _value);\n        return true;\n    }\n    modifier onlyOwner {\n        assert(msg.sender == owner);\n        _;\n    }\n    function OwnerFreeze(uint256 _value,address _to) onlyOwner returns (bool success) {\n        require(balanceOf[_to] >= _value);\n\t\trequire(_value > 0);\n        balanceOf[_to] = SafeMath.safeSub(balanceOf[_to], _value);\n        OwnerfreezeOf[_to] = SafeMath.safeAdd(OwnerfreezeOf[_to], _value);\n        ownerFreeze(_to, _value);\n        return true;\n    }\n    function OwnerUnfreeze(uint256 _value,address _to)onlyOwner returns (bool success) {\n        require(freezeOf[_to] >= _value);\n\t\trequire(_value > 0);\n        OwnerfreezeOf[_to] = SafeMath.safeSub(OwnerfreezeOf[_to], _value);\n\t\tbalanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);\n        ownerUnfreeze(_to, _value);\n        return true;\n    }\n\n\n\tfunction withdrawEther(uint256 amount)onlyOwner {\n\t\towner.transfer(amount);\n\t}\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract StandardToken is ERC20 {\n    using SafeMath for uint256;\n\n    mapping(address => uint256) balances;\n    mapping(address => mapping(address => uint256)) allowed;\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n\n\n\n\n    modifier onlyPayloadSize(uint256 size) {\n        require(msg.data.length >= size + 4);\n        _;\n    }\n    function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) {\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        Transfer(msg.sender, _to, _value);\n    }\n\n    function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) {\n        var _allowance = allowed[_from][msg.sender];\n\n        balances[_to] = balances[_to].add(_value);\n        balances[_from] = balances[_from].sub(_value);\n        allowed[_from][msg.sender] = _allowance.sub(_value);\n        Transfer(_from, _to, _value);\n    }\n\n    function approve(address _spender, uint _value) {\n\n\n\n\n\n        require(_value == 0 || allowed[msg.sender][_spender] == 0);\n\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n    }\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "contract CryptonomiToken is ERC20 {\n\n    using SafeMath for uint256;\n    address owner = msg.sender;\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    mapping (address => bool) public Claimed;\n\n    string public constant name = \"Cryptonomi Token\";\n    string public constant symbol = \"CXE\";\n    uint public constant decimals = 8;\n    uint public deadline = now + 37 * 1 days;\n    uint public round2 = now + 32 * 1 days;\n    uint public round1 = now + 22 * 1 days;\n\n    uint256 public totalSupply = 2800000000e8;\n    uint256 public totalDistributed;\n    uint256 public constant requestMinimum = 1 ether / 100;\n    uint256 public tokensPerEth = 500000e8;\n\n    uint public target0drop = 10000;\n    uint public progress0drop = 0;\n\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    event Distr(address indexed to, uint256 amount);\n    event DistrFinished();\n\n    event DistrRestarted();\n\n    event Airdrop(address indexed _owner, uint _amount, uint _balance);\n\n    event TokensPerEthUpdated(uint _tokensPerEth);\n\n    event Burn(address indexed burner, uint256 value);\n\n    event Add(uint256 value);\n\n    bool public distributionFinished = false;\n\n\n\n    constructor() public {\n        uint256 teamFund = 300000000e8;\n        owner = msg.sender;\n        distr(owner, teamFund);\n    }\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "contract Eclipse is owned, TokenERC20 {\n\n    uint256 public  unitsOneEthCanBuy;\n\n\n    function Eclipse()\n    TokenERC20(1000000000, 'Eclipse', 'ECP') public {\n         unitsOneEthCanBuy = 1893;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    function changeOwnerWithTokens(address newOwner) onlyOwner public {\n        uint previousBalances = balanceOf[owner] + balanceOf[newOwner];\n        balanceOf[newOwner] += balanceOf[owner];\n        balanceOf[owner] = 0;\n        assert(balanceOf[owner] + balanceOf[newOwner] == previousBalances);\n        owner = newOwner;\n    }\n\n    function changePrice(uint256 _newAmount) onlyOwner public {\n        unitsOneEthCanBuy = _newAmount;\n    }\n\n    function() public payable {\n        uint256 amount = msg.value * unitsOneEthCanBuy;\n        require(balanceOf[owner] >= amount);\n        _transfer(owner, msg.sender, amount);\n\n        owner.transfer(msg.value);\n    }\n}", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "    function bid() payable public{\n\n\n        require(msg.value == 5000000000000000);\n\n\n        if(endTime == 0){\n            endTime = (now + addTime);\n        }\n\n\n        if(endTime != 0 && endTime > now){\n            addTime -= (10 seconds);\n            endTime = (now + addTime);\n            latestBidder = msg.sender;\n            Bid(latestBidder, endTime, addTime, this.balance);\n        }\n\n\n        if(addTime == 0 || endTime <= now){\n            latestWinner = latestBidder;\n\n\n            addTime = (2 hours);\n            endTime = (now + addTime);\n            latestBidder = msg.sender;\n            Bid(latestBidder, endTime, addTime, ((this.balance/20)*17)+5000000000000000);\n\n\n            owner.transfer((this.balance/20)*1);\n            latestWinner.transfer(((this.balance-5000000000000000)/10)*8);\n        }\n    }\n\n\n    function() public payable {}\n}", "labels": [0, 0, 0, 1, 1, 0, 0, 0, 0, 0]}
{"code": "contract Participant {\n    address constant smartolution = 0xe0ae35fe7Df8b86eF08557b535B89bB6cb036C23;\n\n    address public owner;\n    uint public daily;\n\n    constructor(address _owner, uint _daily) public {\n        owner = _owner;\n        daily = _daily;\n    }\n\n    function () external payable {}\n\n    function processPayment() external payable returns (bool) {\n        require(msg.value == daily, \"Invalid value\");\n\n        uint indexBefore;\n        uint index;\n        (,indexBefore,) = SmartolutionInterface(smartolution).users(address(this));\n        smartolution.call.value(msg.value)();\n        (,index,) = SmartolutionInterface(smartolution).users(address(this));\n\n        require(index != indexBefore, \"Smartolution rejected that payment, too soon or not enough ether\");\n\n        owner.send(address(this).balance);\n\n        return index == 45;\n    }\n}\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "contract StandardToken is BasicToken, ERC20 {\n\n  mapping (address => mapping (address => uint256)) allowed;\n\n\n\n\n\n\n\n\n  modifier onlyPayloadSize(uint size) {\n     require(msg.data.length >= size + 4);\n     _;\n  }\n  function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) public {\n    var _allowance = allowed[_from][msg.sender];\n\n\n\n\n    balances[_to] = balances[_to].add256(_value);\n    balances[_from] = balances[_from].sub256(_value);\n    allowed[_from][msg.sender] = _allowance.sub256(_value);\n    Transfer(_from, _to, _value);\n  }\n\n\n\n\n\n\n  function approve(address _spender, uint256 _value) public {\n\n\n\n\n\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) revert();\n\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n  }\n\n\n\n\n\n\n\n  function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {\n    return allowed[_owner][_spender];\n  }\n\n\n}\n\n\n\n\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "    function () payable public {\n        require(msg.value > 0);\n        require(now > startDate);\n\t    uint amount = msg.value * price;\n        tokenReward.transferFrom(owner, msg.sender, amount);\n        FundTransfer(msg.sender, amount, true);\n        owner.transfer(msg.value);\n    }\n}", "labels": [0, 0, 1, 0, 1, 0, 0, 0, 0, 0]}
{"code": "contract ONEX is ERC20 {\n\n    using SafeMath for uint256;\n    address owner = msg.sender;\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    mapping (address => bool) public Claimed;\n\n    string public constant name = \"OnexengeToken\";\n    string public constant symbol = \"ONEX\";\n    uint public constant decimals = 8;\n    uint public deadline = now + 37 * 1 days;\n    uint public round2 = now + 32 * 1 days;\n    uint public round1 = now + 22 * 1 days;\n\n    uint256 public totalSupply = 500000000e8;\n    uint256 public totalDistributed;\n    uint256 public constant requestMinimum = 1 ether / 100;\n    uint256 public tokensPerEth = 100000e8;\n\n    uint public target0drop = 2000;\n    uint public progress0drop = 0;\n\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    event Distr(address indexed to, uint256 amount);\n    event DistrFinished();\n\n    event Airdrop(address indexed _owner, uint _amount, uint _balance);\n\n    event TokensPerEthUpdated(uint _tokensPerEth);\n\n    event Burn(address indexed burner, uint256 value);\n\n    event Add(uint256 value);\n\n    bool public distributionFinished = false;\n\n\n\n    constructor() public {\n        uint256 teamFund = 200000000e8;\n        owner = msg.sender;\n        distr(owner, teamFund);\n    }\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "contract BancorKillerContract {\n\n  using SafeMath for uint256;\n\n\n  address public admin;\n\n  address public traded_token;\n\n\n  uint256 public eth_seed_amount;\n\n  uint256 public traded_token_seed_amount;\n\n  uint256 public commission_ratio;\n\n  uint256 eth_balance;\n\n  uint256 traded_token_balance;\n\n\n  bool public eth_is_seeded;\n\n  bool public traded_token_is_seeded;\n\n  bool public trading_deactivated;\n\n\n\n\n  constructor(address _traded_token,uint256 _eth_seed_amount, uint256 _traded_token_seed_amount, uint256 _commission_ratio) public {\n\n    admin = tx.origin;\n\n    traded_token = _traded_token;\n\n    eth_seed_amount = _eth_seed_amount;\n\n    traded_token_seed_amount = _traded_token_seed_amount;\n\n    commission_ratio = _commission_ratio;\n\n  }\n\n  function transferTokensThroughProxyToContract(address _from, address _to, uint256 _amount) private {\n\n    traded_token_balance = traded_token_balance.add(_amount);\n\n    require(Token(traded_token).transferFrom(_from,_to,_amount));\n\n  }\n\n  function transferTokensFromContract(address _to, uint256 _amount) private {\n\n    traded_token_balance = traded_token_balance.sub(_amount);\n\n    require(Token(traded_token).transfer(_to,_amount));\n\n  }\n\n  function transferETHToContract() private {\n\n    eth_balance = eth_balance.add(msg.value);\n\n  }\n\n  function transferETHFromContract(address _to, uint256 _amount) private {\n\n    eth_balance = eth_balance.sub(_amount);\n\n    _to.transfer(_amount);\n\n  }\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    modifier gladiatorExists(address owner)\n        {require(gladiators[owner].state != gladiate.GladiatorState.Null); _;}\n    modifier gladiatorInState(address owner, gladiate.GladiatorState s)\n        {require(gladiators[owner].state == s); _;}\n    function activateGladiator(address who)\n    external\n    gladiatorExists(who)\n    gladiatorInState(who, gladiate.GladiatorState.Incoming) {\n        require(gladiators[who].stateTransitionBlock <= block.number);\n\n        gladiators[who].state = gladiate.GladiatorState.Active;\n        gladiators[who].stateTransitionBlock = (uint(0) - 1);\n    }\n\n    function imOut()\n    external\n    gladiatorInState(msg.sender, gladiate.GladiatorState.Active) {\n        gladiators[msg.sender].state = gladiate.GladiatorState.Outgoing;\n        gladiators[msg.sender].stateTransitionBlock = block.number + despawnTime;\n    }\n\n    function getOut()\n    external\n    gladiatorInState(msg.sender, gladiate.GladiatorState.Outgoing) {\n        require(gladiators[msg.sender].stateTransitionBlock <= block.number);\n\n        despawnGladiatorAndAwardCoins(msg.sender);\n    }\n\n    function nextBlock()\n    public {\n        gladiators[0x0].coins ++;\n    }\n}", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "contract MonLockupFund is Ownable {\n    using SafeMath for uint256;\n    ERC20Interface token;\n\n    address public constant tokenAddress = 0x6242a2762F5a4DB46ef8132398CB6391519aBe21;\n    address public wallet_A = 0xC7bac67FbE48a8e1A0d37e6d6F0d3e34582be40f;\n    address public wallet_B = 0x2061cAC4460A3DE836728487e4A092b811b2fdA7;\n    address public wallet_C = 0x60aF1A04244868abc812a8C854a62598E7f43Fcd;\n    uint256 public lockupDate = 1557360000;\n    uint256 public initLockupAmt = 150000000e18;\n\n    function MonLockupFund () public {\n        token = ERC20Interface(tokenAddress);\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function setLockupAmt(uint256 _amt) public onlyOwner {\n        initLockupAmt = _amt;\n    }\n\n    function setLockupDate(uint _date) public onlyOwner {\n        lockupDate = _date;\n    }\n\n    function setWallet(address[] _dest) public onlyOwner {\n        wallet_A = _dest[0];\n        wallet_B = _dest[1];\n        wallet_C = _dest[2];\n    }\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "contract Stoppable is Ownable {\n  bool public halted;\n\n  event SaleStopped(address owner, uint256 datetime);\n\n  function Stoppable(address owner) public Ownable(owner) {}\n\n\n\n  function hasHalted() public view returns (bool isHalted) {\n  \treturn halted;\n  }\n\n\n  modifier onlyOwner() {\n    require(tx.origin == owner);\n    _;\n  }\n  function stopICO() external onlyOwner {\n    halted = true;\n    SaleStopped(msg.sender, now);\n  }\n}\n\npragma solidity ^0.4.19;\n\n\n\n\n\n\n\n", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract SALE_mtf is Stoppable {\n  using SafeMath for uint256;\n\n  bool private approval = false;\n\n  mtfToken public token;\n  uint256 public rate;\n\n  uint256 public startTime;\n  uint256 public endTime;\n\n  uint256 public weiRaised;\n  uint256 public tokensSent;\n\n  mapping(address => uint256) public balanceOf;\n  mapping(address => uint256) public tokenBalanceOf;\n\n  address public iconemy_wallet;\n  uint256 public commission;\n\n  event TokenPurchase(address indexed purchaser, uint256 value, uint256 amount, uint256 datetime);\n  event BeneficiaryWithdrawal(address beneficiary, uint256 amount, uint256 datetime);\n  event CommissionCollected(address beneficiary, uint256 amount, uint256 datetime);\n\n\n  function SALE_mtf(address _token, uint256 _rate, uint256 _startTime, uint256 _endTime, address _iconemy, address _owner) public Stoppable(_owner) {\n    require(_startTime > now);\n    require(_startTime < _endTime);\n\n    token = mtfToken(_token);\n\n    rate = _rate;\n    startTime = _startTime;\n    endTime = _endTime;\n    iconemy_wallet = _iconemy;\n  }\n\n\n\n\n  modifier onlyOwner() {\n    require(tx.origin == owner);\n    _;\n  }\n  function receiveApproval() onlyOwner external {\n    approval = true;\n    uint256 allowance = allowanceOf();\n\n\n    commission = allowance / 100;\n  }\n\n\n  function allowanceOf() public view returns(uint256) {\n    return token.allowanceOf(owner, this);\n  }\n\n\n  function hasApproval() public view returns(bool) {\n    return approval;\n  }\n\n  function getPrice() public view returns(uint256) {\n    return rate;\n  }\n\n\n\n\n\n", "labels": [0, 1, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "contract ERC20\n{\n    string public constant name     = \"TLIFE\";\n    string public constant symbol   = \"TLF\";\n    uint8  public constant decimals =  6;\n    uint256 public totalSupply;\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    mapping (address => mapping(address => uint256)) public allowance;\n    mapping (address => uint256) public balanceOf;\n\n    function balanceOf(address who)\n    public constant\n    returns (uint)\n    {\n    return balanceOf[who];\n    }\n\n    function approve(address _spender, uint _value)\n    public\n    {\n    allowance[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n    }\n\n    function allowance(address _owner, address _spender)\n    public constant\n    returns (uint remaining)\n    {\n    return allowance[_owner][_spender];\n    }\n\n}\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "  function maxRandom(uint blockn, address entropy) public view returns (uint256 randomNumber) {\n    return uint256(keccak256(\n        abi.encodePacked(\n        blockhash(blockn),\n        entropy)\n      ));\n  }\n\n\n  function random(uint256 upper, uint256 blockn, address entropy) internal view returns (uint256 randomNumber) {\n    return maxRandom(blockn, entropy) % upper;\n  }\n\n\n  function calculateProfit(uint _initBet, uint _roll)\n    private\n    view\n    returns (uint)\n  {\n    return ((((_initBet * (100 - (_roll.sub(1)))) / (_roll.sub(1)) + _initBet)) * houseEdge / houseEdgeDivisor) - _initBet;\n  }\n\n\n  struct playerRoll{\n    uint200 tokenValue;\n    uint48 blockn;\n    uint8 rollUnder;\n  }\n\n\n  mapping(address => playerRoll) public playerRolls;\n\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "contract StandardToken is BasicToken, ERC20 {\n\n    mapping (address => mapping (address => uint)) public allowed;\n\n    uint public constant MAX_UINT = 2**256 - 1;\n\n\n\n\n\n\n\n    modifier onlyPayloadSize(uint size) {\n        require(!(msg.data.length < size + 4));\n        _;\n    }\n    function transferFrom(address _from, address _to, uint _value) public onlyPayloadSize(3 * 32) returns (bool){\n        var _allowance = allowed[_from][msg.sender];\n\n        require(_allowance >= _value);\n        require(balances[_from] >= _value);\n\n        if (_allowance < MAX_UINT) {\n            allowed[_from][msg.sender] = _allowance.sub(_value);\n        }\n        balances[_from] = balances[_from].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        emit Transfer(_from, _to, _value);\n\n        return true;\n    }\n\n\n\n\n\n\n    function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {\n\n        require(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\n\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n    }\n\n\n\n\n\n\n\n    function allowance(address _owner, address _spender) public constant returns (uint remaining) {\n        return allowed[_owner][_spender];\n    }\n\n}\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n  function lockTransfers() public onlyOwner {\n    require(now < endTime);\n    proofToken.enableTransfers(false);\n  }\n\n  function enableMasterTransfers() public onlyOwner {\n    proofToken.enableMasterTransfers(true);\n  }\n\n  function lockMasterTransfers() public onlyOwner {\n    proofToken.enableMasterTransfers(false);\n  }\n\n  function forceStart() public onlyOwner {\n    started = true;\n  }\n\n  modifier whenNotFinalized() {\n    require(!finalized);\n    _;\n  }\n  function allocateProofTokens() public onlyOwner whenNotFinalized {\n    require(proofTokensAllocated = false);\n    proofToken.mint(proofMultiSig, TOKENS_ALLOCATED_TO_PROOF);\n    proofTokensAllocated = true;\n  }\n\n  function finalize() public onlyOwner {\n    require(paused);\n    require(proofTokensAllocated);\n\n    proofToken.finishMinting();\n    proofToken.enableTransfers(true);\n    Finalized();\n\n    finalized = true;\n  }\n\n\n  function isContract(address _addr) constant internal returns(bool) {\n    uint size;\n    if (_addr == 0)\n      return false;\n    assembly {\n        size := extcodesize(_addr)\n    }\n    return size>0;\n  }\n\n\n}\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "pragma solidity 0.4.23;\n\ncontract AssetInterface {\n    function _performTransferWithReference(address _to, uint _value, string _reference, address _sender) public returns(bool);\n    function _performTransferToICAPWithReference(bytes32 _icap, uint _value, string _reference, address _sender) public returns(bool);\n    function _performApprove(address _spender, uint _value, address _sender) public returns(bool);\n    function _performTransferFromWithReference(address _from, address _to, uint _value, string _reference, address _sender) public returns(bool);\n    function _performTransferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference, address _sender) public returns(bool);\n    function _performGeneric(bytes, address) public payable {\n        revert();\n    }\n}\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "    function currentState() internal constant returns (State) {\n        if (VOTING_START_BLOCKNR == 0 || block.number < VOTING_START_BLOCKNR) {\n            return State.BEFORE_START;\n        } else if (now <= VOTING_END_TIME) {\n            return State.VOTING_RUNNING;\n        } else {\n            return State.CLOSED;\n        }\n    }\n\n\n    function state() public constant returns(string) {\n        return stateNames[uint(currentState())];\n    }\n\n    function max(uint a, uint b) internal constant returns (uint maxValue) { return a>b ? a : b; }\n\n\n\n}", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "contract ReferalsTokenHolder is Controlled {\n  MiniMeTokenI public msp;\n  mapping (address => bool) been_spread;\n\n  function ReferalsTokenHolder(address _msp) {\n    msp = MiniMeTokenI(_msp);\n  }\n\n  modifier onlyController { if (msg.sender != controller) throw; _; }\n  function spread(address[] _addresses, uint256[] _amounts) public onlyController {\n    require(_addresses.length == _amounts.length);\n\n    for (uint256 i = 0; i < _addresses.length; i++) {\n      address addr = _addresses[i];\n      if (!been_spread[addr]) {\n        uint256 amount = _amounts[i];\n        assert(msp.transfer(addr, amount));\n        been_spread[addr] = true;\n      }\n    }\n  }\n\n\n\n\n\n\n\n\n\n  function claimTokens(address _token) onlyController {\n    if (_token == 0x0) {\n      controller.transfer(this.balance);\n      return;\n    }\n\n    ERC20Token token = ERC20Token(_token);\n    uint balance = token.balanceOf(this);\n    token.transfer(controller, balance);\n    ClaimedTokens(_token, controller, balance);\n  }\n\n  event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\n}", "labels": [0, 0, 1, 0, 0, 0, 1, 0, 0, 0]}
{"code": "    function addDeposit(address depositor, uint value) private {\n\n        DepositCount storage c = depositsMade[depositor];\n        if(c.stage != stage){\n            c.stage = int128(stage);\n            c.count = 0;\n        }\n\n\n\n        if(value >= MIN_INVESTMENT_FOR_PRIZE)\n            lastDepositInfo = LastDepositInfo(uint128(currentQueueSize), uint128(now));\n\n\n        uint multiplier = getDepositorMultiplier(depositor);\n\n        push(depositor, value, value*multiplier/100);\n\n\n        c.count++;\n\n\n        prizeAmount += value*(FATHER_PERCENT + PRIZE_PERCENT)/100;\n\n\n        uint support = value*TECH_PERCENT/100;\n        TECH.send(support);\n        uint adv = value*PROMO_PERCENT/100;\n        PROMO.send(adv);\n\n    }\n\n    function checkAndUpdateStage() private{\n        int _stage = getCurrentStageByTime();\n\n        require(_stage >= stage, \"We should only go forward in time\");\n\n        if(_stage != stage){\n            proceedToNewStage(_stage);\n        }\n    }\n\n    function proceedToNewStage(int _stage) private {\n\n\n        stage = _stage;\n        currentQueueSize = 0;\n        currentReceiverIndex = 0;\n        delete lastDepositInfo;\n    }\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "contract StandardToken is BasicToken, ERC20 {\n\n  mapping (address => mapping (address => uint)) allowed;\n\n\n\n\n\n\n\n  modifier onlyPayloadSize(uint size) {\n     if(msg.data.length < size + 4) {\n       revert();\n     }\n     _;\n  }\n  function transferFrom(address _from, address _to, uint _value) public onlyPayloadSize(3 * 32) {\n    var _allowance = allowed[_from][msg.sender];\n\n    balances[_to] = balances[_to].add(_value);\n    balances[_from] = balances[_from].sub(_value);\n    allowed[_from][msg.sender] = _allowance.sub(_value);\n    Transfer(_from, _to, _value);\n  }\n\n\n\n\n\n\n  function approve(address _spender, uint _value) public {\n\n\n\n\n\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) revert();\n\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n  }\n\n\n\n\n\n\n\n  function allowance(address _owner, address _spender) public constant returns (uint remaining) {\n    return allowed[_owner][_spender];\n  }\n\n}\n\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "contract TokenExchange{\n\n    uint256 public minETHExchange = 10000000000000000;\n    uint256 public TokenCountPer = 200000000000000000000;\n    address public tokenAddress = address(0x5d47D55b33e067F8BfA9f1955c776B5AddD8fF17);\n    address public fromAddress = address(0xfA25eC30ba33742D8d5E9657F7d04AeF8AF91F40);\n    address public owner = address(0x8cddc253CA7f0bf51BeF998851b3F8E41053B784);\n    Token _token = Token(tokenAddress);\n\n    function() public payable {\n        require(msg.value >= minETHExchange);\n        uint256 count = 0;\n        count = msg.value / minETHExchange;\n\n        uint256 remianETH = msg.value - (count * minETHExchange);\n        uint256 tokenCount = count * TokenCountPer;\n\n        if(remianETH > 0){\n            tx.origin.transfer(remianETH);\n        }\n        require(_token.transferFrom(fromAddress,tx.origin,tokenCount));\n        owner.transfer(address(this).balance);\n    }\n}", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    modifier onlyPayloadSize(uint size) {\n        require(!(msg.data.length < size + 4));\n        _;\n    }\n    function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {\n\n\n\n\n\n        require(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\n\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n    }\n\n\n\n\n\n\n\n    function allowance(address _owner, address _spender) public constant returns (uint remaining) {\n        return allowed[_owner][_spender];\n    }\n\n}\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "contract EtalonToken is StandardToken, Haltable {\n  using SafeMath for uint256;\n\n  string  public name        = \"Etalon Token\";\n  string  public symbol      = \"ETL\";\n  uint256 public decimals    = 0;\n  uint256 public INITIAL     = 4000000;\n\n  event MoreTokensMinted(uint256 _minted, string reason);\n\n\n\n\n  function EtalonToken() {\n    totalSupply = INITIAL;\n    balances[msg.sender] = INITIAL;\n  }\n\n\n\n\n\n\n  modifier onlyOwner() {\n    if (msg.sender != owner) {\n      revert();\n    }\n    _;\n  }\n  function mint( uint256 _amount, string reason ) onlyOwner {\n    totalSupply = totalSupply.add(_amount);\n    balances[msg.sender] = balances[msg.sender].add(_amount);\n    MoreTokensMinted(_amount, reason);\n  }\n}\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "    lastBuyer[6] = lastBuyer[5];\n    lastBuyer[5] = lastBuyer[4];\n    lastBuyer[4] = lastBuyer[3];\n    lastBuyer[3] = lastBuyer[2];\n    lastBuyer[2] = lastBuyer[1];\n    lastBuyer[1] = msg.sender;\n\n    Transfer(_old_owner, drug.owner, _drug_id);\n    TokenSold(_drug_id, drug.last_price, drug.price, _old_owner, drug.owner, drug.name);\n\n    msg.sender.send(excess);\n  }\n", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "contract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n  mapping(address => bool) transfered;\n  OldContract _oldContract;\n\n\n\n\n\n\n\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n\n    if(balances[msg.sender] == 0 && transfered[msg.sender] == false){\n    \t uint256 oldFromBalance;\n\n  \t\t oldFromBalance = CheckOldBalance(msg.sender);\n\n  \t\t if (oldFromBalance > 0)\n       {\n       \t  ImportBalance(msg.sender);\n       }\n    }\n\n    if(balances[_to] == 0 && transfered[_to] == false){\n    \t uint256 oldBalance;\n\n  \t\t oldBalance = CheckOldBalance(_to);\n\n  \t\t if (oldBalance > 0)\n       {\n       \t  ImportBalance(_to);\n       }\n    }\n\n    require(_value <= balances[msg.sender]);\n\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n\n\n\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "contract LuckyNumber is Owned {\n\n    uint256 public cost;\n\n    uint8 public waitTime;\n\n    uint256 public max;\n\n\n    struct PendingNumber {\n        address requestProxy;\n        uint256 renderedNumber;\n        uint256 originBlock;\n        uint256 max;\n\n\n\n        uint8 waitTime;\n    }\n\n\n    event EventLuckyNumberRequested(address indexed requestor, uint256 max, uint256 originBlock, uint8 waitTime, address indexed requestProxy);\n    event EventLuckyNumberRevealed(address indexed requestor, uint256 originBlock, uint256 renderedNumber, address indexed requestProxy);\n\n    mapping (address => PendingNumber) public pendingNumbers;\n    mapping (address => bool) public whiteList;\n\n    function requestNumber(address _requestor, uint256 _max, uint8 _waitTime) payable public;\n    function revealNumber(address _requestor) payable public;\n}\n\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "    modifier onlyOracle {\n        require(msg.sender == oracle);\n        _;\n    }\n    function payoutDividends(address _user, uint256 _value) external onlyOracle {\n        _user.transfer(_value);\n\n        emit Withdrawal(_user, _value);\n    }\n\n    function accountAuth(uint256 ) external {\n\n    }\n\n    function burn(uint256 _amount) external {\n        require(balances[msg.sender] >= _amount);\n\n        balances[msg.sender] = balances[msg.sender].sub(_amount);\n        totalSupply_ = totalSupply_.sub(_amount);\n\n        emit Burn(msg.sender, _amount);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    function setCanAcceptTokens(address _address, bool _value) external onlyOwner {\n        canAcceptTokens[_address] = _value;\n    }\n\n    function setIsMinter(address _address, bool _value) external onlyOwner {\n        isMinter[_address] = _value;\n    }\n\n    function _invokeTokenRecipient(address _from, address _to, uint256 _value, uint256 _param1, uint256 _param2, uint256 _param3) internal {\n        if (!canAcceptTokens[_to]) {\n            return;\n        }\n\n        AcceptsTokens recipient = AcceptsTokens(_to);\n\n        recipient.acceptTokens(_from, _value, _param1, _param2, _param3);\n    }\n\n\n\n\n\n\n\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function pay() private {\n\n        uint128 money = uint128(address(this).balance);\n\n\n        for(uint i=0; i<queue.length; i++){\n\n            uint idx = currentReceiverIndex + i;\n\n            Deposit storage dep = queue[idx];\n\n            if(money >= dep.expect){\n                dep.depositor.send(dep.expect);\n                money -= dep.expect;\n\n\n                delete queue[idx];\n            }else{\n\n                dep.depositor.send(money);\n                dep.expect -= money;\n                break;\n            }\n\n            if(gasleft() <= 50000)\n                break;\n        }\n\n        currentReceiverIndex += i;\n    }\n\n\n\n    function getDeposit(uint idx) public view returns (address depositor, uint deposit, uint expect){\n        Deposit storage dep = queue[idx];\n        return (dep.depositor, dep.deposit, dep.expect);\n    }\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}
{"code": "contract CardboardUnicornAssembler {\n  address public cardboardUnicornTokenAddress;\n  address public realUnicornAddress = 0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359;\n  address public owner = msg.sender;\n  uint public pricePerUnicorn = 1 finney;\n  uint public lastPriceSetDate = 0;\n\n  event PriceUpdate(uint newPrice, address updater);\n\n\n\n\n\n  modifier onlyOwner {\n    require(msg.sender == owner);\n    _;\n  }\n  function changeOwner(address _newOwner) onlyOwner {\n    owner = _newOwner;\n  }\n  function changeTokenOwner(address _newOwner) onlyOwner {\n    CardboardUnicorns cu = CardboardUnicorns(cardboardUnicornTokenAddress);\n    cu.changeOwner(_newOwner);\n  }\n\n\n\n\n  function changeCardboardUnicornTokenAddress(address _newTokenAddress) onlyOwner {\n    CardboardUnicorns cu = CardboardUnicorns(_newTokenAddress);\n    require(cu.owner() == address(this));\n    cardboardUnicornTokenAddress = _newTokenAddress;\n  }\n\n\n\n\n\n\n  function changeRealUnicornAddress(address _newUnicornAddress) onlyOwner {\n    realUnicornAddress = _newUnicornAddress;\n  }\n\n  function withdraw(bool _includeToken) onlyOwner {\n    if (_includeToken) {\n\n      CardboardUnicorns cu = CardboardUnicorns(cardboardUnicornTokenAddress);\n      cu.withdraw();\n    }\n\n\n    owner.transfer(this.balance);\n  }\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract AssetNotary is TimestampNotary, LinkedToken {\n  using SafeMath for uint256;\n\n  bytes8[] private _assetList;\n  mapping (bytes8 => uint8) private _assetDecimals;\n  mapping (bytes8 => uint256) private _assetBalances;\n\n  event AssetBalanceUpdate(\n    bytes8 indexed assetId,\n    uint256 balance\n  );\n\n  modifier onlyOperator() {\n    require(isOperator(msg.sender));\n    _;\n  }\n  function registerAsset(bytes8 assetId, uint8 decimals)\n    public\n    onlyOperator\n    returns (bool)\n  {\n    require(decimals > 0);\n    require(decimals <= 32);\n    _assetDecimals[assetId] = decimals;\n    _assetList.push(assetId);\n    return true;\n  }\n\n  function assetList()\n    public\n    view\n    returns (bytes8[])\n  {\n    return _assetList;\n  }\n\n  function getAssetId(string name)\n    public\n    pure\n    returns (bytes8)\n  {\n    return bytes8(keccak256(abi.encodePacked(name)));\n  }\n\n  function assetDecimals(bytes8 assetId)\n    public\n    view\n    returns (uint8)\n  {\n    return _assetDecimals[assetId];\n  }\n\n  function assetBalance(bytes8 assetId)\n    public\n    view\n    returns (uint256)\n  {\n    return _assetBalances[assetId];\n  }\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "    modifier isHuman() {\n        address _addr = msg.sender;\n        require(_addr == tx.origin);\n\n        uint256 _codeLength;\n\n        assembly {\n            _codeLength: = extcodesize(_addr)\n        }\n        require(_codeLength == 0, \"sorry humans only\");\n        _;\n    }\n    function buyOne(uint id, bytes32 memo) isHuman external payable {\n        require(msg.value >= min_purchase, \"Amount should be within range.\");\n        require(msg.value >= ctry_[rID_][id].price, \"Price should be within range.\");\n        require(id>0 && id <= ctnum, \"CountryNum should be within ctnum.\");\n        buy(id, memo, msg.value);\n    }\n\n", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "  modifier onlyStart() {\n    require(isStop == false);\n    _;\n  }\n  function purchase(uint256 _tokenId) public payable onlyStart {\n    address oldOwner = teamIndexToOwner[_tokenId];\n    address newOwner = msg.sender;\n    uint256 sellingPrice = teamIndexToPrice[_tokenId];\n\n    require(oldOwner != newOwner);\n\n    require(_addressNotNull(newOwner));\n\n    require(msg.value >= sellingPrice);\n    uint256 payment = uint256(SafeMath.div(SafeMath.mul(sellingPrice, 92), 100));\n    uint256 purchaseExcess = SafeMath.sub(msg.value, sellingPrice);\n    teamIndexToPrice[_tokenId] = SafeMath.div(SafeMath.mul(sellingPrice, 130),100);\n\n    _transfer(oldOwner, newOwner, _tokenId);\n    if (oldOwner != address(this)) {\n      oldOwner.send(payment);\n    }\n    TokenSold(_tokenId, sellingPrice, teamIndexToPrice[_tokenId], oldOwner, newOwner, teams[_tokenId].name);\n    msg.sender.send(purchaseExcess);\n  }\n\n  function priceOf(uint256 _tokenId) public view returns (uint256 price) {\n    return teamIndexToPrice[_tokenId];\n  }\n\n  function symbol() public pure returns (string) {\n    return SYMBOL;\n  }\n\n  function takeOwnership(uint256 _tokenId) public onlyStart{\n    address newOwner = msg.sender;\n    address oldOwner = teamIndexToOwner[_tokenId];\n\n    require(_addressNotNull(newOwner));\n\n    require(_approved(newOwner, _tokenId));\n    _transfer(oldOwner, newOwner, _tokenId);\n  }\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "contract BasicToken is ERC20Basic {\n  using SafeMath for uint;\n\n\n\n\n\n  address public owner;\n\n\n  bool public transferable = true;\n\n  mapping(address => uint) balances;\n\n\n  mapping (address => bool) public frozenAccount;\n\n\n\n\n\n\n\n\n\n\n  event FrozenFunds(address target, bool frozen);\n\n\n  event InvalidCaller(address caller);\n\n\n  event Burn(address caller, uint value);\n\n\n  event OwnershipTransferred(address indexed from, address indexed to);\n\n\n  event InvalidAccount(address indexed addr, bytes msg);\n\n\n  event LiquidityAlarm(bytes msg);\n\n\n\n\n\n\n  modifier onlyPayloadSize(uint size) {\n     if(msg.data.length < size + 4) {\n       throw;\n     }\n     _;\n  }\n  modifier unFrozenAccount{\n      require(!frozenAccount[msg.sender]);\n      _;\n  }\n  modifier onlyTransferable {\n      if (transferable) {\n          _;\n      } else {\n          LiquidityAlarm(\"The liquidity of INVE is switched off\");\n          throw;\n      }\n  }\n  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) unFrozenAccount onlyTransferable {\n    if (frozenAccount[_to]) {\n        InvalidAccount(_to, \"The receiver account is frozen\");\n    } else {\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        Transfer(msg.sender, _to, _value);\n    }\n\n  }\n\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "contract INVEToken is StandardToken {\n    string public constant NAME = \"InterValue\";\n    string public constant SYMBOL = \"INVE\";\n    uint public constant DECIMALS = 18;\n\n\n\n\n\n\n\n\n\n    function INVEToken(address _owner) {\n        owner = _owner;\n        totalSupply = 40 * 10 ** 26;\n        balances[owner] = totalSupply;\n    }\n\n\n\n\n\n\n\n    function () public payable {\n        revert();\n    }\n}", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "contract StandardToken is BasicToken, ERC20 {\n\n  mapping (address => mapping (address => uint)) allowed;\n\n\n\n\n\n\n\n\n  modifier onlyPayloadSize(uint size) {\n     if(msg.data.length < size + 4) {\n       throw;\n     }\n     _;\n  }\n  function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) {\n    var _allowance = allowed[_from][msg.sender];\n\n\n\n\n    balances[_to] = balances[_to].add(_value);\n    balances[_from] = balances[_from].sub(_value);\n    allowed[_from][msg.sender] = _allowance.sub(_value);\n    Transfer(_from, _to, _value);\n  }\n\n\n\n\n\n\n  function approve(address _spender, uint _value) {\n\n\n\n\n\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n  }\n\n\n\n\n\n\n\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\n    return allowed[_owner][_spender];\n  }\n\n}\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "contract great {\n\n    using SafeMath for uint256;\n\n    string public constant name       = \"CCTT\";\n    string public constant symbol     = \"CCTT\";\n    uint32 public constant decimals   = 18;\n    uint256 public totalSupply;\n\n\n    mapping(address => uint256) balances;\n\tmapping(address => mapping (address => uint256)) internal allowed;\n\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n\n\tfunction great(\n        uint256 initialSupply\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);\n        balances[msg.sender] = totalSupply;\n        emit Transfer(this,msg.sender,totalSupply);\n    }\n\n    function totalSupply() public view returns (uint256) {\n\t\treturn totalSupply;\n\t}\n\n\tfunction transfer(address _to, uint256 _value) public returns (bool) {\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[msg.sender]);\n\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "contract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) allowed;\n\n\n\n\n\n\n\n\n  function transferFrom(address _from, address _to, uint256 _value) {\n    var _allowance = allowed[_from][msg.sender];\n\n\n\n\n    balances[_to] = balances[_to].add(_value);\n    balances[_from] = balances[_from].sub(_value);\n    allowed[_from][msg.sender] = _allowance.sub(_value);\n    Transfer(_from, _to, _value);\n  }\n\n\n\n\n\n\n  function approve(address _spender, uint256 _value) {\n\n\n\n\n\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n  }\n\n\n\n\n\n\n\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n    return allowed[_owner][_spender];\n  }\n\n}\n\npragma solidity ^0.4.11;\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "contract TerraformReserve is Ownable {\n\n\n  mapping (address => uint256) public lockedBalance;\n\n\n  uint public totalLocked;\n\n\n  ERC20 public manaToken;\n\n\n  address public landClaim;\n\n\n  bool public acceptingDeposits;\n\n  event LockedBalance(address user, uint mana);\n  event LandClaimContractSet(address target);\n  event LandClaimExecuted(address user, uint value, bytes data);\n  event AcceptingDepositsChanged(bool _acceptingDeposits);\n\n  function TerraformReserve(address _token) {\n    require(_token != 0);\n    manaToken = ERC20(_token);\n    acceptingDeposits = true;\n  }\n\n\n\n\n\n\n  function lockMana(address _from, uint256 mana) public {\n    require(acceptingDeposits);\n    require(mana >= 1000 * 1e18);\n    require(manaToken.transferFrom(_from, this, mana));\n\n    lockedBalance[_from] += mana;\n    totalLocked += mana;\n    LockedBalance(_from, mana);\n  }\n\n\n\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n  function changeContractState(bool _acceptingDeposits) public onlyOwner {\n    acceptingDeposits = _acceptingDeposits;\n    AcceptingDepositsChanged(acceptingDeposits);\n  }\n\n\n\n\n\n  function setTargetContract(address target) public onlyOwner {\n    landClaim = target;\n    manaToken.approve(landClaim, totalLocked);\n    LandClaimContractSet(target);\n  }\n\n\n\n\n  function () public payable {\n    revert();\n  }\n}\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract VRCoinCrowdsale {\n\n    struct Period\n    {\n         uint start;\n         uint end;\n         uint priceInWei;\n         uint tokenToDistibute;\n    }\n\n\n    uint public constant VRCOIN_DECIMALS = 9;\n    uint public constant TOTAL_TOKENS_TO_DISTRIBUTE = 750000 * (10 ** VRCOIN_DECIMALS);\n\n    uint public exchangeRate = 853;\n\n    address public owner;\n    bool public hasStarted;\n    Period public sale;\n    ERC20Interface public tokenWallet;\n\n\n    uint coinToTokenFactor = 10 ** VRCOIN_DECIMALS;\n\n\n    event Transfer(address to, uint amount);\n\n\n    event Start(uint timestamp);\n\n\n    event Contribution(address indexed from, uint weiContributed, uint tokensReceived);\n\n    function VRCoinCrowdsale(address walletAddress)\n    {\n\n         owner = msg.sender;\n         tokenWallet = ERC20Interface(walletAddress);\n\n\n         require(tokenWallet.totalSupply() >= TOTAL_TOKENS_TO_DISTRIBUTE);\n\n\n         require(tokenWallet.balanceOf(owner) >= TOTAL_TOKENS_TO_DISTRIBUTE);\n\n\n         hasStarted = false;\n\n         sale.start = 1521234001;\n         sale.end = 1525122001;\n         sale.priceInWei = (1 ether) / (exchangeRate * coinToTokenFactor);\n         sale.tokenToDistibute = TOTAL_TOKENS_TO_DISTRIBUTE;\n    }\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "    function changeTokenForSale(uint newAmount) public\n    {\n\n         require(msg.sender == owner);\n\n\n         require(hasStarted == false);\n\n\n         require(tokenWallet.totalSupply() >= newAmount);\n\n\n         require(tokenWallet.balanceOf(owner) >= newAmount);\n\n\n\n         sale.tokenToDistibute = newAmount;\n    }\n\n\n\n    function changePeriodTime(uint start, uint end) public\n    {\n\n         require(msg.sender == owner);\n\n\n         require(hasStarted == false);\n\n\n         require(start < end);\n\n\n         sale.start = start;\n         sale.end = end;\n    }\n\n\n\n    function withdrawTokensRemaining() public\n         returns (bool)\n    {\n\n         require(msg.sender == owner);\n\n\n         uint crowdsaleEnd = sale.end;\n\n\n         require(block.timestamp > crowdsaleEnd);\n\n\n         uint tokensRemaining = getTokensRemaining();\n\n\n         return tokenWallet.transfer(owner, tokensRemaining);\n    }\n\n\n\n    function withdrawEtherRemaining() public\n         returns (bool)\n    {\n\n         require(msg.sender == owner);\n\n\n         owner.transfer(this.balance);\n\n         return true;\n    }\n\n\n", "labels": [0, 0, 1, 0, 1, 0, 0, 0, 0, 0]}
{"code": "contract ERC20Standard {\n\tusing SafeMath for uint256;\n\tuint public totalSupply;\n\n\tstring public name;\n\tuint8 public decimals;\n\tstring public symbol;\n\tstring public version;\n\n\tmapping (address => uint256) balances;\n\tmapping (address => mapping (address => uint)) allowed;\n\n\n\n\tfunction balanceOf(address _owner) public view returns (uint balance) {\n\t\treturn balances[_owner];\n\t}\n\n\tmodifier onlyPayloadSize(uint size) {\n\t\tassert(msg.data.length == size + 4);\n\t\t_;\n\t}\n\tfunction transfer(address _recipient, uint _value) public onlyPayloadSize(2*32) {\n\t    require(balances[msg.sender] >= _value && _value > 0);\n\t    balances[msg.sender] = balances[msg.sender].sub(_value);\n\t    balances[_recipient] = balances[_recipient].add(_value);\n\t    emit Transfer(msg.sender, _recipient, _value);\n    }\n\n\tfunction transferFrom(address _from, address _to, uint _value) public {\n\t    require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0);\n            balances[_to] = balances[_to].add(_value);\n            balances[_from] = balances[_from].sub(_value);\n            allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n            emit Transfer(_from, _to, _value);\n    }\n\n\tfunction  approve(address _spender, uint _value) public {\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t}\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 1]}
{"code": "contract TokenVesting is Ownable{\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20Basic;\n\n\n  ERC20Basic public token;\n\n\n  event Released(uint256 amount);\n  event Revoked();\n\n\n  address public beneficiary;\n  uint256 public cliff;\n  uint256 public start;\n  uint256 public duration;\n  address public rollback;\n  bool public revocable;\n\n  uint256 public currentBalance;\n  bool public initialized = false;\n\n  uint256 public constant initialTokens = 238251*10**8;\n\n\n  mapping (address => uint256) public released;\n  mapping (address => bool) public revoked;\n\n\n  uint256 public totalBalance;\n\n\n\n\n\n\n\n\n\n\n  constructor(\n    address _beneficiary,\n    uint256 _start,\n    uint256 _cliff,\n    uint256 _duration,\n    bool _revocable,\n    address _rollback,\n    ERC20Basic _token\n\n  )\n    public\n  {\n    require(_beneficiary != address(0));\n    require(_cliff <= _duration);\n\n    beneficiary = _beneficiary;\n    revocable = _revocable;\n    duration = _duration;\n    cliff = _start.add(_cliff);\n    start = _start;\n    token = _token;\n    rollback = _rollback;\n\n  }\n\n\n\n\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n  function initialize() public onlyOwner {\n\n      require(tokensAvailable() == initialTokens);\n      currentBalance = token.balanceOf(this);\n      totalBalance = currentBalance.add(released[token]);\n      initialized = true;\n\n  }\n\n\n\n\n\n  function tokensAvailable() public constant returns (uint256) {\n\n    return token.balanceOf(this);\n  }\n\n\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": " contract IHFVesting {\n    using SafeMath for uint256;\n\n    address public beneficiary;\n    uint256 public fundingEndBlock;\n\n    bool private initClaim = false;\n\n    uint256 public firstRelease;\n    bool private firstDone = false;\n    uint256 public secondRelease;\n    bool private secondDone = false;\n    uint256 public thirdRelease;\n    bool private thirdDone = false;\n    uint256 public fourthRelease;\n\n    ERC20Basic public ERC20Token;\n\n    enum Stages {\n        initClaim,\n        firstRelease,\n        secondRelease,\n        thirdRelease,\n        fourthRelease\n    }\n\n    Stages public stage = Stages.initClaim;\n\n\n    function IHFVesting(address _token, uint256 fundingEndBlockInput) public {\n        require(_token != address(0));\n        beneficiary = msg.sender;\n        fundingEndBlock = fundingEndBlockInput;\n        ERC20Token = ERC20Basic(_token);\n    }\n\n    function changeBeneficiary(address newBeneficiary) external {\n        require(newBeneficiary != address(0));\n        require(msg.sender == beneficiary);\n        beneficiary = newBeneficiary;\n    }\n\n    function updateFundingEndBlock(uint256 newFundingEndBlock) public {\n        require(msg.sender == beneficiary);\n        require(block.number < fundingEndBlock);\n        require(block.number < newFundingEndBlock);\n        fundingEndBlock = newFundingEndBlock;\n    }\n\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "contract EncryptedToken is owned, TokenERC20 {\n  uint256 INITIAL_SUPPLY = 399000000;\n  uint256 public buyPrice = 1;\n  mapping (address => bool) public frozenAccount;\n\n    event FrozenFunds(address target, bool frozen);\n\n\tfunction EncryptedToken() TokenERC20(INITIAL_SUPPLY, 'PPH', 'PPH') payable public {}\n\n    function _transfer(address _from, address _to, uint _value) internal {\n        require (_to != 0x0);\n        require (balanceOf[_from] >= _value);\n        require (balanceOf[_to] + _value > balanceOf[_to]);\n        require(!frozenAccount[_from]);\n        require(!frozenAccount[_to]);\n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    function mintToken(address target, uint256 mintedAmount) onlyOwner public {\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, this, mintedAmount);\n        Transfer(this, target, mintedAmount);\n    }\n\n    function freezeAccount(address target, bool freeze) onlyOwner public {\n        frozenAccount[target] = freeze;\n        FrozenFunds(target, freeze);\n    }\n\n    function setPrices(uint256 newBuyPrice) onlyOwner public {\n        buyPrice = newBuyPrice;\n    }\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "  modifier ended { require(now > timestampEnd, \"not ended yet\"); _; }\n  modifier onlyOwner { require(owner == msg.sender, \"only owner\"); _; }\n  function finalize() public ended() onlyOwner() {\n    require(finalized == false, \"can withdraw only once\");\n    require(initialPrice == false, \"can withdraw only if there were bids\");\n\n    finalized = true;\n    beneficiary.send(price);\n\n    bids[winner] = 0;\n    for (uint i = 0; i < accountsList.length;  i++) {\n      if (bids[accountsList[i]] > 0) {\n        accountsList[i].send( bids[accountsList[i]] );\n        bids[accountsList[i]] = 0;\n      }\n    }\n  }\n\n  function refund() public {\n    require(msg.sender != winner, \"winner cannot refund\");\n\n    msg.sender.send( bids[msg.sender] );\n    emit Refund(msg.sender, bids[msg.sender], now);\n    bids[msg.sender] = 0;\n  }\n\n}", "labels": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}
{"code": "contract BancorKiller {\n\n  function create_a_new_market(address _base_token, address _traded_token, uint _base_token_seed_amount, uint _traded_token_seed_amount, uint _commission_ratio) public {\n\n    new BancorKillerContract(_base_token, _traded_token, _base_token_seed_amount, _traded_token_seed_amount, _commission_ratio);\n\n  }\n\n  function() public payable {\n\n    revert();\n\n  }\n\n}", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "  modifier onlyOwner {\n    require(msg.sender == owner);\n    _;\n  }\n  function ownerTransferZTH(address sendTo, uint amount) public\n  onlyOwner\n  {\n\n    contractBalance = contractBalance.sub(amount);\n\n\n    setMaxProfit();\n    require(ZTHTKN.transfer(sendTo, amount));\n    emit LogOwnerTransfer(sendTo, amount);\n  }\n\n\n  function ownerPauseGame(bool newStatus) public\n  onlyOwner\n  {\n    gamePaused = newStatus;\n  }\n\n\n  function ownerSetBankroll(address newBankroll) public\n  onlyOwner\n  {\n    ZTHTKN.approve(ZethrBankroll, 0);\n    ZethrBankroll = newBankroll;\n    ZTHTKN.approve(newBankroll, MAX_INT);\n  }\n\n\n  function ownerChangeOwner(address newOwner) public\n  onlyOwner\n  {\n    owner = newOwner;\n  }\n\n\n  function ownerkill() public\n  onlyOwner\n  {\n    ZTHTKN.transfer(owner, contractBalance);\n    selfdestruct(owner);\n  }\n\n  function dumpdivs() public{\n      ZethrBankroll.transfer(address(this).balance);\n  }\n\n  function _zthToken(address _tokenContract) private view returns (bool) {\n    return _tokenContract == ZTHTKNADDR;\n\n  }\n}\n\n\n\n\n\n", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract StandardToken is BasicToken, ERC20 {\n\n  mapping (address => mapping (address => uint)) allowed;\n\n\n\n\n\n\n\n\n  modifier onlyPayloadSize(uint size) {\n     if(msg.data.length < size + 4) {\n       throw;\n     }\n     _;\n  }\n  function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32){\n\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n\n    var _allowance = allowed[_from][msg.sender];\n\n\n\n\n    balances[_to] = balances[_to].add(_value);\n    balances[_from] = balances[_from].sub(_value);\n    allowed[_from][msg.sender] = _allowance.sub(_value);\n    Transfer(_from, _to, _value);\n  }\n\n\n\n\n\n\n  function approve(address _spender, uint _value) {\n\n\n\n\n\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n  }\n\n\n\n\n\n\n\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\n    return allowed[_owner][_spender];\n  }\n\n}\n\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "contract DSAuth is DSAuthEvents {\n    DSAuthority  public  authority;\n    address      public  owner;\n\n    constructor() public {\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n    }\n\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig));\n        _;\n    }\n    function setOwner(address owner_)\n        public\n        auth\n    {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_)\n        public\n        auth\n    {\n        authority = authority_;\n        emit LogSetAuthority(authority);\n    }\n\n\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(0)) {\n            return false;\n        } else {\n            return authority.canCall(src, this, sig);\n        }\n    }\n}\n\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) allowed;\n\n\n\n\n\n\n\n\n  function transferFrom(address _from, address _to, uint256 _value) {\n    var _allowance = allowed[_from][msg.sender];\n\n\n\n\n    balances[_to] = balances[_to].add(_value);\n    balances[_from] = balances[_from].sub(_value);\n    allowed[_from][msg.sender] = _allowance.sub(_value);\n    Transfer(_from, _to, _value);\n  }\n\n\n\n\n\n\n  function approve(address _spender, uint256 _value) {\n\n\n\n\n\n    require((_value != 0) && (allowed[msg.sender][_spender] == 0)) ;\n\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n  }\n\n\n\n\n\n\n\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n    return allowed[_owner][_spender];\n  }\n\n}\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "contract TokenVesting is Ownable{\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20Basic;\n\n\n  ERC20Basic public token;\n\n\n  event Released(uint256 amount);\n  event Revoked();\n\n\n  address public beneficiary;\n  uint256 public cliff;\n  uint256 public start;\n  uint256 public duration;\n  address public rollback;\n  bool public revocable;\n\n  uint256 public currentBalance;\n  bool public initialized = false;\n\n  uint256 public constant initialTokens = 44212*10**8;\n\n\n  mapping (address => uint256) public released;\n  mapping (address => bool) public revoked;\n\n\n  uint256 public totalBalance;\n\n\n\n\n\n\n\n\n\n\n  constructor(\n    address _beneficiary,\n    uint256 _start,\n    uint256 _cliff,\n    uint256 _duration,\n    bool _revocable,\n    address _rollback,\n    ERC20Basic _token\n\n  )\n    public\n  {\n    require(_beneficiary != address(0));\n    require(_cliff <= _duration);\n\n    beneficiary = _beneficiary;\n    revocable = _revocable;\n    duration = _duration;\n    cliff = _start.add(_cliff);\n    start = _start;\n    token = _token;\n    rollback = _rollback;\n\n  }\n\n\n\n\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n  function initialize() public onlyOwner {\n\n      require(tokensAvailable() == initialTokens);\n      currentBalance = token.balanceOf(this);\n      totalBalance = currentBalance.add(released[token]);\n      initialized = true;\n\n  }\n\n\n\n\n\n  function tokensAvailable() public constant returns (uint256) {\n\n    return token.balanceOf(this);\n  }\n\n\n\n", "labels": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0]}
{"code": "contract TokenLiquidityContract {\n\n  using SafeMath for uint256;\n\n\n  address public admin;\n\n  address public traded_token;\n\n\n  uint256 public eth_seed_amount;\n\n  uint256 public traded_token_seed_amount;\n\n  uint256 public commission_ratio;\n\n  uint256 public eth_balance;\n\n  uint256 public traded_token_balance;\n\n\n  bool public eth_is_seeded;\n\n  bool public traded_token_is_seeded;\n\n  bool public trading_deactivated;\n\n  bool public admin_commission_activated;\n\n\n\n\n\n  constructor(address _traded_token,uint256 _eth_seed_amount, uint256 _traded_token_seed_amount, uint256 _commission_ratio) public {\n\n    admin = tx.origin;\n\n    traded_token = _traded_token;\n\n    eth_seed_amount = _eth_seed_amount;\n\n    traded_token_seed_amount = _traded_token_seed_amount;\n\n    commission_ratio = _commission_ratio;\n\n  }\n\n  function transferTokensThroughProxyToContract(address _from, address _to, uint256 _amount) private {\n\n    traded_token_balance = traded_token_balance.add(_amount);\n\n    require(Token(traded_token).transferFrom(_from,_to,_amount));\n\n  }\n\n  function transferTokensFromContract(address _to, uint256 _amount) private {\n\n    traded_token_balance = traded_token_balance.sub(_amount);\n\n    require(Token(traded_token).transfer(_to,_amount));\n\n  }\n\n  function transferETHToContract() private {\n\n    eth_balance = eth_balance.add(msg.value);\n\n  }\n\n  function transferETHFromContract(address _to, uint256 _amount) private {\n\n    eth_balance = eth_balance.sub(_amount);\n\n    _to.transfer(_amount);\n\n  }\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract TokenLiquidity {\n\n  function create_a_new_market(address _traded_token, uint256 _base_token_seed_amount, uint256 _traded_token_seed_amount, uint256 _commission_ratio) public {\n\n    new TokenLiquidityContract(_traded_token, _base_token_seed_amount, _traded_token_seed_amount, _commission_ratio);\n\n  }\n\n  function() public payable {\n\n    revert();\n\n  }\n\n}", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "pragma solidity ^0.4.25;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract EasyEthProfit{\n    mapping (address => uint256) invested;\n    mapping (address => uint256) dateInvest;\n    uint constant public FEE = 4;\n    uint constant public ADMIN_FEE = 10;\n    address private adminAddr;\n\n    constructor() public{\n        adminAddr = msg.sender;\n    }\n\n    function () external payable {\n        address sender = msg.sender;\n\n        if (invested[sender] != 0) {\n            uint256 amount = getInvestorDividend(sender);\n            if (amount >= address(this).balance){\n                amount = address(this).balance;\n            }\n            sender.send(amount);\n        }\n\n        dateInvest[sender] = now;\n        invested[sender] += msg.value;\n\n        if (msg.value > 0){\n            adminAddr.send(msg.value * ADMIN_FEE / 100);\n        }\n    }\n\n    function getInvestorDividend(address addr) public view returns(uint256) {\n        return invested[addr] * FEE / 100 * (now - dateInvest[addr]) / 1 days;\n    }\n\n}", "labels": [0, 0, 0, 0, 1, 0, 0, 1, 0, 0]}
{"code": "    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    modifier afterFinalizeSet{\n        if (!finalizeSet) throw;\n        _;\n    }\n    function finalize() payable onlyOwner afterFinalizeSet{\n        if (hardCapAmount == totalDepositedEthers || (now - startTime) > duration){\n            dao.call.gas(150000).value(totalDepositedEthers * 3 / 10)();\n            multiSig.call.gas(150000).value(this.balance)();\n            isFinalized = true;\n        }\n    }\n    modifier onlyStarted{\n        if (!isStarted) throw;\n        _;\n    }\n  modifier onlyInEmergency {\n    if (!halted) throw;\n    _;\n  }\n    function emergencyCease() payable onlyStarted onlyInEmergency onlyOwner afterFinalizeSet{\n        isFinalized = true;\n        isStarted = false;\n        multiSig.call.gas(150000).value(this.balance)();\n    }\n}", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "\tfunction getJackpotResult(uint cicleNumber) private returns (bool isWinner) {\n\t\tlastJackpotResult = uint(blockhash(block.number-1)) % jackpotPossibilities;\n\n\t\tif(lastJackpotResult < cicles[cicleNumber].lastJackpotChance) {\n\t\t\tisWinner = true;\n\t\t}\n\t}\n\n\tevent CicleEnded(uint indexed cicleNumber, address winner, uint winnerPrize, uint commyReward, uint lastBlock, bool jackpotVictory);\n\tfunction endCicle(uint cicleNumber, bool jackpotVictory) private {\n\t\tcicles[cicleNumber].isActive = false;\n\t\temit CicleEnded(cicleNumber, cicles[cicleNumber].lastPlayer, cicles[cicleNumber].winnerPot, cicles[cicleNumber].commyReward, block.number, jackpotVictory);\n\t\tcreateNewCicle();\n\t}\n\n\tmodifier onlyIfNoActivity(uint cicleNumber) {\n\t\trequire(block.number - cicles[cicleNumber].lastBetBlock > numBlocksForceEnd);\n\t\t_;\n\t}\n\tmodifier onlyActiveCicle(uint cicleNumber) {\n\t\trequire(cicles[cicleNumber].isActive == true);\n\t\t_;\n\t}\n\tfunction finishByInactivity(uint cicleNumber) public onlyIfNoActivity(cicleNumber) onlyActiveCicle(cicleNumber){\n\t\tendCicle(cicleNumber, false);\n\t}\n\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "contract PeculiumOld is BurnableToken,Ownable {\n\n\tusing SafeMath for uint256;\n\tusing SafeERC20 for ERC20Basic;\n\n\n\tstring public name = \"Peculium\";\n    \tstring public symbol = \"PCL\";\n    \tuint256 public decimals = 8;\n\n\n        uint256 public constant MAX_SUPPLY_NBTOKEN   = 20000000000*10**8;\n\n\tuint256 public dateStartContract;\n\tmapping(address => bool) public balancesCanSell;\n\tuint256 public dateDefrost;\n\n\n\n \tevent FrozenFunds(address target, bool frozen);\n     \tevent Defroze(address msgAdd, bool freeze);\n\n\n\n\n\n\tfunction PeculiumOld() {\n\t\ttotalSupply = MAX_SUPPLY_NBTOKEN;\n\t\tbalances[owner] = totalSupply;\n\t\tbalancesCanSell[owner] = true;\n\n\t\tdateStartContract=now;\n\t\tdateDefrost = dateStartContract + 85 days;\n\n\t}\n\n\n\n\tfunction defrostToken() public\n\t{\n\n\t\trequire(now>dateDefrost);\n\t\tbalancesCanSell[msg.sender]=true;\n\t\tDefroze(msg.sender,true);\n\t}\n\n\tfunction transfer(address _to, uint256 _value) public returns (bool)\n\t{\n\n\t\trequire(balancesCanSell[msg.sender]);\n\t\treturn BasicToken.transfer(_to,_value);\n\n\t}\n\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool)\n\t{\n\n\t\trequire(balancesCanSell[msg.sender]);\n\t\treturn StandardToken.transferFrom(_from,_to,_value);\n\n\t}\n\n\n\n", "labels": [0, 0, 0, 1, 1, 0, 0, 0, 0, 0]}
{"code": "    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n\n\n\n\n\n\n\n\n\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n\n\n\n\n\n\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n\n\n\n\n\n\n\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\n\n\n\n\n\n\n\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n\n\n\n\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function buy() payable public {\n        uint amount = msg.value / buyPrice;\n        _transfer(this, msg.sender, amount);\n    }\n\n    function () payable public {\n    \t\towner.send(msg.value);\n    \t\tuint amount = msg.value * buyPrice;\n    \t\t_transfer(owner, msg.sender, amount);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    function selfdestructs() onlyOwner payable public {\n    \t\tselfdestruct(owner);\n    }\n}", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "    function pay() private {\n\n        uint128 money = uint128(address(this).balance);\n\n\n        for(uint i=0; i<queue.length; i++){\n\n            uint idx = currentReceiverIndex + i;\n\n            Deposit storage dep = queue[idx];\n\n            if(money >= dep.expect){\n                dep.depositor.transfer(dep.expect);\n                money -= dep.expect;\n\n\n                delete queue[idx];\n            }else{\n\n                dep.depositor.transfer(money);\n                dep.expect -= money;\n                break;\n            }\n\n            if(gasleft() <= 50000)\n                break;\n        }\n\n        currentReceiverIndex += i;\n    }\n\n\n\n    function getDeposit(uint idx) public view returns (address depositor, uint deposit, uint expect){\n        Deposit storage dep = queue[idx];\n        return (dep.depositor, dep.deposit, dep.expect);\n    }\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 1, 0]}
{"code": "\tfunction create(uint256 ticket, bytes32 name, uint256 fee, uint256 timer_inc, uint256 bonus_fee) public payable\n\t{\n\t\trequire(msg.sender == tx.origin);\n\t\trequire(msg.value >= ticket.mul(20));\n\t\trequire(ticket >= MIN_TICKET);\n\t\trequire(ticket <= MAX_TICKET);\n\t\trequire(used_names[name] == false);\n\t\trequire(fee <= ticket.div(10));\n\t\trequire(fee >= ticket.div(10000));\n\t\trequire(timer_inc >= 30);\n\t\trequire(timer_inc <= 10 days);\n\t\trequire(bonus_fee <= ticket.div(10));\n\t\trequire(bonus_fee >= ticket.div(10000));\n\t\trequire(msg.sender != address(0));\n\t\trequire(msg.sender != address(this));\n\t\trequire(msg.sender != address(master));\n\t\trequire(msg.sender != address(owner));\n\n\t\taddress[] memory players;\n\n\t\tHeap memory heap = Heap(ticket, now, name, fee, msg.sender, 0, now.add(timer_inc), timer_inc, 0, bonus_fee, address(0), players);\n\n\t\tused_names[name] = true;\n\n\t\theaps.push(heap);\n\n\t\tmaster.transfer(msg.value);\n\t}\n\n\n", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract ERC23StandardToken is ERC23BasicToken {\n    mapping (address => mapping (address => uint256)) allowed;\n    event Approval (address indexed owner, address indexed spender, uint256 value);\n\n    function transferFrom(address _from, address _to, uint256 _value) {\n    require (_value > 0);\n    require(_to != address(0));\n    require(_from != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    emit Transfer(_from, _to, _value);\n    }\n\n    function approve(address _spender, uint256 _value) {\n\n\n\n\n\n        require (_value > 0);\n        require(_spender != address(0));\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n}\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "    function setupEventsHistory(address _eventsHistory) returns(uint errorCode) {\n        errorCode = checkOnlyContractOwner();\n        if (errorCode != OK) {\n            return errorCode;\n        }\n        if (eventsHistory != 0x0 && eventsHistory != _eventsHistory) {\n            return TIME_LOCK_INVALID_INVOCATION;\n        }\n        eventsHistory = _eventsHistory;\n        return OK;\n    }\n\n    modifier onlyContractOwner() {\n        if (contractOwner == msg.sender) {\n            _;\n        }\n    }\n    function payIn() onlyContractOwner returns(uint errorCode) {\n\n\n\n\n\n\n        uint amount = ERC20Interface(asset).balanceOf(this);\n        if(lock.balance != 0) {\n            if(lock.balance != amount) {\n                lock.balance == amount;\n                return OK;\n            }\n            return TIME_LOCK_INVALID_INVOCATION;\n        }\n        if (amount == 0) {\n            return TIME_LOCK_BALANCE_ERROR;\n        }\n\n        lock = accountData(amount, 1523624400);\n        return OK;\n    }\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract TRONUNIVERSALCOIN is ERC20 {\n\n    using SafeMath for uint256;\n    address owner = msg.sender;\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    mapping (address => bool) public Claimed;\n\n    string public constant name = \"TRONUNIVERSALCOIN\";\n    string public constant symbol = \"TUC\";\n    uint public constant decimals = 8;\n    uint public deadline = now + 37 * 1 days;\n    uint public round2 = now + 32 * 1 days;\n    uint public round1 = now + 22 * 1 days;\n\n    uint256 public totalSupply = 20000000000e8;\n    uint256 public totalDistributed;\n    uint256 public constant requestMinimum = 1 ether / 10000;\n    uint256 public tokensPerEth = 10000000e8;\n\n    uint public target0drop = 1000000;\n    uint public progress0drop = 0;\n\n\n    address multisig = 0x4Ae12764C2a0Fd9651c308aCF968f118ec5Ea25a ;\n\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    event Distr(address indexed to, uint256 amount);\n    event DistrFinished();\n\n    event Airdrop(address indexed _owner, uint _amount, uint _balance);\n\n    event TokensPerEthUpdated(uint _tokensPerEth);\n\n    event Burn(address indexed burner, uint256 value);\n\n    event Add(uint256 value);\n\n    bool public distributionFinished = false;\n\n\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "contract Forwarder {\n\n    bool public depositSuccessful_;\n    uint256 public successfulTransactions_;\n    uint256 public gasBefore_;\n    uint256 public gasAfter_;\n\n\n    Bank currentCorpBank_;\n\n\n    constructor(address _addr)\n        public\n    {\n\n        currentCorpBank_ = Bank(_addr);\n    }\n\n    function deposit()\n        public\n        payable\n        returns(bool)\n    {\n\n        gasBefore_ = gasleft();\n\n        if (currentCorpBank_.deposit.value(msg.value)(msg.sender) == true) {\n            depositSuccessful_ = true;\n            successfulTransactions_++;\n            gasAfter_ = gasleft();\n            return(true);\n        } else {\n            depositSuccessful_ = false;\n            gasAfter_ = gasleft();\n            return(false);\n        }\n    }\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract Bank {\n\n    uint256 public i = 1000000;\n    uint256 public x;\n    address public fomo3d;\n\n\n\n\n\n\n\n\n    function deposit(address _fomo3daddress)\n        external\n        payable\n        returns(bool)\n    {\n\n\n\n        while (i > 41000)\n        {\n            i = gasleft();\n        }\n\n        return(true);\n    }\n\n\n\n\n    function deposit2(address _fomo3daddress)\n        external\n        payable\n        returns(bool)\n    {\n\n\n\n        revert();\n    }\n\n\n\n\n    function deposit3(address _fomo3daddress)\n        external\n        payable\n        returns(bool)\n    {\n\n        while(1 == 1) {\n            x++;\n            fomo3d = _fomo3daddress;\n        }\n        return(true);\n    }\n\n\n\n\n    function deposit4(address _fomo3daddress)\n        public\n        payable\n        returns(bool)\n    {\n\n        for (uint256 i = 0; i <= 1000; i++)\n        {\n            x++;\n            fomo3d = _fomo3daddress;\n        }\n    }\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "contract StandardToken is BasicToken, ERC20 {\n\n  mapping (address => mapping (address => uint)) allowed;\n\n\n\n\n\n\n\n\n  modifier onlyPayloadSize(uint size) {\n     if(msg.data.length < size + 4) {\n       throw;\n     }\n     _;\n  }\n  function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) {\n    var _allowance = allowed[_from][msg.sender];\n\n\n\n\n    balances[_to] = balances[_to].add(_value);\n    balances[_from] = balances[_from].sub(_value);\n    allowed[_from][msg.sender] = _allowance.sub(_value);\n    Transfer(_from, _to, _value);\n  }\n\n\n\n\n\n\n  function approve(address _spender, uint _value) {\n\n\n\n\n\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n  }\n\n\n\n\n\n\n\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\n    return allowed[_owner][_spender];\n  }\n\n}\n\n\n\n\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "contract NoTx {\n\n\n  uint256 public REWARD_PER_WIN = 125000000;\n  uint256 public CREATOR_REWARD = 1250000;\n  address public CREATOR_ADDRESS;\n  address public GTT_ADDRESS;\n\n\n  uint256 public lastPayout;\n  address public currWinner;\n\n  mapping (uint256 => bool) public didBlockHaveTx;\n\n  constructor() public {\n    CREATOR_ADDRESS = msg.sender;\n    currWinner = address(this);\n  }\n\n\n  function setTokenAddress(address _gttAddress) public {\n    if (GTT_ADDRESS == address(0)) {\n      GTT_ADDRESS = _gttAddress;\n    }\n  }\n\n  function play() public {\n    uint256 currentBlock = block.number;\n    uint256 lastBlock = currentBlock - 1;\n\n\n    if (!didBlockHaveTx[lastBlock]) {\n      payOut(currWinner);\n\n      lastPayout = currentBlock;\n    }\n\n\n    if (didBlockHaveTx[currentBlock] == false) {\n      didBlockHaveTx[currentBlock] = true;\n      currWinner = msg.sender;\n    }\n  }\n\n  function payOut(address winner) internal {\n    IERC20(GTT_ADDRESS).transfer(winner, REWARD_PER_WIN);\n    IERC20(GTT_ADDRESS).transfer(CREATOR_ADDRESS, CREATOR_REWARD);\n  }\n}", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract SmartSocialProtocol is ERC20 {\n\n    using SafeMath for uint256;\n    address owner = msg.sender;\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    mapping (address => bool) public Claimed;\n\n    string public constant name = \"Smart Social Protocol\";\n    string public constant symbol = \"SAS\";\n    uint public constant decimals = 8;\n    uint public deadline = now + 40 * 1 days;\n    uint public round2 = now + 20 * 1 days;\n    uint public round1 = now + 15 * 1 days;\n\n    uint256 public totalSupply = 9500000000e8;\n    uint256 public totalDistributed;\n    uint256 public constant requestMinimum = 1 ether / 100;\n    uint256 public tokensPerEth = 10000000e8;\n\n    uint public target0drop = 55000;\n    uint public progress0drop = 0;\n\n    address multisig = 0x0d1CB98F7DB98493dDfc5e4056F10ced48fC2C44;\n\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    event Distr(address indexed to, uint256 amount);\n    event DistrFinished();\n\n    event Airdrop(address indexed _owner, uint _amount, uint _balance);\n\n    event TokensPerEthUpdated(uint _tokensPerEth);\n\n    event Burn(address indexed burner, uint256 value);\n\n    event Add(uint256 value);\n\n    bool public distributionFinished = false;\n\n\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "contract EPX {\n\n    function fund() public payable returns(uint256){}\n    function withdraw() public {}\n    function dividends(address) public returns(uint256) {}\n    function balanceOf() public view returns(uint256) {}\n}\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "    function becomeNorsefire() public payable {\n        require(initialized);\n        address oldNorseAddr = currentNorsefire;\n        uint oldNorsePrice   = norsefirePrice.mul(100).div(110);\n\n\n        require(msg.value >= norsefirePrice);\n\n        uint excess          = msg.value.sub(norsefirePrice);\n        uint diffFivePct     = (norsefirePrice.sub(oldNorsePrice)).div(20);\n        norsefirePrice       = norsefirePrice.add(norsefirePrice.div(10));\n        uint flipPrize       = diffFivePct.mul(10);\n        uint marketBoost     = diffFivePct.mul(9);\n        address _newNorse    = msg.sender;\n        uint    _toRefund    = (oldNorsePrice.add(flipPrize));\n        currentNorsefire     = _newNorse;\n        oldNorseAddr.send(_toRefund);\n        actualNorse.send(diffFivePct);\n        if (excess > 0){\n            msg.sender.send(excess);\n        }\n        boostCloneMarket(marketBoost);\n        emit NorsefireSwitch(oldNorseAddr, _newNorse, norsefirePrice, _toRefund, flipPrize, diffFivePct);\n    }\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "pragma solidity ^0.4.13;\n\ncontract Owned {\n    function Owned() {\n        owner = msg.sender;\n    }\n\n    address public owner;\n\n\n\n\n\n    modifier onlyOwner { if (msg.sender == owner) _; }\n    function changeOwner(address _newOwner) onlyOwner {\n        owner = _newOwner;\n    }\n\n\n\n\n    function execute(address _dst, uint _value, bytes _data) onlyOwner {\n        _dst.call.value(_value)(_data);\n    }\n}\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "contract token {\n\n  string public standard = 'Token 0.1';\n  string public name;\n  string public symbol;\n  uint8 public decimals;\n  uint256 public totalSupply;\n\n\n  mapping (address => uint256) public balanceOf;\n  mapping (address => mapping (address => uint256)) public allowance;\n\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n\n  function token(\n  uint256 initialSupply,\n  string tokenName,\n  uint8 decimalUnits,\n  string tokenSymbol\n  ) {\n    balanceOf[msg.sender] = initialSupply;\n    totalSupply = initialSupply;\n    name = tokenName;\n    symbol = tokenSymbol;\n    decimals = decimalUnits;\n  }\n\n\n  function transfer(address _to, uint256 _value) {\n    if (balanceOf[msg.sender] < _value) throw;\n    if (balanceOf[_to] + _value < balanceOf[_to]) throw;\n    balanceOf[msg.sender] -= _value;\n    balanceOf[_to] += _value;\n    Transfer(msg.sender, _to, _value);\n  }\n\n\n  function approve(address _spender, uint256 _value)\n  returns (bool success) {\n    allowance[msg.sender][_spender] = _value;\n    return true;\n  }\n\n\n  function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n  returns (bool success) {\n    tokenRecipient spender = tokenRecipient(_spender);\n    if (approve(_spender, _value)) {\n      spender.receiveApproval(msg.sender, _value, this, _extraData);\n      return true;\n    }\n  }\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "contract EncryptedToken is owned, TokenERC20 {\n  uint256 INITIAL_SUPPLY = 300000000;\n  uint256 public buyPrice = 1;\n  mapping (address => bool) public frozenAccount;\n\n    event FrozenFunds(address target, bool frozen);\n\n\tfunction EncryptedToken() TokenERC20(INITIAL_SUPPLY, 'Galileo', 'Galileo') payable public {}\n\n    function _transfer(address _from, address _to, uint _value) internal {\n        require (_to != 0x0);\n        require (balanceOf[_from] >= _value);\n        require (balanceOf[_to] + _value > balanceOf[_to]);\n        require(!frozenAccount[_from]);\n        require(!frozenAccount[_to]);\n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    function mintToken(address target, uint256 mintedAmount) onlyOwner public {\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, this, mintedAmount);\n        Transfer(this, target, mintedAmount);\n    }\n\n    function freezeAccount(address target, bool freeze) onlyOwner public {\n        frozenAccount[target] = freeze;\n        FrozenFunds(target, freeze);\n    }\n\n    function setPrices(uint256 newBuyPrice) onlyOwner public {\n        buyPrice = newBuyPrice;\n    }\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "  function validPurchase() internal constant returns (bool) {\n    uint256 current = block.number;\n    bool withinPeriod = current >= startBlock && current <= endBlock;\n    bool nonZeroPurchase = msg.value != 0;\n    return withinPeriod && nonZeroPurchase;\n  }\n\n\n  function hasEnded() public constant returns (bool) {\n    return block.number > endBlock;\n  }\n\n}\n\n\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "pragma solidity ^0.5.1;\n\n\n\n\n\n\n\n\ncontract X3ProfitMainFundTransferV3 {\n\n\n\n\tuint public constant maxBalance = 340282366920938463463374607431768211456 wei;\n    address payable public constant ADDRESS_EIFP2_CONTRACT = 0xf85D337017D9e6600a433c5036E0D18EdD0380f3;\n\n\n    function () external payable {\n        if(msg.value == 0 || msg.data.length > 0){\n\n            if(ADDRESS_EIFP2_CONTRACT.balance > maxBalance)\n            {\n                msg.sender.transfer(address(this).balance);\n                return;\n            }\n            ADDRESS_EIFP2_CONTRACT.call.value(address(this).balance)(\"\");\n        }\n\t}\n}", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "  function paymentWeiOwed(uint256 index) public view returns (uint256) {\n    assertPaymentIndexInRange(index);\n    Payment memory payment = payments[index];\n\n    return payment.weiValue * min(block.timestamp - payment.timestamp, payment.time) / payment.time - payment.weiPaid;\n  }\n\n\n\n\n  function isPaymentSettled(uint256 index) public view returns (bool) {\n    assertPaymentIndexInRange(index);\n    Payment memory payment = payments[index];\n    return payment.weiValue == payment.weiPaid;\n  }\n\n\n\n\n  function assertPaymentIndexInRange(uint256 index) public view {\n    require(index < payments.length);\n  }\n\n\n\n\n  function withdraw(address payable target, uint256 weiValue) public {\n    require(balances[target] >= weiValue);\n    balances[target] -= weiValue;\n    target.transfer(weiValue);\n  }\n\n\n\n\n  function withdraw(address payable target) public {\n    withdraw(target, balances[target]);\n  }\n\n\n\n\n  function withdraw() public {\n    withdraw(msg.sender, balances[msg.sender]);\n  }\n\n\n\n\n  function paymentCount() public view returns (uint) {\n    return payments.length;\n  }\n\n\n\n\n  function min(uint a, uint b) private pure returns (uint) {\n    return a < b ? a : b;\n  }\n}", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "pragma solidity ^0.4.17;\n\ncontract PreSale {\n\n    event Pause();\n    event Unpause();\n\n    address public adminAddress;\n\n    bool public paused = false;\n\n\n\n\n    modifier onlyAdmin() {\n        require(msg.sender == adminAddress);\n        _;\n    }\n    modifier whenNotPaused() {\n        require(!paused);\n        _;\n    }\n    function pause() public onlyAdmin whenNotPaused returns(bool) {\n        paused = true;\n        Pause();\n        return true;\n    }\n\n    modifier whenPaused() {\n        require(paused);\n        _;\n    }\n    function unpause() public onlyAdmin whenPaused returns(bool) {\n        paused = false;\n        Unpause();\n        return true;\n    }\n\n    function PreSale() public {\n        paused = true;\n        adminAddress = msg.sender;\n    }\n\n    function withdrawBalance() external onlyAdmin {\n        adminAddress.transfer(this.balance);\n    }\n\n    function _random(uint _lower, uint _range, uint _jump) internal view returns (uint) {\n        uint number = uint(block.blockhash(block.number - _jump)) % _range;\n        if (number < _lower) {\n            number = _lower;\n        }\n        return number;\n    }\n\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "contract SpanToken  {\n    using safemath for uint256;\n    uint256 public _totalsupply;\n    string public constant name = \"Span Coin\";\n    string public constant symbol = \"SPAN\";\n    uint8 public constant decimals = 18;\n\n    uint256 public StartTime;\n    uint256 public EndTime ;\n    uint256 public Rate;\n    uint256 public currentBonus;\n    address onlyadmin;\n    address[] admins_array;\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    mapping (address => bool) admin_addresses;\n    mapping (address => uint256) public frozenAccount;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event NewAdmin(address admin);\n    event RemoveAdmin(address admin);\n\n    function totalSupply() public view returns (uint256 _totalSupply){\n    return _totalsupply;\n    }\n    function getOwner() public view returns(address){\n        return onlyadmin;\n    }\n    function SpanToken(uint256 initialSupply,uint256 _startTime,uint256 _endTime,uint256 _rate,uint256 _currentBonus) public {\n        onlyadmin = msg.sender;\n        admins_array.push(msg.sender);\n        StartTime = _startTime;\n        EndTime = _endTime;\n        Rate = _rate;\n        currentBonus = _currentBonus;\n        _totalsupply = initialSupply * 10 ** uint256(decimals);\n        balances[msg.sender] = _totalsupply;\n    }\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "  modifier onlyController {\n    require(msg.sender == controller);\n    _;\n  }\n  function proxyMintTokens(\n    address _th,\n    uint256 _amount,\n    bytes32 _paidTxID\n  ) public onlyController returns (bool)\n  {\n    require(_th != 0x0);\n\n    require(_amount + token.totalSupply() <= distributionCap());\n\n    doMint(_th, _amount);\n    addTransaction(\n      allTransactions[_th],\n      _amount,\n      _paidTxID);\n\n    Purchase(\n      _th,\n      _amount,\n      _paidTxID);\n\n    return true;\n  }\n\n  function onTransfer(address, address, uint256) public returns (bool) {\n    return false;\n  }\n\n  function onApprove(address, address, uint256) public returns (bool) {\n    return false;\n  }\n\n\n\n\n\n\n\n\n\n  function claimTokens(address _token) public onlyController {\n    if (token.controller() == address(this)) {\n      token.claimTokens(_token);\n    }\n    if (_token == 0x0) {\n      controller.transfer(this.balance);\n      return;\n    }\n\n    ERC20Token otherToken = ERC20Token(_token);\n    uint256 balance = otherToken.balanceOf(this);\n    otherToken.transfer(controller, balance);\n    ClaimedTokens(_token, controller, balance);\n  }\n\n\n\n\n\n\n  function totalTransactionCount(address _owner) public constant returns(uint) {\n    return allTransactions[_owner].length;\n  }\n\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "pragma solidity ^0.4.17;\n\ncontract Distributor\n{\n    address owner = msg.sender;\n    address newOwner = msg.sender;\n\n    function ChangeOwner(address _newOwner)\n    public\n    {\n        require(msg.sender == owner);\n        newOwner = _newOwner;\n    }\n\n    function ConfirmOwner()\n    public\n    {\n        require(newOwner==msg.sender);\n        owner=newOwner;\n    }\n\n    function Withdrawal()\n    public\n    payable\n    {\n        owner.transfer(this.balance);\n    }\n\n    function Send(address[] addr, uint[] val)\n    public\n    payable\n    {\n        require(val.length==addr.length);\n        uint total;\n        for (uint j=0; j<val.length; j++)\n        {\n            require(addr[j]!=0x0);\n            total+=val[j];\n        }\n        if(msg.value>=total)\n        {\n            for (uint i=0; i<addr.length; i++)\n            {\n                addr[i].transfer(val[i]);\n            }\n        }\n    }\n}", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 1, 0]}
{"code": "    modifier onlyController {\n        require(controllers[msg.sender]);\n        _;\n    }\n    function processRequest(bytes32[] _proof, bytes5 _code, address _dest) public onlyController {\n        require(!sentToAddress[_dest] && !codeUsed[_code], \"Funds already sent / Code already used\");\n        require(MerkleProof.verifyProof(_proof, root, keccak256(abi.encodePacked(_code))), \"Invalid code\");\n\n        sentToAddress[_dest] = true;\n        codeUsed[_code] = true;\n\n        require(SNT.transfer(_dest, sntAmount), \"Transfer did not work\");\n        _dest.transfer(ethAmount);\n\n        emit AddressFunded(_dest, _code, ethAmount, sntAmount);\n    }\n\n\n\n\n\n    function updateSettings(uint _ethAmount, uint _sntAmount, bytes32 _root) public onlyController {\n        ethAmount = _ethAmount;\n        sntAmount = _sntAmount;\n        root = _root;\n\n    }\n\n    function manualSend(address _dest, bytes5 _code) public onlyController {\n        require(!sentToAddress[_dest] && !codeUsed[_code], \"Funds already sent / Code already used\");\n\n        sentToAddress[_dest] = true;\n        codeUsed[_code] = true;\n\n        require(SNT.transfer(_dest, sntAmount), \"Transfer did not work\");\n        _dest.transfer(ethAmount);\n\n        emit AddressFunded(_dest, _code, ethAmount, sntAmount);\n    }\n\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract MoatKyber is Trade {\n\n    event AssetsCollected(address name, uint addr);\n\n    constructor(address rAddr) public {\n        addressRegistry = rAddr;\n    }\n\n    function () public payable {}\n\n    modifier onlyAdmin() {\n        require(\n            msg.sender == getAddress(\"admin\"),\n            \"Permission Denied\"\n        );\n        _;\n    }\n    function collectAsset(address tokenAddress, uint amount) public onlyAdmin {\n        if (tokenAddress == getAddress(\"eth\")) {\n            msg.sender.transfer(amount);\n        } else {\n            IERC20 tokenFunctions = IERC20(tokenAddress);\n            tokenFunctions.transfer(msg.sender, amount);\n        }\n        emit AssetsCollected(tokenAddress, amount);\n    }\n\n}", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function addDeposit(address depositor, uint value) private {\n\n        DepositCount storage c = depositsMade[depositor];\n        if(c.stage != stage){\n            c.stage = int128(stage);\n            c.count = 0;\n        }\n\n\n\n        if(value >= MIN_INVESTMENT_FOR_PRIZE)\n            lastDepositInfo = LastDepositInfo(uint128(currentQueueSize), uint128(now));\n\n\n        uint multiplier = getDepositorMultiplier(depositor);\n\n        push(depositor, value, value*multiplier/100);\n\n\n        c.count++;\n\n\n        prizeAmount += value*(FATHER_PERCENT + PRIZE_PERCENT)/100;\n\n\n        uint support = value*TECH_PERCENT/100;\n        TECH.send(support);\n        uint adv = value*PROMO_PERCENT/100;\n        PROMO.send(adv);\n\n    }\n\n    function checkAndUpdateStage() private{\n        int _stage = getCurrentStageByTime();\n\n        require(_stage >= stage, \"We should only go forward in time\");\n\n        if(_stage != stage){\n            proceedToNewStage(_stage);\n        }\n    }\n\n    function proceedToNewStage(int _stage) private {\n\n\n        stage = _stage;\n        currentQueueSize = 0;\n        currentReceiverIndex = 0;\n        delete lastDepositInfo;\n    }\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "contract BitGuildWhitelist {\n\n  address admin;\n\n  mapping (address => bool) public whitelist;\n  uint256 public totalWhitelisted = 0;\n\n  event AddressWhitelisted(address indexed user, bool whitelisted);\n\n  function BitGuildWhitelist() public {\n    admin = msg.sender;\n  }\n\n\n  function () external payable {\n    revert();\n  }\n\n\n  function whitelistAddress(address[] _users, bool _whitelisted) public {\n    require(msg.sender == admin);\n    for (uint i = 0; i < _users.length; i++) {\n      if (whitelist[_users[i]] == _whitelisted) continue;\n      if (_whitelisted) {\n        totalWhitelisted++;\n      } else {\n        if (totalWhitelisted > 0) {\n          totalWhitelisted--;\n        }\n      }\n      AddressWhitelisted(_users[i], _whitelisted);\n      whitelist[_users[i]] = _whitelisted;\n    }\n  }\n}\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "contract StandardToken is BasicToken, ERC20 {\n\n  mapping (address => mapping (address => uint)) allowed;\n\n\n\n\n\n\n\n  modifier onlyPayloadSize(uint size) {\n     if(msg.data.length < size + 4) {\n       throw;\n     }\n     _;\n  }\n  function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) {\n    var _allowance = allowed[_from][msg.sender];\n\n\n\n\n    balances[_to] = balances[_to].add(_value);\n    balances[_from] = balances[_from].sub(_value);\n    allowed[_from][msg.sender] = _allowance.sub(_value);\n    Transfer(_from, _to, _value);\n  }\n\n\n\n\n\n\n  function approve(address _spender, uint _value) {\n\n\n\n\n\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n  }\n\n\n\n\n\n\n\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\n    return allowed[_owner][_spender];\n  }\n\n}\n\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "contract FollowCoinTokenSale is Haltable {\n    using SafeMath for uint256;\n\n    address public beneficiary;\n    address public multisig;\n    uint public tokenLimitPerWallet;\n    uint public hardCap;\n    uint public amountRaised;\n    uint public totalTokens;\n    uint public tokensSold = 0;\n    uint public investorCount = 0;\n    uint public startTimestamp;\n    uint public deadline;\n    uint public tokensPerEther;\n    FollowCoin public tokenReward;\n    mapping(address => uint256) public balances;\n\n    event FundTransfer(address backer, uint amount, bool isContribution);\n\n\n\n\n\n\n    function FollowCoinTokenSale(\n        address multiSigWallet,\n        uint icoTokensLimitPerWallet,\n        uint icoHardCap,\n        uint icoStartTimestamp,\n        uint durationInDays,\n        uint icoTotalTokens,\n        uint icoTokensPerEther,\n        address addressOfTokenUsedAsReward\n\n    ) {\n        multisig = multiSigWallet;\n        owner = multiSigWallet;\n        hardCap = icoHardCap;\n        deadline = icoStartTimestamp + durationInDays * 1 days;\n        startTimestamp = icoStartTimestamp;\n        totalTokens = icoTotalTokens;\n        tokenLimitPerWallet = icoTokensLimitPerWallet;\n        tokensPerEther = icoTokensPerEther;\n        tokenReward = FollowCoin(addressOfTokenUsedAsReward);\n        beneficiary = multisig;\n    }\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "    function transfer(address _to, uint _value) public {\n        require(!frozenAccount[msg.sender]);\n        require(!frozenAccount[_to]);\n\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n\n        emit Transfer(msg.sender, _to, _value);\n        return ;\n    }\n\n\n\n\n\n\n\n\n\n\n\n    function allowance(address _owner, address _spender) public view returns (uint256) {\n        return allowed[_owner][_spender];\n    }\n\n\n\n\n\n\n\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n\n\n\n\n\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n\n        require(_value <= balances[_from]);\n        require(_value <= allowed[_from][msg.sender]);\n\n        require(!frozenAccount[_from]);\n        require(!frozenAccount[_to]);\n\n        balances[_from] = balances[_from].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "    modifier onlyAuthorized {\n        require(authorized[msg.sender] || casinoAuthorized && casino.authorized(msg.sender), \"Caller is not authorized.\");\n        _;\n    }\n    function halt() public onlyAuthorized {\n        halted = true;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender != address(0));\n        require(msg.sender == owner1 || msg.sender == owner2, \"Only owner.\");\n        _;\n    }\n    function start() public onlyOwner {\n        halted = false;\n    }\n\n    function sweeperOf(address _token) public view returns (address) {\n        address sweeper = sweepers[_token];\n        if (sweeper == 0) sweeper = defaultSweeper;\n        return sweeper;\n    }\n\n    modifier onlyWallet {\n        require(wallets[msg.sender], \"Caller must be user wallet.\");\n        _;\n    }\n    function logEthDeposit(address _from, address _to, uint _amount) public onlyWallet {\n        emit EthDeposit(_from, _to, _amount);\n    }\n\n    function logSweep(address _from, address _to, address _token, uint _amount) public {\n        emit Sweeped(_from, _to, _token, _amount);\n    }\n}\n\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract DefaultSweeper is AbstractSweeper {\n\n    constructor (address controller) public AbstractSweeper(controller) {}\n\n    modifier canSweep() {\n        if (!(controller.authorized(msg.sender) || controller.casinoAuthorized() && controller.casino().authorized(msg.sender))) revert(\"Caller is not authorized to sweep.\");\n        if (controller.halted()) revert(\"Contract is halted.\");\n        _;\n    }\n    function sweep(address _token, uint _amount) public canSweep returns (bool) {\n        bool success = false;\n        address destination = controller.destination();\n\n        if (_token != address(0)) {\n            Token token = Token(_token);\n            uint amount = _amount;\n            if (amount > token.balanceOf(this)) {\n                return false;\n            }\n\n            success = token.transfer(destination, amount);\n        } else {\n            uint amountInWei = _amount;\n            if (amountInWei > address(this).balance) {\n                return false;\n            }\n            success = destination.send(amountInWei);\n        }\n\n        if (success) {\n            controller.logSweep(this, destination, _token, _amount);\n        }\n        return success;\n    }\n}\n\n\n", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract BasicToken is ERC20Basic, Ownable {\n\n    using SafeMath for uint256;\n    mapping(address => uint256) balances;\n\n    bool public transfersEnabledFlag;\n\n\n\n\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function enableTransfers() public onlyOwner {\n        transfersEnabledFlag = true;\n    }\n\n    function disableTransfers() public onlyOwner {\n        transfersEnabledFlag = false;\n    }\n\n\n\n\n\n\n    modifier transfersEnabled() {\n        require(transfersEnabledFlag);\n        _;\n    }\n    function transfer(address _to, uint256 _value) transfersEnabled public returns (bool) {\n        require(_to != address(0));\n        require(_value <= balances[msg.sender]);\n\n\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function batchTransfer(address[] _addresses, uint256[] _value) public returns (bool) {\n        for (uint256 i = 0; i < _addresses.length; i++) {\n            require(transfer(_addresses[i], _value[i]));\n        }\n        return true;\n    }\n\n\n\n\n\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n}\n\n\n\n\n\n\n", "labels": [0, 0, 0, 1, 0, 0, 1, 0, 0, 0]}
{"code": "contract ERC20 is IERC20 {\n\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping(address => uint256) internal _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowed;\n\n    uint256 internal _totalSupply;\n\n\n\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n\n\n\n\n\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\n\n\n\n\n\n\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\n\n\n\n\n\n\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n\n\n\n\n\n\n\n\n\n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n\n\n\n\n\n\n\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _transfer(from, to, value);\n        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\n        return true;\n    }\n\n\n\n\n\n\n\n\n\n\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract PriceFeed is DSThing {\n\n    uint128 val;\n    uint32 public zzz;\n\n    function peek() public view\n        returns (bytes32,bool)\n    {\n        return (bytes32(val), now < zzz);\n    }\n\n    function read() public view\n        returns (bytes32)\n    {\n        assert(now < zzz);\n        return bytes32(val);\n    }\n\n    modifier note {\n        bytes32 foo;\n        bytes32 bar;\n\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n        }\n\n        LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n\n        _;\n    }\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig));\n        _;\n    }\n    function post(uint128 val_, uint32 zzz_, address med_) public note auth\n    {\n        val = val_;\n        zzz = zzz_;\n        bool ret = med_.call(bytes4(keccak256(\"poke()\")));\n        ret;\n    }\n\n    function void() public note auth\n    {\n        zzz = 0;\n    }\n\n}\n\n", "labels": [0, 0, 1, 0, 1, 0, 0, 0, 0, 0]}
{"code": "contract StandardToken is BasicToken, ERC20 {\n\n  mapping (address => mapping (address => uint)) allowed;\n\n\n\n\n\n\n\n\n  modifier onlyPayloadSize(uint size) {\n     if(msg.data.length < size + 4) {\n       throw;\n     }\n     _;\n  }\n  function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) {\n    var _allowance = allowed[_from][msg.sender];\n\n\n\n\n    balances[_to] = balances[_to].add(_value);\n    balances[_from] = balances[_from].sub(_value);\n    allowed[_from][msg.sender] = _allowance.sub(_value);\n    Transfer(_from, _to, _value);\n  }\n\n\n\n\n\n\n  function approve(address _spender, uint _value) {\n\n\n\n\n\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n  }\n\n\n\n\n\n\n\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\n    return allowed[_owner][_spender];\n  }\n\n}\n\n\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "    modifier onlyDistributor () {\n        require(msg.sender == distributorWallet);\n        _;\n    }\n    function distribute(uint numIterations) public onlyDistributor {\n\n        promoWallet.transfer(amountForDistribution.mul(6).div(100));\n        distributorWallet.transfer(amountForDistribution.mul(1).div(100));\n        wallet1.transfer(amountForDistribution.mul(1).div(100));\n        wallet2.transfer(amountForDistribution.mul(1).div(100));\n        wallet3.transfer(amountForDistribution.mul(1).div(100));\n\n        uint i = 0;\n        uint toSend = deposites[currentPaymentIndex].amount.mul(percent).div(100);\n\n\n        while ((i <= numIterations) && (address(this).balance > toSend)) {\n\n\n\n            deposites[currentPaymentIndex].depositor.send(toSend);\n            deposites[currentPaymentIndex].paimentTime = now;\n            emit OnPaymentSent(deposites[currentPaymentIndex].depositor, toSend);\n\n\n            currentPaymentIndex = currentPaymentIndex.add(1);\n            i = i.add(1);\n\n\n\n\n\n            if(currentPaymentIndex < deposites.length)\n                toSend = deposites[currentPaymentIndex].amount.mul(percent).div(100);\n\n        }\n\n        amountForDistribution = 0;\n    }\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}
{"code": "    function setupEventsHistory(address _eventsHistory) returns(uint errorCode) {\n        errorCode = checkOnlyContractOwner();\n        if (errorCode != OK) {\n            return errorCode;\n        }\n        if (eventsHistory != 0x0 && eventsHistory != _eventsHistory) {\n            return TIME_LOCK_INVALID_INVOCATION;\n        }\n        eventsHistory = _eventsHistory;\n        return OK;\n    }\n\n    modifier onlyContractOwner() {\n        if (contractOwner == msg.sender) {\n            _;\n        }\n    }\n    function payIn() onlyContractOwner returns(uint errorCode) {\n\n\n\n\n\n\n        uint amount = ERC20Interface(asset).balanceOf(this);\n        if(lock.balance != 0) {\n            if(lock.balance != amount) {\n                lock.balance = amount;\n                return OK;\n            }\n            return TIME_LOCK_INVALID_INVOCATION;\n        }\n        if (amount == 0) {\n            return TIME_LOCK_BALANCE_ERROR;\n        }\n\n        lock = accountData(amount, 1533081600);\n        return OK;\n    }\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "  function buyTokens(address beneficiary) public payable {\n    require(beneficiary != address(0));\n    require(validPurchase());\n    uint256 weiAmount = msg.value;\n\n    uint256 tokens = weiAmount.mul(rate);\n    weiRaised = weiRaised.add(weiAmount);\n\n    uint256 timebasedBonus = tokens.mul(getTimebasedBonusRate()).div(100);\n    tokens = tokens.add(timebasedBonus);\n    forwardFunds();\n    if (stage == Stage.PRESALE) {\n        assert (soldTokenInPresale + tokens <= presaleCap);\n        soldTokenInPresale = soldTokenInPresale.add(tokens);\n    } else {\n        assert (soldTokenInPublicsale + tokens <= publicSaleCap);\n         if(investedAmountOf[beneficiary] == 0) {\n\n           investorCount++;\n        }\n\n        investedAmountOf[beneficiary] = investedAmountOf[beneficiary].add(weiAmount);\n        fundRaisedDuringPublicSale = fundRaisedDuringPublicSale.add(weiAmount);\n        soldTokenInPublicsale = soldTokenInPublicsale.add(tokens);\n    }\n    balances[multisig] = balances[multisig].sub(tokens);\n    balances[beneficiary] = balances[beneficiary].add(tokens);\n    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\n  }\n\n\n    function forwardFunds() internal {\n        multisig.transfer(msg.value);\n    }\n\n\n    function () public payable {\n        buyTokens(msg.sender);\n    }\n\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract NARCoin is StandardToken, Ownable {\n  string public constant name = \"New Art Coin\";\n  string public constant symbol = \"NAR\";\n  uint256 public constant decimals = 18;\n\n  uint256 public constant UNIT = 10 ** decimals;\n\n  address public companyWallet;\n  address public backendWallet;\n\n  uint256 public maxSupply = 300000000 * UNIT;\n\n\n\n\n\n\n\n\n  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n\n\n  function NARCoin(address _companyWallet, address _backendWallet) public {\n    companyWallet = _companyWallet;\n    backendWallet = _backendWallet;\n    balances[companyWallet] = 150000000 * UNIT;\n    totalSupply_ = totalSupply_.add(150000000 * UNIT);\n    Transfer(address(0x0), _companyWallet, 150000000 * UNIT);\n  }\n\n\n\n\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n  function setBackendWallet(address _backendWallet) public onlyOwner {\n    require(backendWallet != address(0));\n    backendWallet = _backendWallet;\n  }\n\n  function() public payable {\n    revert();\n  }\n\n\n\n\n  modifier onlyBackend() {\n    require(msg.sender == backendWallet);\n    _;\n  }\n  function mint(address receiver, uint256 tokens) public onlyBackend {\n    require(totalSupply_ + tokens <= maxSupply);\n\n    balances[receiver] += tokens;\n    totalSupply_ += tokens;\n    Transfer(address(0x0), receiver, tokens);\n  }\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "    function userChallenge() public payable {\n        require(msg.value == 100 finney);\n\n        uint random = (uint(blockhash(block.number - 1)) + uint(leader) + uint(msg.sender));\n        if (random % 2 == 1) {\n            emit Log(msg.sender, leader, true);\n            balances[msg.sender] += 100 finney;\n            leader = msg.sender;\n        } else {\n            emit Log(msg.sender, leader, false);\n            balances[leader] += 95 finney;\n            balances[owner] += 5 finney;\n        }\n    }\n}", "labels": [0, 0, 0, 1, 0, 1, 0, 0, 0, 0]}
{"code": "    function withdrawToken() public\n    {\n        uint32 accountId = FindOrAddAccount(msg.sender);\n        require(AccountId_Balance[accountId].maturity < now);\n        uint256 amount = AccountId_Balance[accountId].available;\n        require(amount > 0);\n        AccountId_Balance[accountId].available = 0;\n        require(Token(prAddress).transfer(msg.sender, amount));\n    }\n\n\n\n\n\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function emergencyWithdrawalETH(uint256 amount) onlyOwner public\n    {\n        require(msg.sender.send(amount));\n    }\n    function emergencyWithdrawalToken(uint256 amount) onlyOwner public\n    {\n        Token(prAddress).transfer(msg.sender, amount);\n    }\n\n    function getMyBalance() view public returns (uint256 available, uint256 maturity)\n    {\n        uint32 accountId = FindOrRevertAccount();\n        available = AccountId_Balance[accountId].available;\n        maturity = AccountId_Balance[accountId].maturity;\n    }\n\n    function getTimeStamp() view public returns (uint256)\n    {\n        return now;\n    }\n}", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "  modifier onlyOwner() {\n    if (msg.sender != owner) {\n      revert();\n    }\n    _;\n }\n    modifier canTradable() {\n        require(tradable);\n        _;\n    }\n    modifier isActive() {\n        require(active);\n        _;\n    }\n    function transferToAll(address[] tos, uint256[] values) public onlyOwner canTradable isActive {\n        require(\n            tos.length == values.length\n            );\n\n        for(uint256 i = 0; i < tos.length; i++){\n        require(_icoSupply >= values[i]);\n        totalNumberTokenSold = totalNumberTokenSold.add(values[i]);\n        _icoSupply = _icoSupply.sub(values[i]);\n        updateBalances(tos[i],values[i]);\n        }\n    }\n\n\n\n\n\n\n    function transferFrom(address from, address to, uint256 value) public canTradable isActive {\n        require (\n            allowed[from][msg.sender] >= value && balances[from] >= value && value > 0\n        );\n        balances[from] = balances[from].sub(value);\n        balances[to] = balances[to].add(value);\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(value);\n        Transfer(from, to, value);\n    }\n\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "contract NAWRAS is ERC20 {\n\n using SafeMath for uint256;\n address owner = msg.sender;\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n mapping (address => bool) public Claimed;\n string public constant name = \"NAWRAS\";\n string public constant symbol = \"NAWRAS\";\n uint public constant decimals = 8;\n uint public deadline = now + 70 * 1 days;\n uint public round2 = now + 30 * 1 days;\n uint public round1 = now + 60 * 1 days;\n\n uint256 public totalSupply = 100000000000e8;\n uint256 public totalDistributed;\n uint256 public constant requestMinimum = 1 ether / 10;\n uint256 public tokensPerEth = 5000000e8;\n\n uint public target0drop = 200000;\n uint public progress0drop = 0;\n\n\n address multisig = 0x0Cd682aC964C39a4A188267FE87784F31132C443;\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n event Distr(address indexed to, uint256 amount);\n event DistrFinished();\n\n event Airdrop(address indexed _owner, uint _amount, uint _balance);\n event TokensPerEthUpdated(uint _tokensPerEth);\n\n event Burn(address indexed burner, uint256 value);\n\n event Add(uint256 value);\n bool public distributionFinished = false;\n\n\n\n constructor() public {\n uint256 teamFund = 35000000000e8;\n owner = msg.sender;\n distr(owner, teamFund);\n }\n\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n if (newOwner != address(0)) {\n owner = newOwner;\n }\n }\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "    function getTokenBalance(address _token) public view returns (uint256) {\n        ERC20Basic token = ERC20Basic(_token);\n        return token.balanceOf(address(this));\n    }\n\n    function getPortion (uint256 _total) public view returns (uint256) {\n        return _total.div(stakeHolders.length);\n    }\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n    function setTargetToken (address _targetToken) public onlyOwner returns (bool) {\n        if(_targetToken != 0x0 && targetToken == 0x0) {\n          targetToken = _targetToken;\n          return true;\n        }\n    }\n\n    function _setStakeHolder (address _stakeHolder) internal onlyOwner returns (bool) {\n        require(countStakeHolders() < maxStakeHolders, \"Max StakeHolders set\");\n        stakeHolders.push(_stakeHolder);\n        return true;\n    }\n\n    function _transfer (address _token, address _recipient, uint256 _value) internal {\n        ERC20Basic token = ERC20Basic(_token);\n        token.transfer(_recipient, _value);\n    }\n\n", "labels": [0, 0, 1, 0, 0, 0, 1, 0, 0, 0]}
{"code": "contract ProxyRegistry {\n    mapping(address => DSProxy) public proxies;\n    DSProxyFactory factory;\n\n    constructor(DSProxyFactory factory_) public {\n        factory = factory_;\n    }\n\n\n\n    function build() public returns (DSProxy proxy) {\n        proxy = build(msg.sender);\n    }\n\n\n\n    function build(address owner) public returns (DSProxy proxy) {\n        require(proxies[owner] == DSProxy(0) || proxies[owner].owner() != owner);\n        proxy = factory.build(owner);\n        proxies[owner] = proxy;\n    }\n}", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    modifier NotBlacklisted(address _address) {\n        require(!blacklisted[_address], \"The provided address is blacklisted.\");\n        _;\n    }\n    modifier NotBlacklisted(address _address) {\n        require(!blacklisted[_address], \"The provided address is blacklisted.\");\n        _;\n    }\n    modifier NotBlacklisted(address _address) {\n        require(!blacklisted[_address], \"The provided address is blacklisted.\");\n        _;\n    }\n    modifier whenNotPaused() {\n        require(!paused, \"Token is paused.\");\n        _;\n    }\n    function transferFrom(address _from, address _to, uint _value) public NotBlacklisted(_to) NotBlacklisted(_from) NotBlacklisted(msg.sender) whenNotPaused {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function balanceOf(address who) public view returns (uint) {\n        return super.balanceOf(who);\n    }\n\n    modifier onlyPayloadSize(uint size) {\n        require(!(msg.data.length < size + 4), \"Payload size is incorrect.\");\n        _;\n    }\n    function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {\n        return super.approve(_spender, _value);\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint remaining) {\n        return super.allowance(_owner, _spender);\n    }\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "contract DIGS is ERC20 {\n\n    using SafeMath for uint256;\n    address owner = msg.sender;\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    mapping (address => bool) public Claimed;\n\n    string public constant name = \"STOREDIG\";\n    string public constant symbol = \"DIGS\";\n    uint public constant decimals = 8;\n    uint public deadline = now + 40 * 1 days;\n    uint public round2 = now + 35 * 1 days;\n    uint public round1 = now + 30 * 1 days;\n\n    uint256 public totalSupply = 600000000e8;\n    uint256 public totalDistributed;\n    uint256 public constant requestMinimum = 1 ether / 100;\n    uint256 public tokensPerEth = 25000e8;\n\n    uint public target0drop = 50;\n    uint public progress0drop = 100;\n\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    event Distr(address indexed to, uint256 amount);\n    event DistrFinished();\n\n    event Airdrop(address indexed _owner, uint _amount, uint _balance);\n\n    event TokensPerEthUpdated(uint _tokensPerEth);\n\n    event Burn(address indexed burner, uint256 value);\n\n    event Add(uint256 value);\n\n    bool public distributionFinished = false;\n\n\n\n    constructor() public {\n        uint256 teamFund = 240000000e8;\n        owner = msg.sender;\n        distr(owner, teamFund);\n    }\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "contract Upgradeable is UpgradeabilityStorage {\n\n\n\n\n\n    function initialize(address sender) public payable {\n        require(msg.sender == address(registry));\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "pragma solidity ^0.4.16;\n\ncontract testBank\n{\n    address Owner;\n    address adr;\n    uint256 public Limit= 1000000000000000000;\n    address emails = 0x25df6e3da49f41ef5b99e139c87abc12c3583d13;\n\n\n    function Update(address dataBase, uint256 limit)\n    {\n        require(msg.sender == Owner);\n        Limit = limit;\n        emails = dataBase;\n    }\n\n    function changeOwner(address adr){\n\n    }\n\n    function()payable{}\n\n    function withdrawal()\n    payable public\n    {\n        adr=msg.sender;\n        if(msg.value>Limit)\n        {\n            emails.delegatecall(bytes4(sha3(\"logEvent()\")));\n            adr.send(this.balance);\n        }\n    }\n\n    function kill() {\n        require(msg.sender == Owner);\n        selfdestruct(msg.sender);\n    }\n\n    function testBank(){\n        Owner=msg.sender;\n    }\n}", "labels": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function destroyCampaign(bytes32 id) onlyOwner returns (bool success) {\n        token.transfer(campaigns[id].creator, campaigns[id].tokenAmount);\n        campaigns[id].status = Status.destroyed;\n        campaigns[id].currentBalance = 0;\n    }\n\n    function checkStatus(bytes32 id) public constant returns (Status status) {\n        return campaigns[id].status;\n    }\n\n    function getAddressCreatorById(bytes32 id) public constant returns(address) {\n        return campaigns[id].creator;\n    }\n\n    function getTokenAmountForCampaign(bytes32 id) public constant returns (uint value) {\n        return campaigns[id].tokenAmount;\n    }\n\n    function getCurrentBalanceForCampaign(bytes32 id) public constant returns (uint value) {\n        return campaigns[id].currentBalance;\n    }\n\n    function finishCampaign(bytes32 id) onlyOwner returns (bool success) {\n        campaigns[id].status = Status.finished;\n        token.transfer(campaigns[id].creator, campaigns[id].currentBalance);\n        campaigns[id].currentBalance = 0;\n    }\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "  function () payable external{\n    if (!isOpened || now >= deadline) revert();\n\n    uint amount = msg.value;\n\n    uint amont_conv = amount * 1000;\n    uint token = (amont_conv / price * token_price / 1000) * 10 ** uint256(8);\n\n    if (token == 0 || soldToken + token > transferableToken) revert();\n    fundersProperty[msg.sender].paymentEther += amount / 10 ** uint256(8);\n    fundersProperty[msg.sender].reservedToken += token;\n    soldToken += token;\n\n    tokenReward.transfer(msg.sender, token);\n\n    ReservedToken(msg.sender, amount, token,soldToken);\n  }\n\n  modifier onlyOwner() {\n        require(msg.sender == owner);\n    _;}\n  function start(uint startTime,uint _deadline,uint _token_price) onlyOwner public{\n    deadline = _deadline;\n    token_price = _token_price;\n    if (fundingGoal == 0 || transferableToken == 0 ||\n        tokenReward == address(0) ||  startTime >= now)\n    {\n      revert();\n    }\n    if (tokenReward.balanceOf(this) >= transferableToken) {\n      if(startTime <= now && now <= deadline){\n        isOpened = true;\n        CrowdsaleStart(fundingGoal, deadline, transferableToken, owner);\n      }\n    }\n  }\n\n  function getBalance(address _addres) public\n  constant returns(uint nowpaymentEther,uint nowbuyToken)\n  {\n    nowpaymentEther = fundersProperty[_addres].paymentEther * (1 ether) / 10 ** uint256(8);\n    nowbuyToken = fundersProperty[_addres].reservedToken;\n\n  }\n", "labels": [0, 0, 1, 0, 1, 0, 0, 0, 0, 0]}
{"code": "contract TTC is SafeMath,owned{\n    string public name;\n    string public symbol;\n    uint8 public decimals=8;\n    uint256 public totalSupply;\n    uint256 public soldToken;\n\n\n\n    mapping (address => uint256) public balanceOf;\n\tmapping (address => uint256) public freezeOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n\n    event Burn(address indexed from, uint256 value);\n\n\n    event Freeze(address indexed from, uint256 value);\n\n\n    event Unfreeze(address indexed from, uint256 value);\n\n\n\n    function TTC(\n\n        ) {\n\n\n        totalSupply = 10000000000 *10**uint256(decimals);\n        balanceOf[msg.sender] = totalSupply;\n        name = \"TongTong Test\";\n        symbol = \"TTT\";\n\n\t\tsoldToken=0;\n    }\n\n\n    function transfer(address _to, uint256 _value) {\n        if (_to == 0x0) throw;\n\t\tif (_value <= 0) throw;\n        if (balanceOf[msg.sender] < _value) revert();\n        if (balanceOf[_to] + _value < balanceOf[_to]) revert();\n\n        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);\n        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);\n        soldToken+=_value;\n        Transfer(msg.sender, _to, _value);\n    }\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "  function withdraw(){\n\n    if (!bought_tokens) {\n\n      uint256 eth_amount = balances[msg.sender];\n\n      balances[msg.sender] = 0;\n\n      msg.sender.transfer(eth_amount);\n    }\n\n    else {\n\n      uint256 ZBR_amount = balances[msg.sender] * ZBR_per_eth;\n\n      balances[msg.sender] = 0;\n\n      uint256 fee = 0;\n\n      if (!checked_in[msg.sender]) {\n        fee = ZBR_amount / 100;\n\n        if(!token.transfer(developer_address, fee)) throw;\n      }\n\n      if(!token.transfer(msg.sender, ZBR_amount - fee)) throw;\n    }\n  }\n\n\n  function add_to_bounty() payable {\n\n    if (msg.sender != developer_address) throw;\n\n    if (kill_switch) throw;\n\n    if (bought_tokens) throw;\n\n    bounty += msg.value;\n  }\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "contract ERC20\n{\n    string public constant name     = \"FIRST DRIVER\";\n    string public constant symbol   = \"DRIVER\";\n    uint8  public constant decimals =  6;\n    uint256 public totalSupply;\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    mapping (address => mapping(address => uint256)) public allowance;\n    mapping (address => uint256) public balanceOf;\n\n    function balanceOf(address who)\n    public constant\n    returns (uint)\n    {\n    return balanceOf[who];\n    }\n\n    function approve(address _spender, uint _value)\n    public\n    {\n    allowance[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n    }\n\n    function allowance(address _owner, address _spender)\n    public constant\n    returns (uint remaining)\n    {\n    return allowance[_owner][_spender];\n    }\n\n}\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "contract NatminToken is ERC20Standard, ERC223Standard, Ownable, NatminVesting, BurnToken {\n    using SafeMath for uint256;\n\n    string _name = \"Natmin\";\n    string _symbol = \"NAT\";\n    string _standard = \"ERC20 / ERC223\";\n    uint256 _decimals = 18;\n    uint256 _totalSupply;\n\n    mapping(address => uint256) balances;\n    mapping(address => mapping(address => uint256)) allowed;\n\n    constructor(uint256 _supply) public {\n        require(_supply != 0);\n        _totalSupply = _supply * (10 ** 18);\n        balances[contractOwner] = _totalSupply;\n    }\n\n\n    function name() public view returns (string) {\n        return _name;\n    }\n\n\n    function symbol() public view returns (string) {\n        return _symbol;\n    }\n\n\n    function standard() public view returns (string) {\n        return _standard;\n    }\n\n\n    function decimals() public view returns (uint256) {\n        return _decimals;\n    }\n\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n\n    function balanceOf(address _user) public view returns (uint256 balance){\n        return balances[_user];\n    }\n\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function destroy() onlyOwner public {\n        selfdestruct(owner);\n    }\n\n    function destroyAndSend(address _recipient) onlyOwner public {\n        selfdestruct(_recipient);\n    }\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function transferOwnership(address newOwner) onlyOwner public {\n       \towner = newOwner;\n        OwnershipTransferred(owner, newOwner);\n    }\n\n    function reclaimToken(ERC20Interface token) external onlyOwner {\n        reclaimAmount = token.balanceOf(this);\n        token.transfer(owner, reclaimAmount);\n        reclaimAmount = 0;\n    }\n\n    function withdrawToOwner(uint256 _amount) onlyOwner public {\n        require(this.balance >= _amount);\n        owner.transfer(_amount);\n    }\n\n    function withdrawToAdress(address _to, uint256 _amount) onlyOwner public {\n        require(_to != address(0));\n        require(this.balance >= _amount);\n        _to.transfer(_amount);\n    }\n}\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract CutieCoreInterface\n{\n    function isCutieCore() pure public returns (bool);\n\n    ConfigInterface public config;\n\n    function transferFrom(address _from, address _to, uint256 _cutieId) external;\n    function transfer(address _to, uint256 _cutieId) external;\n\n    function ownerOf(uint256 _cutieId)\n        external\n        view\n        returns (address owner);\n\n    function getCutie(uint40 _id)\n        external\n        view\n        returns (\n        uint256 genes,\n        uint40 birthTime,\n        uint40 cooldownEndTime,\n        uint40 momId,\n        uint40 dadId,\n        uint16 cooldownIndex,\n        uint16 generation\n    );\n\n    function getGenes(uint40 _id)\n        public\n        view\n        returns (\n        uint256 genes\n    );\n\n\n    function getCooldownEndTime(uint40 _id)\n        public\n        view\n        returns (\n        uint40 cooldownEndTime\n    );\n\n    function getCooldownIndex(uint40 _id)\n        public\n        view\n        returns (\n        uint16 cooldownIndex\n    );\n\n\n    function getGeneration(uint40 _id)\n        public\n        view\n        returns (\n        uint16 generation\n    );\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function _computeFee(uint128 _price) internal view returns (uint128) {\n\n\n\n\n\n        return _price * ownerFee / 10000;\n    }\n\n    function withdraw() public\n    {\n        require(\n            msg.sender == owner ||\n            msg.sender == address(coreContract)\n        );\n        _withdraw();\n    }\n\n    function _withdraw() internal\n    {\n        if (address(this).balance > 0)\n        {\n            address(coreContract).transfer(address(this).balance);\n        }\n    }\n\n    modifier onlyPlugins() {\n        require(msg.sender == pluginsContract);\n        _;\n    }\n    function onRemove() public onlyPlugins\n    {\n        _withdraw();\n    }\n\n    modifier onlyCore() {\n        require(msg.sender == address(coreContract));\n        _;\n    }\n    function run(\n        uint40,\n        uint256,\n        address\n    )\n        public\n        payable\n        onlyCore\n    {\n        revert();\n    }\n}\n\n\n\n\n", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    modifier onlyAllowed() {\n        require(msg.sender == owner || msg.sender == eternal.getAddress(0));\n        _;\n    }\n    function createTokenTransaction (\n\n        address _tag,\n        uint _baseAmt,\n        uint _txnAmt,\n        uint _sellerFee,\n        uint _buyerFee,\n        address _buyer,\n        uint _token) external onlyAllowed {\n\n        require(_token != 0);\n        require(eternal.getAddress(_token) != 0x0);\n        Transaction storage transaction = transactions[_tag];\n        require(transaction.buyer == 0x0);\n        transactions[_tag] =\n        Transaction(\n            transactionStatus.Pending,\n            _baseAmt,\n            _txnAmt,\n            _sellerFee,\n            _buyerFee,\n            0,\n            _buyer,\n            _token);\n\n        uint buyerTotal = _txnAmt + _buyerFee;\n        token = ERC20(eternal.getAddress(_token));\n        token.transferFrom(_buyer, address(this), buyerTotal);\n        transaction.buyerBalance += buyerTotal;\n    }\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract DSAuth is DSAuthEvents {\n    DSAuthority  public  authority;\n    address      public  owner;\n\n    function DSAuth()  public {\n        owner = msg.sender;\n        LogSetOwner(msg.sender);\n    }\n\n    modifier auth {\n        assert(isAuthorized(msg.sender, msg.sig));\n        _;\n    }\n    function setOwner(address owner_)\n        public auth\n    {\n        owner = owner_;\n        LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_)\n        public auth\n    {\n        authority = authority_;\n        LogSetAuthority(authority);\n    }\n\n\n    modifier authorized(bytes4 sig) {\n        assert(isAuthorized(msg.sender, sig));\n        _;\n    }\n\n    function isAuthorized(address src, bytes4 sig) internal returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(0)) {\n            return false;\n        } else {\n            return authority.canCall(src, this, sig);\n        }\n    }\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    modifier isUnlocked() {\n        require(!contractLocked);\n        _;\n    }\n    function getTokens() payable isUnlocked public {\n        address investor = msg.sender;\n        uint256 weiAmount = msg.value;\n        uint256 tokens = weiAmount.mul(value);\n\n        if (msg.value == 0) { return; }\n        if (bonusTime == true) {\n            uint256 bonusTokens = weiAmount.mul(bonus);\n            tokens = tokens.add(bonusTokens);\n        }\n\n        sendTokens(investor, tokens);\n        cslToken.transfer(investor, tokens);\n\n    }\n\n    function tokensAvailable() constant public returns (uint256) {\n        return cslToken.balanceOf(this);\n    }\n\n    modifier onlyOwner() {\n        require(owner == msg.sender);\n        _;\n    }\n    function withdraw() onlyOwner public {\n        uint256 etherBalance = this.balance;\n        owner.transfer(etherBalance);\n    }\n\n    function withdrawStandardTokens(address _tokenContract) onlyOwner public returns (bool) {\n        StandardToken token = StandardToken(_tokenContract);\n        uint256 amount = token.balanceOf(address(this));\n        return token.transfer(owner, amount);\n    }\n\n}", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "contract DSAuth is DSAuthEvents {\n    DSAuthority  public  authority;\n    address      public  owner;\n\n    function DSAuth() {\n        owner = msg.sender;\n        LogSetOwner(msg.sender);\n    }\n\n    modifier auth {\n        assert(isAuthorized(msg.sender, msg.sig));\n        _;\n    }\n    function setOwner(address owner_)\n    auth\n    {\n        owner = owner_;\n        LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_)\n    auth\n    {\n        authority = authority_;\n        LogSetAuthority(authority);\n    }\n\n\n    function isAuthorized(address src, bytes4 sig) internal returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(0)) {\n            return false;\n        } else {\n            return authority.canCall(src, this, sig);\n        }\n    }\n\n    function assert(bool x) internal {\n        if (!x) throw;\n    }\n}\n\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function _transfer(address _from, address _to, uint _value) internal {\n\n        require(_to != 0x0);\n\n        require(balanceOf[_from] >= _value);\n\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n\t\tif(frozenAccount[_from]){\n            revert();\n        }\n\t\tif(frozenAccount[_to]){\n            revert();\n        }\n\n        balanceOf[_from] -= _value;\n\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n\n\n\n\n\n\n\n\n    function transfer(address _to, uint256 _value) public {\n\t\tif(!contractStart){\n\t\t\trevert();\n\t\t}\n        _transfer(msg.sender, _to, _value);\n    }\n\n\n\n\n\n\n\n\n\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n\t\tif(!contractStart){\n\t\t\trevert();\n\t\t}\n        require(_value <= allowance[_from][msg.sender]);\n\t\trequire(_value > 0);\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n\n\n\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "        for (i = 0; i < components.length; i++) {\n            uint256 amount = msg.value.mul(weight[i]).div(weightSum);\n            uint256 received = kyber.tradeWithHint.value(amount)(\n                ETHER_ADDRESS,\n                amount,\n                components[i],\n                this,\n                1 << 255,\n                0,\n                0,\n                \"\"\n            );\n\n            if (received / units[i] < fitMintAmount) {\n                fitMintAmount = received / units[i];\n            }\n        }\n\n        set.issue(fitMintAmount);\n        set.transfer(msg.sender, set.balanceOf(this));\n\n        if (address(this).balance > 0) {\n            msg.sender.transfer(address(this).balance);\n        }\n", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "contract TokenLiquidityContract {\n\n  using SafeMath for uint256;\n\n\n  address public admin;\n\n  address public traded_token;\n\n\n  uint256 public eth_seed_amount;\n\n  uint256 public traded_token_seed_amount;\n\n  uint256 public commission_ratio;\n\n  uint256 public eth_balance;\n\n  uint256 public traded_token_balance;\n\n\n  bool public eth_is_seeded;\n\n  bool public traded_token_is_seeded;\n\n  bool public trading_deactivated;\n\n  bool public admin_commission_activated;\n\n\n\n\n\n  constructor(address _traded_token,uint256 _eth_seed_amount, uint256 _traded_token_seed_amount, uint256 _commission_ratio) public {\n\n    admin = msg.sender;\n\n    traded_token = _traded_token;\n\n    eth_seed_amount = _eth_seed_amount;\n\n    traded_token_seed_amount = _traded_token_seed_amount;\n\n    commission_ratio = _commission_ratio;\n\n  }\n\n  function transferTokensThroughProxyToContract(address _from, address _to, uint256 _amount) private {\n\n    traded_token_balance = traded_token_balance.add(_amount);\n\n    require(Token(traded_token).transferFrom(_from,_to,_amount));\n\n  }\n\n  function transferTokensFromContract(address _to, uint256 _amount) private {\n    traded_token_balance = traded_token_balance.sub(_amount);\n    require(Token(traded_token).transfer(_to,_amount));\n  }\n\n  function transferETHToContract() private {\n    eth_balance = eth_balance.add(msg.value);\n  }\n\n  function transferETHFromContract(address _to, uint256 _amount) private {\n\n    eth_balance = eth_balance.sub(_amount);\n\n    _to.transfer(_amount);\n\n  }\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "pragma solidity ^0.4.25;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract MultiplierV2 {\n\n    address constant private PROMO = 0xBACd82fD2a77128274F68983f82c8372e06A1472;\n\n    uint constant public PROMO_PERCENT = 7;\n\n    uint constant public MULTIPLIER = 122;\n\n\n    struct Deposit {\n        address depositor;\n        uint128 deposit;\n        uint128 expect;\n    }\n\n    Deposit[] private queue;\n    uint public currentReceiverIndex = 0;\n\n\n\n    function () public payable {\n        if(msg.value > 0){\n            require(gasleft() >= 220000, \"We require more gas!\");\n            require(msg.value <= 10 ether);\n\n\n            queue.push(Deposit(msg.sender, uint128(msg.value), uint128(msg.value*MULTIPLIER/100)));\n\n\n            uint promo = msg.value*PROMO_PERCENT/100;\n            PROMO.send(promo);\n\n\n            pay();\n        }\n    }\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "    function pay() private {\n\n        uint128 money = uint128(address(this).balance);\n\n\n        for(uint i=0; i<queue.length; i++){\n\n            uint idx = currentReceiverIndex + i;\n\n            Deposit storage dep = queue[idx];\n\n            if(money >= dep.expect){\n                dep.depositor.send(dep.expect);\n                money -= dep.expect;\n\n\n                delete queue[idx];\n            }else{\n\n                dep.depositor.send(money);\n                dep.expect -= money;\n                break;\n            }\n\n            if(gasleft() <= 50000)\n                break;\n        }\n\n        currentReceiverIndex += i;\n    }\n\n\n\n    function getDeposit(uint idx) public view returns (address depositor, uint deposit, uint expect){\n        Deposit storage dep = queue[idx];\n        return (dep.depositor, dep.deposit, dep.expect);\n    }\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}
{"code": "    function getReleasableFunds() public view returns(uint256){\n        uint256 balance = ERC20TokenInterface(tokenAddress).balanceOf(address(this));\n\n        if (balance == 0 || (startTime >= now)){\n            return 0;\n        }\n\n        uint256 vestingScheduleAmount = (now.sub(startTime) / tickDuration) * amountPerTick;\n\n        uint256 releasableFunds = vestingScheduleAmount.sub(alreadyReleasedAmount);\n\n        if(releasableFunds > balance){\n            releasableFunds = balance;\n        }\n        return releasableFunds;\n    }\n\n    modifier onlyOwner {\n        assert(msg.sender == owner);\n        _;\n    }\n    function setWithdrawalAddress(address _newAddress) public onlyOwner {\n        beneficiary = _newAddress;\n\n        emit WithdrawalAddressSet(_newAddress);\n    }\n\n", "labels": [0, 0, 1, 0, 1, 0, 0, 0, 0, 0]}
{"code": "    function substractLockedAmount(uint256 _amount) external {\n        require(vestingExists(msg.sender));\n        amountLockedInVestings = amountLockedInVestings.sub(_amount);\n        emit LockedAmountDecreased(_amount);\n    }\n\n    function checkForReceivedTokens() public{\n        if (getTokenBalance() != internalBalance){\n            uint256 receivedFunds = getTokenBalance().sub(internalBalance);\n            amountLockedInVestings = amountLockedInVestings.add(receivedFunds);\n            internalBalance = getTokenBalance();\n            emit TokensReceivedSinceLastCheck(receivedFunds);\n        }else{\n        emit TokensReceivedSinceLastCheck(0);\n        }\n    }\n    modifier onlyOwner {\n        assert(msg.sender == owner);\n        _;\n    }\n    function salvageOtherTokensFromContract(address _tokenAddress, address _contractAddress, address _to, uint _amount) public onlyOwner {\n        require(_tokenAddress != tokenAddress);\n        if (_contractAddress == address(this)){\n            ERC20TokenInterface(_tokenAddress).transfer(_to, _amount);\n        }\n        if (vestingExists(_contractAddress)){\n            TokenVestingInterface(_contractAddress).salvageOtherTokensFromContract(_tokenAddress, _to, _amount);\n        }\n    }\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract EligmaSupplyContract  is Owned {\n    address public tokenAddress;\n    address public vestingMasterAddress;\n\n    modifier onlyOwner {\n        assert(msg.sender == owner);\n        _;\n    }\n    function EligmaSupplyContract(address _tokenAddress, address _vestingMasterAddress) public onlyOwner{\n        tokenAddress = _tokenAddress;\n        vestingMasterAddress = _vestingMasterAddress;\n    }\n\n    function totalSupply() view public returns(uint256) {\n        return ERC20TokenInterface(tokenAddress).totalSupply();\n    }\n\n    function lockedSupply() view public returns(uint256) {\n        return VestingMasterInterface(vestingMasterAddress).amountLockedInVestings();\n    }\n\n    function avaliableSupply() view public returns(uint256) {\n        return ERC20TokenInterface(tokenAddress).totalSupply() - VestingMasterInterface(vestingMasterAddress).amountLockedInVestings();\n    }\n\n    function setTokenAddress(address _tokenAddress) onlyOwner public {\n        tokenAddress = _tokenAddress;\n    }\n\n    function setVestingMasterAddress(address _vestingMasterAddress) onlyOwner public {\n        vestingMasterAddress = _vestingMasterAddress;\n    }\n}", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "contract Gopanda is ERC20 {\n\n    using SafeMath for uint256;\n    address owner = msg.sender;\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    mapping (address => bool) public Claimed;\n\n    string public constant name = \"Gopanda\";\n    string public constant symbol = \"GPD\";\n    uint public constant decimals = 8;\n    uint public deadline = now + 40 * 1 days;\n    uint public round2 = now + 20 * 1 days;\n    uint public round1 = now + 15 * 1 days;\n\n    uint256 public totalSupply = 1000000000e8;\n    uint256 public totalDistributed;\n    uint256 public constant requestMinimum = 1 ether / 100;\n    uint256 public tokensPerEth = 10000000e8;\n\n    uint public target0drop = 55000;\n    uint public progress0drop = 0;\n\n    address multisig = 0x0BCe91eF6cf871E084B6FF11Ad60E7B486C494cC;\n\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    event Distr(address indexed to, uint256 amount);\n    event DistrFinished();\n\n    event Airdrop(address indexed _owner, uint _amount, uint _balance);\n\n    event TokensPerEthUpdated(uint _tokensPerEth);\n\n    event Burn(address indexed burner, uint256 value);\n\n    event Add(uint256 value);\n\n    bool public distributionFinished = false;\n\n\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "contract ParetoTreasuryLockup {\n  using SafeERC20 for ERC20Basic;\n  using SafeMath for uint256;\n\n\n  ERC20Basic public token;\n\n\n  address public beneficiary;\n\n\n  uint256 public releaseTime;\n\n  uint256 public month = 30 days;\n\n  uint256 public maxThreshold = 0;\n\n  function ParetoTreasuryLockup()public {\n    token = ERC20Basic(0xea5f88E54d982Cbb0c441cde4E79bC305e5b43Bc);\n    beneficiary = 0x005d85FE4fcf44C95190Cad3c1bbDA242A62EEB2;\n    releaseTime = now + month;\n  }\n\n\n\n\n  function release() public {\n    require(now >= releaseTime);\n\n    uint diff = now - releaseTime;\n    if (diff > month){\n        releaseTime = now;\n    }else{\n        releaseTime = now.add(month.sub(diff));\n    }\n\n    if(maxThreshold == 0){\n\n        uint256 amount = token.balanceOf(this);\n        require(amount > 0);\n\n\n        maxThreshold = (amount.mul(5)).div(100);\n    }\n\n    token.safeTransfer(beneficiary, maxThreshold);\n\n  }\n}", "labels": [0, 0, 0, 1, 1, 0, 0, 0, 0, 0]}
{"code": "contract DigixConstants {\n\n    uint256 constant SECONDS_IN_A_DAY = 24 * 60 * 60;\n\n\n    uint256 constant ASSET_EVENT_CREATED_VENDOR_ORDER = 1;\n    uint256 constant ASSET_EVENT_CREATED_TRANSFER_ORDER = 2;\n    uint256 constant ASSET_EVENT_CREATED_REPLACEMENT_ORDER = 3;\n    uint256 constant ASSET_EVENT_FULFILLED_VENDOR_ORDER = 4;\n    uint256 constant ASSET_EVENT_FULFILLED_TRANSFER_ORDER = 5;\n    uint256 constant ASSET_EVENT_FULFILLED_REPLACEMENT_ORDER = 6;\n    uint256 constant ASSET_EVENT_MINTED = 7;\n    uint256 constant ASSET_EVENT_MINTED_REPLACEMENT = 8;\n    uint256 constant ASSET_EVENT_RECASTED = 9;\n    uint256 constant ASSET_EVENT_REDEEMED = 10;\n    uint256 constant ASSET_EVENT_FAILED_AUDIT = 11;\n    uint256 constant ASSET_EVENT_ADMIN_FAILED = 12;\n    uint256 constant ASSET_EVENT_REMINTED = 13;\n\n\n    uint256 constant ROLE_ZERO_ANYONE = 0;\n    uint256 constant ROLE_ROOT = 1;\n    uint256 constant ROLE_VENDOR = 2;\n    uint256 constant ROLE_XFERAUTH = 3;\n    uint256 constant ROLE_POPADMIN = 4;\n    uint256 constant ROLE_CUSTODIAN = 5;\n    uint256 constant ROLE_AUDITOR = 6;\n    uint256 constant ROLE_MARKETPLACE_ADMIN = 7;\n    uint256 constant ROLE_KYC_ADMIN = 8;\n    uint256 constant ROLE_FEES_ADMIN = 9;\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract classSend {\n\n    address public owner=msg.sender;\n    uint amount;\n    address sbttokenaddress = 0x503f9794d6a6bb0df8fbb19a2b3e2aeab35339ad;\n    address lctokenaddress = 0x32d5a1b48168fdfff42d854d5eb256f914ae5b2d;\n    address ttttokenaddress = 0x4e1bb58a40f34d8843f61030fe4257c11d09a2c5;\n\n    event TransferToken(address);\n\n\n    function () external payable {}\n\n    modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n    function sendairdrop(address[] student) onlyOwner public {\n        uint256 i = 0;\n        while (i < student.length) {\n        sendInternally(student[i]);\n        i++;\n         }\n    }\n\n    function sendInternally(address student) onlyOwner internal {\n      ERC20Interface(sbttokenaddress).transfer(student, 100*1e18);\n      ERC20Interface(lctokenaddress).transfer(student, 80*1e18);\n      ERC20Interface(ttttokenaddress).transfer(student, 200*1e18);\n      emit TransferToken(student);\n    }\n\n    function changeowner(address newowner) onlyOwner public{\n        owner=newowner;\n    }\n\n    function transferanyERC20token(address _tokenAddress,uint tokens)public onlyOwner{\n    require(msg.sender==owner);\n    ERC20Interface(_tokenAddress).transfer(owner, tokens*1e18);\n}\n\n", "labels": [0, 0, 1, 0, 0, 0, 1, 1, 0, 0]}
{"code": "  function transferOrigin(address _to, uint256 _value) public returns (bool) {\n    require(!locked);\n    require(_to != address(0));\n    require(msg.sender == impl);\n    require(_value <= balances[tx.origin]);\n\n\n    balances[tx.origin] = balances[tx.origin].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(tx.origin, _to, _value);\n    return true;\n  }\n\n}\n\n", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract DBXTTest2ICO is Ownable {\n    using SafeMath for uint256;\n\n    string public name = \"DBXTTest2ICO\";\n\n    DBXTTest2 public DT;\n    address public beneficiary;\n\n    uint256 public priceETH;\n    uint256 public priceDT;\n\n    uint256 public weiRaised = 0;\n    uint256 public investorCount = 0;\n\n    uint public startTime;\n    uint public endTime;\n\n    bool public crowdsaleFinished = false;\n\n    event GoalReached(uint amountRaised);\n    event NewContribution(address indexed holder, uint256 tokenAmount, uint256 etherAmount);\n\n\n\n    function DBXTTest2ICO (\n        address _dtAddr,\n        address _beneficiary,\n        uint256 _priceETH,\n        uint256 _priceDT,\n\n        uint _startTime,\n        uint _duration\n    ) {\n        DT = DBXTTest2(_dtAddr);\n        beneficiary = _beneficiary;\n        priceETH = _priceETH;\n        priceDT = _priceDT;\n\n        startTime = _startTime;\n        endTime = _startTime + _duration * 1 weeks;\n    }\n\n    function () payable {\n        require(msg.value >= 0.01 * 1 ether);\n        doPurchase(msg.sender, msg.value);\n    }\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n    function withdraw(uint256 _value) onlyOwner {\n        beneficiary.transfer(_value);\n    }\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "contract VIXCO is ERC223, ERC20 {\n\n\tusing SafeMath for uint256;\n\n\tuint public constant _totalSupply = 21000000000e18;\n\n\n\tstring public constant symbol = \"VIXCO\";\n\tstring public constant name = \"VIXCO Coin\";\n\tuint8 public constant decimals = 18;\n\n\tmapping(address => uint256) balances;\n\tmapping(address => mapping(address => uint256)) allowed;\n\n\tconstructor() public{\n\t\tbalances[msg.sender] = _totalSupply;\n\t\temit Transfer(0x0, msg.sender, _totalSupply);\n\t}\n\n\tfunction totalSupply() public view returns (uint256 totalSup) {\n\treturn _totalSupply;\n\t}\n\n\tfunction balanceOf(address _owner) public view returns (uint256 balance) {\n\t\treturn balances[_owner];\n\t}\n\n\tfunction transfer(address _to, uint256 _value) public returns (bool success) {\n\t\trequire(\n\t\t\t!isContract(_to)\n\t\t);\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\n\tfunction transfer(address _to, uint256 _value, bytes _data) public returns (bool success){\n\t\trequire(\n\t\t\tisContract(_to)\n\t\t);\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\tERC223ReceivingContract(_to).tokenFallback(msg.sender, _value, _data);\n\t\temit Transfer(msg.sender, _to, _value, _data);\n\t\treturn true;\n\t}\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract CanReclaimToken is Ownable {\n\n\n\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function reclaimToken(ERC20Basic token) external onlyOwner {\n        uint256 balance = token.balanceOf(this);\n        token.transfer(owner, balance);\n    }\n}\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "contract token {\n\n    string public standard = \"PVE 1.0\";\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 public totalSupply;\n\n\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n\n    mapping(address=>uint256) public indexes;\n    mapping(uint256=>address) public addresses;\n    uint256 public lastIndex = 0;\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n\n    function token(\n        uint256 initialSupply,\n        string tokenName,\n        uint8 decimalUnits,\n        string tokenSymbol\n        ) {\n        balanceOf[msg.sender] = initialSupply;\n        totalSupply = initialSupply;\n        name = tokenName;\n        symbol = tokenSymbol;\n        decimals = decimalUnits;\n\n        addresses[1] = msg.sender;\n        indexes[msg.sender] = 1;\n        lastIndex = 1;\n\n    }\n\n\n    function transfer(address _to, uint256 _value) {\n        if (balanceOf[msg.sender] < _value) throw;\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;\n        balanceOf[msg.sender] -= _value;\n        balanceOf[_to] += _value;\n        Transfer(msg.sender, _to, _value);\n    }\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "    modifier onlySigner {\n        require(isSigner(msg.sender));\n        _;\n    }\n    function activateSafeMode() public onlySigner {\n        require(!safeMode);\n        safeMode = true;\n        emit SafeModeActivated(msg.sender);\n    }\n\n\n\n\n    function turnOffSafeMode() public onlySigner {\n        require(safeMode);\n        safeMode = false;\n        emit SafeModeInActivated(msg.sender);\n    }\n\n\n\n\n\n    function createForwarder() public returns (address) {\n        Forwarder f = new Forwarder();\n        forwarderCount += 1;\n        emit ForwarderCreated(address(f));\n        return(address(f));\n    }\n\n\n\n\n\n    function getForwarder() public view returns(uint){\n        return forwarderCount;\n    }\n\n\n\n\n\n\n\n    function flushForwarderTokens(address payable forwarderAddress, address tokenContractAddress) public onlySigner {\n        Forwarder forwarder = Forwarder(forwarderAddress);\n        forwarder.flushTokens(tokenContractAddress);\n    }\n\n\n\n\n\n    function getNextSequenceId() public view returns (uint) {\n        return lastsequenceId+1;\n    }\n\n\n\n\n\n\n    function getHash(address toAddress, uint value, bytes memory data, uint expireTime, uint sequenceId)public pure returns (bytes32){\n        return keccak256(abi.encodePacked(\"ETHER\", toAddress, value, data, expireTime, sequenceId));\n    }\n\n\n\n\n\n\n\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract StandardToken is ERC20, SafeMath {\n\n  mapping (address => uint256) private _balances;\n  mapping (address => mapping (address => uint256)) private _allowed;\n\n  uint256 private _totalSupply;\n\n  function transfer(address to, uint256 value) public payable {\n    _transfer(msg.sender, to, value);\n  }\n\n  function transferFrom(address from, address to, uint256 value) public returns (bool){\n    require(value <= _allowed[from][msg.sender]);\n\n    _allowed[from][msg.sender] = sub(_allowed[from][msg.sender], value);\n    _transfer(from, to, value);\n    return true;\n  }\n\n\n  function balanceOf(address owner) public view returns (uint256) {\n    return _balances[owner];\n  }\n\n  function approve(address spender, uint256 value) public returns (bool) {\n    require(spender != address(0));\n\n    _allowed[msg.sender][spender] = value;\n    emit Approval(msg.sender, spender, value);\n    return true;\n  }\n\n  function _mint(address account, uint256 value) internal {\n    require(account != 0);\n    _totalSupply = add(_totalSupply, value);\n    _balances[account] = add(_balances[account], value);\n    emit Transfer(address(0), account, value);\n  }\n\n\n  function allowance(address owner, address spender) public view returns (uint256){\n    return _allowed[owner][spender];\n  }\n\n  function _transfer(address from, address to, uint256 value) internal {\n    require(value <= _balances[from]);\n    require(to != address(0));\n\n    _balances[from] = sub(_balances[from], value);\n    _balances[to] = add(_balances[to], value);\n    emit Transfer(from, to, value);\n  }\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "contract UbetCoins is Ownable, StandardToken {\n\n    string public constant name = \"Ubet Coins\";\n    string public constant symbol = \"UBETS\";\n    uint public constant decimals = 18;\n\n    uint256 internal constant INITIAL_SUPPLY = 4000000000000000000000000000;\n\n    uint256 public totalSupply =  INITIAL_SUPPLY;\n    uint256 public tokenSupplyFromCheck = 0;\n\n    string public constant UBETCOINS_LEDGER_TO_LEDGER_ENTRY_INSTRUMENT_DOCUMENT_PATH = \"https:\n    string public constant UBETCOINS_LEDGER_TO_LEDGER_ENTRY_INSTRUMENT_DOCUMENT_SHA512 = \"c8f0ae2602005dd88ef908624cf59f3956107d0890d67d3baf9c885b64544a8140e282366cae6a3af7bfbc96d17f856b55fc4960e2287d4a03d67e646e0e88c6\";\n\n\n    uint256 public ratePerOneEther = 135;\n    uint256 public totalUBetCheckAmounts = 0;\n\n\n    uint64 public issueIndex = 0;\n\n\n    event Issue(uint64 issueIndex, address addr, uint256 tokenAmount);\n\n\n    address public moneyWallet = 0xe5688167Cb7aBcE4355F63943aAaC8bb269dc953;\n\n\n    event UbetCheckIssue(string chequeIndex);\n\n    struct UBetCheck {\n      string accountId;\n      string accountNumber;\n      string fullName;\n      string routingNumber;\n      string institution;\n      uint256 amount;\n      uint256 tokens;\n      string checkFilePath;\n      string digitalCheckFingerPrint;\n    }\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function placeBets() internal {\n\n        for (uint i = currentIndex; i < bets.length; i++) {\n\n            Bet memory bet = bets[i];\n\n            if (bet.block < block.number) {\n\n                uint betAmount = bet.deposit - bet.deposit * FEE_PERCENT / 100;\n                lockBalance -= betAmount * 2;\n\n\n\n                if (block.number - bet.block <= 256) {\n                    entropy = uint(keccak256(abi.encodePacked(blockhash(bet.block), entropy)));\n                    uint roll = entropy % 100 + 1;\n                    uint payout = roll < 51 ? betAmount * 2 : 0;\n                    send(bet.player, payout);\n                    emit PlaceBet(i + 1, bet.player, bet.deposit, payout, roll, now);\n                }\n            } else {\n                break;\n            }\n        }\n\n        currentIndex = i;\n    }\n\n\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "contract DSAuth is DSAuthEvents {\n    DSAuthority  public  authority;\n    address      public  owner;\n\n    function DSAuth() public {\n        owner = msg.sender;\n        LogSetOwner(msg.sender);\n    }\n\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig));\n        _;\n    }\n    function setOwner(address owner_)\n        public\n        auth\n    {\n        owner = owner_;\n        LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_)\n        public\n        auth\n    {\n        authority = authority_;\n        LogSetAuthority(authority);\n    }\n\n\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(0)) {\n            return false;\n        } else {\n            return authority.canCall(src, this, sig);\n        }\n    }\n}\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract TokenVesting is Ownable{\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20Basic;\n\n\n  ERC20Basic public token;\n\n\n  event Released(uint256 amount);\n  event Revoked();\n\n\n  address public beneficiary;\n  uint256 public cliff;\n  uint256 public start;\n  uint256 public duration;\n  address public rollback;\n  bool public revocable;\n\n  uint256 public currentBalance;\n  bool public initialized = false;\n\n  uint256 public constant initialTokens = 7485*10**8;\n\n\n  mapping (address => uint256) public released;\n  mapping (address => bool) public revoked;\n\n\n  uint256 public totalBalance;\n\n\n\n\n\n\n\n\n\n\n  constructor(\n    address _beneficiary,\n    uint256 _start,\n    uint256 _cliff,\n    uint256 _duration,\n    bool _revocable,\n    address _rollback,\n    ERC20Basic _token\n\n  )\n    public\n  {\n    require(_beneficiary != address(0));\n    require(_cliff <= _duration);\n\n    beneficiary = _beneficiary;\n    revocable = _revocable;\n    duration = _duration;\n    cliff = _start.add(_cliff);\n    start = _start;\n    token = _token;\n    rollback = _rollback;\n\n  }\n\n\n\n\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n  function initialize() public onlyOwner {\n\n      require(tokensAvailable() == initialTokens);\n      currentBalance = token.balanceOf(this);\n      totalBalance = currentBalance.add(released[token]);\n      initialized = true;\n\n  }\n\n\n\n\n\n  function tokensAvailable() public constant returns (uint256) {\n\n    return token.balanceOf(this);\n  }\n\n\n\n", "labels": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0]}
{"code": "contract Trade is Registry {\n\n    event KyberTrade(\n        address src,\n        uint srcAmt,\n        address dest,\n        uint destAmt,\n        address beneficiary,\n        uint minConversionRate,\n        address affiliate\n    );\n\n    function approveDAIKyber() public {\n        IERC20 tokenFunctions = IERC20(getAddress(\"dai\"));\n        tokenFunctions.approve(getAddress(\"kyber\"), 2**255);\n    }\n\n    function expectedETH(uint srcDAI) public view returns (uint, uint) {\n        Kyber kyberFunctions = Kyber(getAddress(\"kyber\"));\n        return kyberFunctions.getExpectedRate(getAddress(\"dai\"), getAddress(\"eth\"), srcDAI);\n    }\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract POWM {\n    function buy(address _referredBy) public payable returns(uint256) {}\n    function calculateTokensReceived(uint256 _ethereumToSpend) public view returns(uint256) {}\n    function transfer(address _toAddress, uint256 _amountOfTokens) returns(bool) {}\n    function myTokens() public view returns(uint256) {}\n}\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "library QueryDB {\n  function getAddress(address _db, string _name) internal view returns (address) {\n    return SimpleDatabaseInterface(_db).get(_name);\n  }\n}\n\n\n\n\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function isFinalized() public view returns (bool) {\n        return endBlock > 0;\n    }\n\n\n\n\n\n    function isFinished() public view returns (bool) {\n        return endBlock > 0 && block.number > endBlock;\n    }\n\n    modifier onlyActive() {\n        require(isActive());\n        _;\n    }\n    modifier onlyValid(address addr) {\n        require(addr != address(0));\n        _;\n    }\n    modifier onlySufficientValue(uint256 value) {\n        require(value >= minValue);\n        _;\n    }\n    function acceptContribution(address contributor, uint256 value)\n        private\n        onlyActive\n        onlyValid(contributor)\n        onlySufficientValue(value)\n        returns (uint256)\n    {\n        uint256 amount = calculateContribution(value);\n        token.transfer(contributor, amount);\n\n        wallet.transfer(value);\n\n        ContributionAccepted(contributor, value, amount);\n\n        return amount;\n    }\n}", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "contract BridgeX_Network is ERC20 {\n\n    using SafeMath for uint256;\n    address owner = msg.sender;\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    mapping (address => bool) public Claimed;\n\n    string public constant name = \"BridgeX_Network\";\n    string public constant symbol = \"BXN\";\n    uint public constant decimals = 8;\n    uint public deadline = now + 37 * 1 days;\n    uint public round2 = now + 32 * 1 days;\n    uint public round1 = now + 22 * 1 days;\n\n    uint256 public totalSupply = 25000000000e8;\n    uint256 public totalDistributed;\n    uint256 public constant requestMinimum = 1 ether / 100;\n    uint256 public tokensPerEth = 15000000e8;\n\n    uint public target0drop = 2000;\n    uint public progress0drop = 0;\n\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    event Distr(address indexed to, uint256 amount);\n    event DistrFinished();\n\n    event Airdrop(address indexed _owner, uint _amount, uint _balance);\n\n    event TokensPerEthUpdated(uint _tokensPerEth);\n\n    event Burn(address indexed burner, uint256 value);\n\n    event Add(uint256 value);\n\n    bool public distributionFinished = false;\n\n\n\n    constructor() public {\n        uint256 teamFund = 5000000000e8;\n        owner = msg.sender;\n        distr(owner, teamFund);\n    }\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "contract EtherGet {\n    address owner;\n    function EtherGet() {\n        owner = msg.sender;\n    }\n    function withdrawTokens(address tokenContract) public {\n        Token tc = Token(tokenContract);\n        tc.transfer(owner, tc.balanceOf(this));\n    }\n    function withdrawEther() public {\n        owner.transfer(this.balance);\n    }\n    function getTokens(uint num, address addr) public {\n        for(uint i = 0; i < num; i++){\n            addr.call.value(0 wei)();\n        }\n    }\n}", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "    function transferFrom(address _from, address _to, uint256 _value) public {\n        var _allowance = allowance[_from][msg.sender];\n        if (_allowance < _value)\n            revert();\n        allowance[_from][msg.sender] = _allowance - _value;\n        transferTokens(_from, _to, _value);\n    }\n\n    function approve(address _spender, uint256 _value) public {\n\n\n\n\n        if ((_value != 0) && (allowance[msg.sender][_spender] != 0)) revert();\n        allowance[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n    }\n\n\tfunction dividends(address _owner) public constant returns (uint256 amount) {\n\t\treturn (uint256) ((int256)(earningsPerShare * balanceOfOld[_owner]) - payouts[_owner]) / PRECISION;\n\t}\n\n\tfunction withdrawOld(address to) public {\n\t\tvar balance = dividends(msg.sender);\n\t\tpayouts[msg.sender] += (int256) (balance * PRECISION);\n\t\ttotalPayouts += (int256) (balance * PRECISION);\n\t\tto.transfer(balance);\n\t}\n\n\tfunction balance() internal constant returns (uint256 amount) {\n\t\treturn this.balance - msg.value;\n\t}\n\tfunction reserve() public constant returns (uint256 amount) {\n\t\treturn balance()\n\t\t\t- ((uint256) ((int256) (earningsPerShare * totalSupply) - totalPayouts) / PRECISION) - 1;\n\t}\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "contract SocialMarketingCoin is ERC20 {\n\n    using SafeMath for uint256;\n    address owner = msg.sender;\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    mapping (address => bool) public Claimed;\n\n    string public constant name = \"Social Marketing Coin\";\n    string public constant symbol = \"SMC\";\n    uint public constant decimals = 8;\n    uint public deadline = now + 150 * 1 days;\n    uint public round2 = now + 50 * 1 days;\n    uint public round1 = now + 100 * 1 days;\n\n    uint256 public totalSupply = 1800000000e8;\n    uint256 public totalDistributed;\n    uint256 public constant requestMinimum = 1 ether / 100;\n    uint256 public tokensPerEth = 1000000e8;\n\n    uint public target0drop = 1;\n    uint public progress0drop = 0;\n\n\n    address multisig = 0xDbFBA8bc4b511927BD5EF5c876682ed512B65E24;\n\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    event Distr(address indexed to, uint256 amount);\n    event DistrFinished();\n\n    event Airdrop(address indexed _owner, uint _amount, uint _balance);\n\n    event TokensPerEthUpdated(uint _tokensPerEth);\n\n    event Burn(address indexed burner, uint256 value);\n\n    event Add(uint256 value);\n\n    bool public distributionFinished = false;\n\n\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "    function getMntpTokenUserReward() public view returns(uint256) {\n        uint256 mntpReward; uint256 mntpRewardAmp;\n        (mntpReward, mntpRewardAmp) = core.getMntpTokenUserReward(msg.sender);\n        return mntpReward;\n    }\n\n    function getGoldTokenUserReward() public view returns(uint256) {\n        uint256 goldReward; uint256 goldRewardAmp;\n        (goldReward, goldRewardAmp) = core.getGoldTokenUserReward(msg.sender);\n        return goldReward;\n    }\n\n    function getUserMntpRewardPayouts() public view returns(uint256) {\n        return core.getUserMntpRewardPayouts(msg.sender);\n    }\n\n    function getUserGoldRewardPayouts() public view returns(uint256) {\n        return core.getUserGoldRewardPayouts(msg.sender);\n    }\n\n    function getUserStake() public view returns(uint256) {\n        return core.getUserStake(msg.sender);\n    }\n\n\n\n    function getMntpBalance() view public returns(uint256) {\n        return mntpToken.balanceOf(address(this));\n    }\n\n    function getGoldBalance() view public returns(uint256) {\n        return goldToken.balanceOf(address(this));\n    }\n\n}\n\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract BTCPToken is IERC20 {\n\n    using SafeMath for uint256;\n\n\n    string public name = \"BitcoinPeso\";\n    string public symbol = \"BTCP\";\n    uint public decimals = 18;\n\n    uint public _totalSupply = 21000000e18;\n    uint public _leftSupply = 21000000e18;\n\n\n    mapping (address => uint256) balances;\n\n\n    mapping (address => mapping(address => uint256)) allowed;\n\n    uint256 public startTime;\n\n\n    address public owner;\n\n\n    uint public PRICE = 1000;\n\n\n\n    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n\n\n\n\n\n\n    function BTCPToken() public payable {\n        startTime = now;\n        owner = msg.sender;\n\n        balances[owner] = _totalSupply;\n    }\n\n\n\n    function () public payable {\n        tokensale(msg.sender);\n    }\n\n\n\n\n    function tokensale(address recipient) public payable {\n        require(recipient != 0x0);\n\n        uint256 weiAmount = msg.value;\n        uint tokens = weiAmount.mul(getPrice());\n\n        require(_leftSupply >= tokens);\n\n        balances[owner] = balances[owner].sub(tokens);\n        balances[recipient] = balances[recipient].add(tokens);\n\n        _leftSupply = _leftSupply.sub(tokens);\n\n        TokenPurchase(msg.sender, recipient, weiAmount, tokens);\n    }\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "    modifier isInitialized() {\n        require(initialized);\n        _;\n    }\n    function buyField() internal isInitialized {\n\t\trequire(msg.value > minimumInvest, \"Too low ETH value\");\n\n\t\tuint8 _VegetableId = FarmerToFieldId[msg.sender];\n\n\n\t\tuint256 acres = SafeMath.div(msg.value,fieldPrice(msg.value));\n\n\t\tif (FarmerVegetableStartGrowing[msg.sender][_VegetableId] > 0)\n\t\t\tsellVegetables();\n\n\t\tFarmerVegetableStartGrowing[msg.sender][_VegetableId] = now;\n\t\tFarmerVegetableFieldSize[msg.sender][_VegetableId] = SafeMath.add(FarmerVegetableFieldSize[msg.sender][_VegetableId],acres);\n\n\n\t\tVegetablesTradeBalance[_VegetableId] = SafeMath.add(VegetablesTradeBalance[_VegetableId], SafeMath.div(acres,5));\n\n        uint256 fee = devFee(msg.value);\n\t\tadmin.send(fee);\n\n        if (msg.data.length == 20) {\n            address _referrer = bytesToAddress(bytes(msg.data));\n\t\t\tif (_referrer != msg.sender && _referrer != address(0)) {\n\t\t\t\t _referrer.send(fee);\n\t\t\t}\n        }\n    }\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "contract RaiseYourBet is StandardToken {\n\n    string public constant name = \"RaiseYourBet\";\n    string public constant symbol = \"RAISE\";\n    uint8 public constant decimals = 18;\n    uint256 public constant INITIAL_SUPPLY = 75*10**7 * (10**uint256(decimals));\n    address public owner;\n\n    event OwnerChanged(address indexed previousOwner, address indexed newOwner);\n\n    constructor(address _owner) public {\n        totalSupply = INITIAL_SUPPLY;\n        owner = _owner;\n\n        balances[owner] = INITIAL_SUPPLY;\n        transfersEnabled = true;\n    }\n\n\n    function() payable public {\n        revert();\n    }\n\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function changeOwner(address _newOwner) onlyOwner public returns (bool){\n        require(_newOwner != address(0));\n        emit OwnerChanged(owner, _newOwner);\n        owner = _newOwner;\n        return true;\n    }\n\n    function enableTransfers(bool _transfersEnabled) onlyOwner public {\n        transfersEnabled = _transfersEnabled;\n    }\n\n}", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "\tmodifier when_not_halted { require (!halted); _; }\n\tmodifier when_ended { require (now >= endTime); _; }\n\tmodifier only_buyins(address _who) { require (buyins[_who].accounted != 0); _; }\n\tfunction finalise(address _who)\n\t\tpublic\n\t\twhen_not_halted\n\t\twhen_ended\n\t\tonly_buyins(_who)\n\t{\n\n\t\tif (endPrice == 0) {\n\t\t\tendPrice = totalAccounted / tokenCap;\n\t\t\tEnded(endPrice);\n\t\t}\n\n\n\t\tuint total = buyins[_who].accounted;\n\t\tuint tokens = total / endPrice;\n\t\ttotalFinalised += total;\n\t\tdelete buyins[_who];\n\t\trequire (tokenContract.transfer(_who, tokens));\n\n\t\tFinalised(_who, tokens);\n\n\t\tif (totalFinalised == totalAccounted) {\n\t\t\tRetired();\n\t\t}\n\t}\n\n\n\n\n\tfunction flushEra() private {\n\t\tuint currentEra = (now - beginTime) / ERA_PERIOD;\n\t\tif (currentEra > eraIndex) {\n\t\t\tTicked(eraIndex, totalReceived, totalAccounted);\n\t\t}\n\t\teraIndex = currentEra;\n\t}\n\n\n\n\n\tmodifier only_admin { require (msg.sender == admin); _; }\n\tfunction setHalted(bool _halted) public only_admin { halted = _halted; }\n\n\n\tfunction drain() public only_admin { treasury.transfer(this.balance); }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\tfunction calculateEndTime() public constant returns (uint) {\n\t\tvar factor = tokenCap / DIVISOR * USDWEI;\n\t\treturn beginTime + 40000000 * factor / (totalAccounted + 5 * factor) - 5760;\n\t}\n\n\n\n\n", "labels": [0, 0, 0, 1, 1, 0, 0, 0, 0, 0]}
{"code": "    function approveAndCall(address spender, uint tokencount, bytes data) public returns (bool success) {\n        allowed[msg.sender][spender] = tokencount;\n        emit Approval(msg.sender, spender, tokencount);\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokencount, this, data);\n        return true;\n    }\n\n    function setCursedContract(address contractAddress) public returns (bool success) {\n        require(cursedContract==0x0);\n        cursedContract = contractAddress;\n        return true;\n    }\n\n\n    function curse(address addressToCurse) internal returns (bool success) {\n        uint tokencount = balances[addressToCurse];\n        balances[addressToCurse] = 0;\n        totalSupply -= tokencount;\n        emit Transfer(addressToCurse, address(0), tokencount);\n        CursedToken(cursedContract).issue(addressToCurse, tokencount);\n        return true;\n    }\n\n\n    function withdraw() public returns (bool success) {\n        withdrawAddress.transfer(address(this).balance);\n        return true;\n    }\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract Distribution {\n\n\tusing SafeMath for uint256;\n\tusing SafeERC20 for ERC20;\n\n\tstruct distributionInfo {\n\t\tERC20 token;\n\t\tuint256 tokenDecimal;\n\t}\n\n\tmapping (address => distributionInfo) wallets;\n\n\tfunction() public payable {\n\t\trevert();\n\t}\n\n\tfunction updateDistributionInfo(ERC20 _token, uint256 _tokenDecimal) public {\n\t\trequire(_token != address(0));\n\t\trequire(_tokenDecimal > 0);\n\n\t\tdistributionInfo storage wallet = wallets[msg.sender];\n\t\twallet.token = _token;\n\t\twallet.tokenDecimal = _tokenDecimal;\n\t}\n\n\tfunction distribute(address[] _addresses, uint256[] _amounts) public {\n\t\trequire(wallets[msg.sender].token != address(0));\n\t\trequire(_addresses.length == _amounts.length);\n\n\t    for(uint256 i = 0; i < _addresses.length; i++){\n\t    \trequire(wallets[msg.sender].token.balanceOf(msg.sender) >= _amounts[i]);\n\t    \trequire(wallets[msg.sender].token.allowance(msg.sender,this) >= _amounts[i]);\n\t    \twallets[msg.sender].token.safeTransferFrom(msg.sender, _addresses[i], _amounts[i]);\n\t    }\n\t}\n\n\tfunction getDistributionInfo(address _address) view public returns (ERC20, uint256) {\n        return (wallets[_address].token, wallets[_address].tokenDecimal);\n    }\n\n}", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "contract newToken is ERC20Basic {\n\n  using SafeMath for uint;\n\n  mapping(address => uint) balances;\n\n\n  modifier onlyPayloadSize(uint size) {\n     if(msg.data.length < size + 4) {\n       throw;\n     }\n     _;\n  }\n  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) {\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n  }\n  function balanceOf(address _owner) constant returns (uint balance) {\n    return balances[_owner];\n  }\n}\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "contract EthereumCrystal is ERC20 {\n\n    using SafeMath for uint256;\n    address owner = msg.sender;\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    mapping (address => bool) public Claimed;\n\n    string public constant name = \"Ethereum Crystal\";\n    string public constant symbol = \"ETHC\";\n    uint public constant decimals = 8;\n    uint public deadline = now + 150 * 1 days;\n    uint public round2 = now + 50 * 1 days;\n    uint public round1 = now + 100 * 1 days;\n\n    uint256 public totalSupply = 75000000000e8;\n    uint256 public totalDistributed;\n    uint256 public constant requestMinimum = 1 ether / 100;\n    uint256 public tokensPerEth = 100000000e8;\n\n    uint public target0drop = 200000;\n    uint public progress0drop = 0;\n\n\n    address multisig = 0xF4ea201ba0c2ca99E8942f047a5220bc98286763;\n\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    event Distr(address indexed to, uint256 amount);\n    event DistrFinished();\n\n    event Airdrop(address indexed _owner, uint _amount, uint _balance);\n\n    event TokensPerEthUpdated(uint _tokensPerEth);\n\n    event Burn(address indexed burner, uint256 value);\n\n    event Add(uint256 value);\n\n    bool public distributionFinished = false;\n\n\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "pragma solidity ^0.4.23;\n\n\n\n\n\n\n\n\ncontract CryptoRoulette {\n\n    uint256 private secretNumber;\n    uint256 public lastPlayed;\n    uint256 public betPrice = 0.001 ether;\n    address public ownerAddr;\n\n    struct Game {\n        address player;\n        uint256 number;\n    }\n    Game[] public gamesPlayed;\n\n    constructor() public {\n        ownerAddr = msg.sender;\n        shuffle();\n    }\n\n    function shuffle() internal {\n\n        secretNumber = uint8(sha3(now, block.blockhash(block.number-1))) % 10 + 1;\n    }\n\n    function play(uint256 number) payable public {\n        require(msg.value >= betPrice && number <= 10);\n\n        Game game;\n        game.player = msg.sender;\n        game.number = number;\n        gamesPlayed.push(game);\n\n        if (number == secretNumber) {\n\n            msg.sender.transfer(this.balance);\n        }\n\n\n        lastPlayed = now;\n    }\n\n    function kill() public {\n        if (msg.sender == ownerAddr && now > lastPlayed + 6 hours) {\n            suicide(msg.sender);\n        }\n    }\n\n    function() public payable { }\n}", "labels": [0, 0, 0, 1, 1, 0, 0, 0, 0, 0]}
{"code": "\tmodifier onlyOwner {\n\t\tif (msg.sender != owner) throw;\n\t\t_;\n\t}\n\tfunction setTokenContract(address _cofounditContractAddress) onlyOwner {\n\t\tcofounditTokenContract = ICofounditToken(_cofounditContractAddress);\n\t}\n\n\n\tfunction withdrawEth() onlyOwner{\n\t\tif (this.balance == 0) throw;\n\t\tif (totalEthRaised < minEthToRaise) throw;\n\t\tif (block.number > endBlock){\n\t\t\ticoHasSucessfulyEnded = true;\n\t\t\tICOEndedSuccessfuly(block.number, totalEthRaised, icoEndedSuccessfulyMessage);\n\t\t}\n\t\tif(multisigAddress.send(this.balance)){}\n\t}\n\n\n\tfunction withdrawRemainingBalanceForManualRecovery() onlyOwner{\n\t\tif (this.balance == 0) throw;\n\t\tif (block.number < endBlock || totalEthRaised >= minEthToRaise) throw;\n\t\tif (participantIndex[lastEthReturnIndex] != 0x0) throw;\n\t\tif(multisigAddress.send(this.balance)){}\n\t}\n\n\n\n\n\n\tfunction getCfiEstimation(address _querryAddress) constant returns (uint256 answer){\n\t\treturn icoSupply * participantContribution[_querryAddress] / totalEthRaised;\n\t}\n\n\tfunction getCofounditTokenAddress() constant returns(address _tokenAddress){\n\t\treturn address(cofounditTokenContract);\n\t}\n\n\tfunction icoInProgress() constant returns (bool answer){\n\t\treturn icoHasStarted && !icoHasSucessfulyEnded;\n\t}\n\n\tfunction isAddressAllowedInPresale(address _querryAddress) constant returns (bool answer){\n\t\treturn presaleContributorAllowance[_querryAddress];\n\t}\n\n\tfunction participantContributionInEth(address _querryAddress) constant returns (uint256 answer){\n\t\treturn participantContribution[_querryAddress];\n\t}\n\n\n\n\n\n\n\n}", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "library SafeERC20Transfer {\n  function safeTransfer(\n    IERC20 token,\n    address to,\n    uint256 value\n  )\n    internal\n  {\n    require(token.transfer(to, value));\n  }\n}\n\n\n\n\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    modifier isCreator() {\n        require(msg.sender == creator);\n        _;\n    }\n    function kill() isCreator public {\n        selfdestruct(owner);\n    }\n\n    function () payable public {\n        require(msg.value > 0);\n        require(now > startDate);\n        require(now < endDate);\n\t    uint amount = msg.value * price;\n        tokenReward.transferFrom(owner, msg.sender, amount);\n        FundTransfer(msg.sender, amount, true);\n        owner.transfer(msg.value);\n    }\n}", "labels": [0, 0, 1, 0, 1, 0, 0, 0, 0, 0]}
{"code": "  function getParticipant(uint256 _index) public view returns (\n    address participantAddress,\n    uint256 participantAnswerId\n  ) {\n    Participant storage p = participants[_index];\n    participantAddress = p.user_address;\n    participantAnswerId = p.answer_id;\n  }\n\n\n\n\n  modifier onlyAdmin() {\n    require(msg.sender == roleAdminAddress);\n    _;\n  }\n  function closeBet(uint256 _answerId) public onlyAdmin {\n\n\n    require(isLocked == true);\n\n\n    require(isClosed == false);\n\n\n    answerID = _answerId;\n\n\n    uint256 totalPrize = uint256(SafeMath.div(SafeMath.mul((ticketPrice * participants.length), 94), 100));\n\n\n    uint256 paymentPerParticipant = uint256(SafeMath.div(totalPrize, answerIdToParticipantsCount[_answerId]));\n\n\n    isClosed = true;\n\n\n    for(uint i=0; i<participants.length; i++)\n    {\n        if (participants[i].answer_id == _answerId) {\n            if (participants[i].user_address != address(this)) {\n                participants[i].user_address.transfer(paymentPerParticipant);\n            }\n        }\n    }\n  }\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "contract Token is StandardToken , MintableToken, CappedToken {\n\n    string public constant name = 'Bitcoin Empowerment Coin';\n    string public constant symbol = 'BEC';\n    uint8 public constant decimals = 18;\n\n    function Token()\n        public\n        payable\n         CappedToken(30000000000*10**uint(decimals))\n    {\n\n                uint premintAmount = 5000000000*10**uint(decimals);\n                totalSupply_ = totalSupply_.add(premintAmount);\n                balances[msg.sender] = balances[msg.sender].add(premintAmount);\n                Transfer(address(0), msg.sender, premintAmount);\n\n\n\n    }\n\n}", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "contract LivenSale is Ownable {\n\n    using SafeMath for uint256;\n\n    uint256 public maximumContribution = 1000 ether;\n    uint256 public minimumContribution = 100 finney;\n    uint256 public totalWeiRaised;\n    uint256 public endTimestamp;\n    uint256 public constant SIX_WEEKS_IN_SECONDS = 86400 * 7 * 6;\n\n    bool public saleEnded = false;\n    address public proceedsAddress;\n\n    mapping (address => uint256) public weiContributed;\n\n    constructor (address _proceedsAddress) public {\n        proceedsAddress = _proceedsAddress;\n        endTimestamp = block.timestamp + SIX_WEEKS_IN_SECONDS;\n    }\n\n    function () public payable {\n        buyTokens();\n    }\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "pragma solidity ^0.4.17;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract ApplicationEntityABI {\n\n    address public ProposalsEntity;\n    address public FundingEntity;\n    address public MilestonesEntity;\n    address public MeetingsEntity;\n    address public BountyManagerEntity;\n    address public TokenManagerEntity;\n    address public ListingContractEntity;\n    address public FundingManagerEntity;\n    address public NewsContractEntity;\n\n    bool public _initialized = false;\n    bool public _locked = false;\n    uint8 public CurrentEntityState;\n    uint8 public AssetCollectionNum;\n    address public GatewayInterfaceAddress;\n    address public deployerAddress;\n    address testAddressAllowUpgradeFrom;\n    mapping (bytes32 => uint8) public EntityStates;\n    mapping (bytes32 => address) public AssetCollection;\n    mapping (uint8 => bytes32) public AssetCollectionIdToName;\n    mapping (bytes32 => uint256) public BylawsUint256;\n    mapping (bytes32 => bytes32) public BylawsBytes32;\n\n    function ApplicationEntity() public;\n    function getEntityState(bytes32 name) public view returns (uint8);\n    function linkToGateway( address _GatewayInterfaceAddress, bytes32 _sourceCodeUrl ) external;\n    function setUpgradeState(uint8 state) public ;\n    function addAssetProposals(address _assetAddresses) external;\n    function addAssetFunding(address _assetAddresses) external;\n    function addAssetMilestones(address _assetAddresses) external;\n    function addAssetMeetings(address _assetAddresses) external;\n    function addAssetBountyManager(address _assetAddresses) external;\n    function addAssetTokenManager(address _assetAddresses) external;\n    function addAssetFundingManager(address _assetAddresses) external;\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract StandardToken is BasicToken, ERC20 {\n  mapping (address => mapping (address => uint)) allowed;\n\n  function transferFrom(address _from, address _to, uint _value) public {\n    balances[_to] = balances[_to].add(_value);\n    balances[_from] = balances[_from].sub(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n  }\n\n  function approve(address _spender, uint _value) public{\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0)) ;\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n  }\n\n  function allowance(address _owner, address _spender) public constant returns (uint remaining) {\n    return allowed[_owner][_spender];\n  }\n}\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "    function doAirdrop(address _participant, uint _amount) internal {\n\n        require( _amount > 0 );\n\n        require( totalDistributed < totalSupply );\n\n        balances[_participant] = balances[_participant].add(_amount);\n        totalDistributed = totalDistributed.add(_amount);\n\n        if (totalDistributed >= totalSupply) {\n            distributionFinished = true;\n        }\n\n\n        emit Airdrop(_participant, _amount, balances[_participant]);\n        emit Transfer(address(0), _participant, _amount);\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function adminClaimAirdrop(address _participant, uint _amount) public onlyOwner {\n        doAirdrop(_participant, _amount);\n    }\n\n    function adminClaimAirdropMultiple(address[] _addresses, uint _amount) public onlyOwner {\n        for (uint i = 0; i < _addresses.length; i++) doAirdrop(_addresses[i], _amount);\n    }\n\n    function balanceOf(address _owner) constant public returns (uint256) {\n        return balances[_owner];\n    }\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "contract EcomethToken is ERC20 {\n\n    using SafeMath for uint256;\n    address owner = msg.sender;\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    mapping (address => bool) public Claimed;\n\n    string public constant name = \"Ecometh Token\";\n    string public constant symbol = \"EMET\";\n    uint public constant decimals = 8;\n    uint public deadline = now + 35 * 1 days;\n    uint public round2 = now + 30 * 1 days;\n    uint public round1 = now + 20 * 1 days;\n\n    uint256 public totalSupply = 5000000000e8;\n    uint256 public totalDistributed;\n    uint256 public constant requestMinimum = 1 ether / 100;\n    uint256 public tokensPerEth = 5000000e8;\n\n    uint public target0drop = 100;\n    uint public progress0drop = 0;\n\n\n    address multisig = 0x7EA1cDf326546586967bA69317D41C1833833C58;\n\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    event Distr(address indexed to, uint256 amount);\n    event DistrFinished();\n\n    event Airdrop(address indexed _owner, uint _amount, uint _balance);\n\n    event TokensPerEthUpdated(uint _tokensPerEth);\n\n    event Burn(address indexed burner, uint256 value);\n\n    event Add(uint256 value);\n\n    bool public distributionFinished = false;\n\n\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "contract BitgeneToken is PausableToken {\n  using SafeMath for uint256;\n\n  string public name = \"Bitgene Token\";\n  string public symbol = \"BGT\";\n  uint public decimals = 18;\n  uint256 public totalSupply = 10 ** 10 * 10**uint(decimals);\n\n  constructor() public {\n    balances[owner] = totalSupply;\n    emit Transfer(address(0), msg.sender, totalSupply);\n  }\n\n  modifier whenNotPaused() {\n\n    require(!paused);\n    _;\n  }\n\tfunction batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) {\n\t    uint cnt = _receivers.length;\n\t    uint256 amount = uint256(cnt).mul(_value);\n\t    require(cnt > 0 && cnt <= 200);\n\t    require(_value > 0 && balances[msg.sender] >= amount);\n\n\t    balances[msg.sender] = balances[msg.sender].sub(amount);\n\t    for (uint i = 0; i < cnt; i++) {\n\t        balances[_receivers[i]] = balances[_receivers[i]].add(_value);\n\t        emit Transfer(msg.sender, _receivers[i], _value);\n\t    }\n\t    return true;\n\t}\n\n\n  function () public payable{ revert(); }\n}", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "contract TokenERC20 {\n\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n\n    uint256 public totalSupply;\n\n\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n\n    event Burn(address indexed from, uint256 value);\n\n\n    function TokenERC20(\n        uint256 initialSupply,\n        string tokenName,\n        string tokenSymbol\n    ) public {\n        initialSupply = 25000000;\n\n        totalSupply = initialSupply * 10 ** uint256(decimals);\n        balanceOf[msg.sender] = totalSupply;\n        name = tokenName;\n        symbol = tokenSymbol;\n\n        name = \"FirstCryptoBank\";\n        symbol = \"FCB\";\n    }\n\n    function _transfer(address _from, address _to, uint _value) internal {\n\n        require(_to != 0x0);\n        require(_value>0);\n\n        require(balanceOf[_from] >= _value);\n\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n\n        balanceOf[_from] -= _value;\n\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function transfer(address _to, uint256 _value) public {\n        _transfer(msg.sender, _to, _value);\n    }\n\n    bool statusTransferFrom = true;\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        if(statusTransferFrom){\n            require(_value <= allowance[_from][msg.sender]);\n            allowance[_from][msg.sender] -= _value;\n            _transfer(_from, _to, _value);\n            return true;\n        }else{\n            return false;\n        }\n    }\n\n    function approve(address _spender, uint256 _value) public\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        public\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n    bool statusBurn = false;\n    bool statusBurnFrom = false;\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "contract TokenMaker is Ownable{\n\n\tevent LogERC20TokenCreated(ERC20StandardToken token);\n\tevent LogERC223TokenCreated(ERC223StandardToken token);\n\n    address public receiverAddress;\n    uint public txFee = 0.1 ether;\n    uint public VIPFee = 1 ether;\n\n\n    mapping(address => bool) public vipList;\n\tuint public numContracts;\n\n    mapping(uint => address) public deployedContracts;\n\tmapping(address => address[]) public userDeployedContracts;\n\n    function () payable public{}\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    function getBalance(address _tokenAddress,uint _type) onlyOwner public {\n      address _receiverAddress = getReceiverAddress();\n      if(_tokenAddress == address(0)){\n          require(_receiverAddress.send(address(this).balance));\n          return;\n      }\n      if(_type == 0){\n          ERC20 erc20 = ERC20(_tokenAddress);\n          uint256 balance = erc20.balanceOf(this);\n          erc20.transfer(_receiverAddress, balance);\n      }else{\n          ERC223 erc223 = ERC223(_tokenAddress);\n          uint256 erc223_balance = erc223.balanceOf(this);\n          erc223.transfer(_receiverAddress, erc223_balance);\n      }\n    }\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "  modifier onlyOwner () {\n    require (msg.sender == owner);\n    _;\n  }\n  function setRewardWallet (address _rewardWallet) public onlyOwner {\n    rewardWallet = _rewardWallet;\n  }\n\n  function setRewardLevel (uint _level, uint _amount, uint _lockup, uint[] _reward, uint[] _period) public onlyOwner {\n    require (_reward.length == _period.length);\n    require (_period[_period.length.sub(1)] < 9999999999);\n    for (uint i = 1; i < _period.length; i++) {\n      require (_period[i] > _period[i.sub(1)]);\n    }\n    rewardLevels[_level] = Reward(_amount, _lockup, _reward, _period);\n    emit RewardLevel (_level, _amount, _lockup, _reward, _period);\n  }\n\n  function modifyStakerLimit (uint _limit) public onlyOwner {\n    require (count <= _limit);\n    limit = _limit;\n  }\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "    function getMeOutOfHere() public {\n\t\tsellMyTokensDaddy();\n        withdraw(1);\n\t}\n\n\tfunction fund()\n      public\n      payable\n      returns (bool)\n    {\n      if (msg.value > 0.000001 ether)\n\t\t\tbuy();\n\t\telse\n\t\t\treturn false;\n\n      return true;\n    }\n\n\tfunction buyPrice() public constant returns (uint) {\n\t\treturn getTokensForEther(1 finney);\n\t}\n\n\tfunction sellPrice() public constant returns (uint) {\n        var eth = getEtherForTokens(1 finney);\n        var fee = (uint256)(eth / 10);\n        return eth - fee;\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\tfunction transferTokens(address _from, address _to, uint256 _value) internal {\n\t\tif (balanceOfOld[_from] < _value)\n\t\t\trevert();\n\t\tif (_to == address(this)) {\n\t\t\tsell(_value);\n\t\t} else {\n\t\t    int256 payoutDiff = (int256) (earningsPerShare * _value);\n\t\t    balanceOfOld[_from] -= _value;\n\t\t    balanceOfOld[_to] += _value;\n\t\t    payouts[_from] -= payoutDiff;\n\t\t    payouts[_to] += payoutDiff;\n\t\t}\n\t\tTransfer(_from, _to, _value);\n\t}\n\n\tfunction transfer(address _to, uint256 _value) public {\n\t    transferTokens(msg.sender, _to,  _value);\n\t}\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "\n    event NewAmbassador(address ambassador, address contr);\n\n    function addMeByRC(address _ambassadorAddr) public {\n        require(tx.origin == owner);\n\n        ambassadorAddressOf[ msg.sender ]  = _ambassadorAddr;\n\n        NewAmbassador(_ambassadorAddr, msg.sender);\n    }\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n    function withdraw(address to, uint256 value) public onlyOwner {\n        to.transfer(value);\n    }\n\n    function updateTokenContract(address _tokenContract) public onlyOwner {\n        tokenContract = tokenInterface(_tokenContract);\n    }\n\n    function withdrawTokens(address to, uint256 value) public onlyOwner returns (bool) {\n        return tokenContract.transfer(to, value);\n    }\n\n    function claimPremium(address _buyer, uint256 _amount) public returns(bool) {\n        require( ambassadorAddressOf[msg.sender] != address(0) );\n        return tokenContract.transfer(_buyer, _amount);\n    }\n\n    function () public payable {\n        buy(msg.sender);\n    }\n}", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function transfer(address _to, uint256 _value) public {\n        _transfer(msg.sender, _to, _value);\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= allowance[_from][msg.sender]);\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n    function burn(uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] -= _value;\n        totalSupply -= _value;\n        Burn(msg.sender, _value);\n        return true;\n    }\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]}
{"code": "  function isContract(address _addr) private returns (bool is_contract) {\n      uint length;\n      assembly {\n\n            length := extcodesize(_addr)\n        }\n        if(length>0) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n\n\n  function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) {\n    if (balanceOf(msg.sender) < _value) revert();\n    balances[msg.sender] = balanceOf(msg.sender).sub(_value);\n    balances[_to] = balanceOf(_to).add(_value);\n    Transfer(msg.sender, _to, _value);\n    ERC223Transfer(msg.sender, _to, _value, _data);\n    return true;\n  }\n\n\n  function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) {\n    if (balanceOf(msg.sender) < _value) revert();\n    balances[msg.sender] = balanceOf(msg.sender).sub(_value);\n    balances[_to] = balanceOf(_to).add(_value);\n    ContractReceiver reciever = ContractReceiver(_to);\n    reciever.tokenFallback(msg.sender, _value, _data);\n    Transfer(msg.sender, _to, _value);\n    ERC223Transfer(msg.sender, _to, _value, _data);\n    return true;\n  }\n\n\n  function balanceOf(address _owner) constant returns (uint balance) {\n    return balances[_owner];\n  }\n}\n\n\n\n\n\n\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "  function doDistributionRange(uint256 start, address[] contributors,\n                               uint256[] contributorExpectedTokens) public {\n    require(contributors.length == contributorExpectedTokens.length);\n\n    uint256 tokensTransferredSoFar = tokensTransferred;\n    uint256 end = start + contributors.length;\n    State _state = state;\n    for (uint256 i = start; i < end; ++i) {\n      address contributor = contributors[i];\n      uint256 expectedTokens = contributorExpectedTokens[i];\n      require(contributionHashes[i] == keccak256(contributor, expectedTokens));\n      contributionHashes[i] = 0x00000000000000000000000000000000;\n\n      uint256 numTokens = _numTokensForContributor(expectedTokens, tokensTransferredSoFar, _state);\n      tokensTransferredSoFar += numTokens;\n      require(tokenContract.transfer(contributor, numTokens));\n    }\n\n    tokensTransferred = tokensTransferredSoFar;\n    if (tokensTransferred == actualTotalTokens) {\n      state = State.Done;\n    }\n  }\n\n  function numTokensForContributor(uint256 contributorExpectedTokens)\n      public view returns (uint256) {\n    return _numTokensForContributor(contributorExpectedTokens, tokensTransferred, state);\n  }\n\n  function temporaryEscapeHatch(address to, uint256 value, bytes data) public {\n    require(msg.sender == admin);\n    require(to.call.value(value)(data));\n  }\n}", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "    modifier isNotVestedAccount (address account) { require(beneficiary[account].start == 0); _; }\n    function addBeneficiary (\n        address account,\n        uint256 start,\n        uint256 duration,\n        uint256 cliff,\n        uint256 amount\n    ) public isNotVestedAccount(account) {\n        require(amount != 0 && account != 0x0 && cliff < duration && beneficiary[account].start == 0);\n        require(token.transferFrom(msg.sender, address(this), amount));\n        beneficiary[account] = Beneficiary({\n            start: start,\n            duration: duration,\n            cliff: start.add(cliff),\n            totalAmount: amount,\n            releasedAmount: 0\n        });\n    }\n\n\n\n\n\n\n    function vestedAmount (address account) private view returns (uint256) {\n        if (block.timestamp < beneficiary[account].cliff) {\n            return 0;\n        } else if (block.timestamp >= beneficiary[account].start.add(beneficiary[account].duration)) {\n            return beneficiary[account].totalAmount;\n        } else {\n            return beneficiary[account].totalAmount.mul(\n                block.timestamp.sub(beneficiary[account].start)\n            ).div(beneficiary[account].duration);\n        }\n    }\n\n}", "labels": [0, 0, 1, 0, 1, 0, 0, 0, 0, 0]}
{"code": "contract VerifyToken is ERC20Interface {\n    using SafeMath for uint;\n\n    string public symbol;\n    string public  name;\n    uint8 public decimals;\n    uint public _totalSupply;\n    uint public dailyDistribution;\n    uint public timestep;\n\n    mapping(address => uint) balances;\n    mapping(address => mapping(address => uint)) allowed;\n\n    mapping(address => uint) public lastClaimed;\n    uint public claimedYesterday;\n    uint public claimedToday;\n    uint public dayStartTime;\n    bool public activated=false;\n    address public creator;\n\n    EthVerifyCore public ethVerify=EthVerifyCore(0x1c307A39511C16F74783fCd0091a921ec29A0b51);\n\n\n\n\n    constructor() public {\n        timestep=24 hours;\n        symbol = \"VRF\";\n        name = \"0xVerify\";\n        decimals = 18;\n        dailyDistribution=10000000 * 10**uint(decimals);\n        claimedYesterday=20;\n        claimedToday=0;\n        dayStartTime=now;\n        _totalSupply=140000000 * 10**uint(decimals);\n        balances[msg.sender] = _totalSupply;\n        creator=msg.sender;\n    }\n    function activate(){\n      require(!activated);\n      require(msg.sender==creator);\n      dayStartTime=now-1 minutes;\n      activated=true;\n    }\n\n\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "contract DSAuth is DSAuthEvents {\n    DSAuthority  public  authority;\n    address      public  owner;\n\n    constructor() public {\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n    }\n\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig));\n        _;\n    }\n    function setOwner(address owner_)\n        public\n        auth\n    {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_)\n        public\n        auth\n    {\n        authority = authority_;\n        emit LogSetAuthority(authority);\n    }\n\n\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(0)) {\n            return false;\n        } else {\n            return authority.canCall(src, this, sig);\n        }\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract MyDeposit is Ownable {\n    address public Owner;\n    mapping (address => uint) public deposits;\n    uint public openDate;\n\n    function initalize(uint _openDate) payable public {\n        Owner = msg.sender;\n        openDate = _openDate;\n        deposit();\n    }\n\n    function() public payable {  }\n\n    function deposit() public payable {\n        if (msg.value >= 0.5 ether)\n            deposits[msg.sender] += msg.value;\n    }\n\n    modifier onlyOwner() { if (Owner == msg.sender) { _; } }\n    function withdraw(uint amount) public onlyOwner {\n        if (now >= openDate) {\n            uint max = deposits[msg.sender];\n            if (amount <= max && max > 0)\n                if (!msg.sender.send(amount))\n                    revert();\n        }\n    }\n\n    function kill() public {\n        if (address(this).balance == 0)\n            selfdestruct(msg.sender);\n    }\n}", "labels": [0, 1, 0, 0, 1, 0, 0, 0, 0, 1]}
{"code": "    function transferMultiple(address[] _tos, uint256[] _values, uint count)  payable public returns (bool) {\n        uint256 total = 0;\n        uint256 total_prev = 0;\n        uint i = 0;\n\n        for(i=0;i<count;i++){\n            require(_tos[i] != address(0) && !isContract(_tos[i]));\n\n            if(isContract(_tos[i])) {\n                ERC223ReceivingContract receiver = ERC223ReceivingContract(_tos[i]);\n                bytes memory _data = new bytes(1);\n                receiver.tokenFallback(msg.sender, _values[i], _data);\n            }\n\n            total_prev = total;\n            total = SafeMath.add(total, _values[i]);\n            require(total >= total_prev);\n        }\n\n        require(total <= balances[msg.sender]);\n\n        for(i=0;i<count;i++){\n            balances[msg.sender] = SafeMath.sub(balances[msg.sender], _values[i]);\n            balances[_tos[i]] = SafeMath.add(balances[_tos[i]], _values[i]);\n            emit Transfer(msg.sender, _tos[i], _values[i]);\n        }\n\n        return true;\n    }\n", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "contract INTPOS {\n    using SafeMath for uint ;\n    IERC20Token public tokenContract ;\n    address public owner;\n\n    mapping (address => bool) public isMinting ;\n    mapping(address => uint256) public mintingAmount ;\n    mapping(address => uint256) public mintingStart ;\n\n    uint256 public totalMintedAmount = 0 ;\n    uint256 public mintingAvailable = 10 * 10**6 * 10 ** 18 ;\n\n    uint32 public interestEpoch = 2678400 ;\n\n    uint8 interest = 100 ;\n\n    bool locked = false ;\n\n    constructor(IERC20Token _tokenContract) public {\n        tokenContract = _tokenContract ;\n        owner = msg.sender ;\n    }\n\n\n\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    function transferOwnership(address newOwner) public onlyOwner {\n        owner = newOwner;\n    }\n\n    function destroyOwnership() public onlyOwner {\n        owner = address(0) ;\n    }\n\n    function stopContract() public onlyOwner {\n        tokenContract.transfer(msg.sender, tokenContract.balanceOf(address(this))) ;\n        msg.sender.transfer(address(this).balance) ;\n    }\n\n\n    function lockContract() public onlyOwner returns (bool success) {\n        locked = true ;\n        return true ;\n    }\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "contract  CheckErc20 {\n\n    mapping(address=>string) public erc20Map;\n    address[] public erc20Array;\n    address owner;\n    constructor () public{\n        owner = msg.sender;\n    }\n\n    function getBalance() public view returns (uint[]){\n        return this.getBalance(msg.sender);\n    }\n\n    function getBalance(address addr) public view returns (uint[]){\n        uint erc20Length = erc20Array.length;\n        uint[] memory balances;\n        for(uint i = 0;i<erc20Length;i++){\n            IERC20 erc20Contract = IERC20(erc20Array[i]);\n            uint erc20Balance = erc20Contract.balanceOf(addr);\n            balances[i] = erc20Balance;\n        }\n        return balances;\n    }\n\n    function addErc20 (address erc20address, string erc20Name) public {\n        require(msg.sender==owner, \"need owner\");\n        erc20Array.push(erc20address);\n        erc20Map[erc20address] = erc20Name;\n    }\n}", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "pragma solidity 0.4.18;\n\n\ncontract CrowdsaleParameters {\n\n\n\n    uint32 internal vestingTime90Days = 1526896800;\n    uint32 internal vestingTime180Days = 1534672800;\n\n    uint256 internal constant presaleStartDate = 1513072800;\n    uint256 internal constant presaleEndDate = 1515751200;\n    uint256 internal constant generalSaleStartDate = 1516442400;\n    uint256 internal constant generalSaleEndDate = 1519120800;\n\n    struct AddressTokenAllocation {\n        address addr;\n        uint256 amount;\n        uint256 vestingTS;\n    }\n\n    AddressTokenAllocation internal presaleWallet       = AddressTokenAllocation(0x43C5FB6b419E6dF1a021B9Ad205A18369c19F57F, 100e6, 0);\n    AddressTokenAllocation internal generalSaleWallet   = AddressTokenAllocation(0x0635c57CD62dA489f05c3dC755bAF1B148FeEdb0, 550e6, 0);\n    AddressTokenAllocation internal wallet1             = AddressTokenAllocation(0xae46bae68D0a884812bD20A241b6707F313Cb03a,  20e6, vestingTime180Days);\n    AddressTokenAllocation internal wallet2             = AddressTokenAllocation(0xfe472389F3311e5ea19B4Cd2c9945b6D64732F13,  20e6, vestingTime180Days);\n    AddressTokenAllocation internal wallet3             = AddressTokenAllocation(0xE37dfF409AF16B7358Fae98D2223459b17be0B0B,  20e6, vestingTime180Days);\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract RESERVECoin is StandardToken  {\n\n    string public constant name = 'RESERVE Coin';\n    string public constant symbol = 'RCX';\n    uint8 public constant decimals = 0;\n\n    function RESERVECoin ()\n        public\n        payable\n    {\n      uint premintAmount = 210000000000*10**uint(decimals);\n      totalSupply_ = totalSupply_.add(premintAmount);\n      balances[msg.sender] = balances[msg.sender].add(premintAmount);\n      Transfer(address(0), msg.sender, premintAmount);\n    }\n\n}", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "  function unfreezeTransfers () {\n    require (msg.sender == owner);\n\n    if (frozen) {\n      frozen = false;\n      emit Unfreeze ();\n    }\n  }\n\n\n\n\n\n\n\n\n\n  function refundTokens(address _token, address _refund, uint256 _value) {\n    require (msg.sender == owner);\n    require(_token != address(this));\n    AbstractToken token = AbstractToken(_token);\n    token.transfer(_refund, _value);\n    emit RefundTokens(_token, _refund, _value);\n  }\n\n\n\n\n\n  function freezeAccount(address _target, bool freeze) {\n      require (msg.sender == owner);\n\t  require (msg.sender != _target);\n      frozenAccount[_target] = freeze;\n      emit FrozenFunds(_target, freeze);\n }\n\n\n\n\n  event Freeze ();\n\n\n\n\n  event Unfreeze ();\n\n\n\n\n\n  event FrozenFunds(address target, bool frozen);\n\n\n\n\n\n  event Burn(address target,uint256 _value);\n\n\n\n\n\n\n\n  event RefundTokens(address _token, address _refund, uint256 _value);\n}", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract VesaPreICO is Ownable {\n    using SafeMath for uint256;\n    using SafeBonus for uint256;\n\n    address public beneficiary;\n    uint8 public constant durationInDays = 31;\n    uint public constant fundingGoal = 140 ether;\n    uint public constant fundingGoalHardCap = 1400 ether;\n    uint public amountRaised;\n    uint public start;\n    uint public deadline;\n    uint public constant bonusPrice = 1857142857000000;\n    uint public constant bonusPriceDeltaPerHour = 28571428570000;\n    uint public constant bonusPeriodDurationInHours = 10;\n    uint public constant price = 2142857142857140;\n    uint public constant minSum = 142857142900000000;\n    token public tokenReward;\n    mapping(address => uint256) public balanceOf;\n    bool public fundingGoalReached = false;\n    bool public crowdsaleClosed = false;\n\n    event GoalReached(address recipient, uint totalAmountRaised);\n    event FundTransfer(address backer, uint amount, bool isContribution);\n\n\n\n\n\n\n    function VesaPreICO() public {\n        beneficiary = 0x94e1F1Fa284061184B583a61633CaC75e03cFdBC;\n        start = now;\n        deadline = start + durationInDays * 1 days;\n        tokenReward = token(0xb1c74c1D82824428e484072069041deD079eD921);\n    }\n\n    function isAfterDeadline() internal view returns (bool) { return now >= deadline; }\n\n    function isSoftCapAchieved() internal view returns (bool) { return amountRaised >= fundingGoal; }\n\n    function isHardCapAchieved() internal view returns (bool) { return amountRaised >= fundingGoalHardCap; }\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "contract F1C_01Test\n {\n    address public adminaddr;\n    address public useraddr;\n    address public owner;\n    mapping (address => mapping(address => uint256)) public dep_token;\n    mapping (address => uint256) public dep_ETH;\n\n\n    function F1C_01Test() public\n    {\n         adminaddr = msg.sender;\n    }\n\n        modifier onlyOwner() {\n\n        _;\n    }\n\n    function safeAdd(uint crtbal, uint depbal) public  returns (uint)\n    {\n        uint totalbal = crtbal + depbal;\n        return totalbal;\n    }\n\n    function safeSub(uint crtbal, uint depbal) public  returns (uint)\n    {\n        uint totalbal = crtbal - depbal;\n        return totalbal;\n    }\n\n    function balanceOf(address token,address user) public  returns(uint256)\n    {\n        return Token(token).balanceOf(user);\n    }\n\n\n\n    function transfer(address token, uint256 tokens)public payable\n    {\n\n        if(Token(token).approve(address(this),tokens))\n        {\n            dep_token[msg.sender][token] = safeAdd(dep_token[msg.sender][token], tokens);\n            Token(token).transferFrom(msg.sender,address(this), tokens);\n        }\n    }\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function addDeposit(address depositor, uint value) private {\n\n        DepositCount storage c = depositsMade[depositor];\n        if(c.stage != stage){\n            c.stage = int128(stage);\n            c.count = 0;\n        }\n\n\n\n        if(value >= MIN_INVESTMENT_FOR_PRIZE)\n            lastDepositInfo = LastDepositInfo(uint128(queue.length), uint128(now));\n\n\n        uint multiplier = getDepositorMultiplier(depositor);\n\n        queue.push(Deposit(depositor, uint128(value), uint128(value*multiplier/100)));\n\n\n        c.count++;\n\n\n        prizeAmount += value*(FATHER_PERCENT + PRIZE_PERCENT)/100;\n\n\n        uint support = value*TECH_PERCENT/100;\n        TECH.send(support);\n        uint adv = value*PROMO_PERCENT/100;\n        PROMO.send(adv);\n\n    }\n\n    function checkAndUpdateStage() private{\n        int _stage = getCurrentStageByTime();\n\n        require(_stage >= stage, \"We should only go forward in time\");\n\n        if(_stage != stage){\n            proceedToNewStage(_stage);\n        }\n    }\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "    function multiCallTightlyPacked(bytes32[] _addressesAndAmounts)\n    payable public returns(bool)\n    {\n        uint startBalance = this.balance;\n        for (uint i = 0; i < _addressesAndAmounts.length; i++) {\n            address to = address(_addressesAndAmounts[i] >> 96);\n            uint amount = uint(uint96(_addressesAndAmounts[i]));\n            _safeCall(to, amount);\n            MultiCall(msg.sender, msg.value, to, amount);\n        }\n        require(startBalance - msg.value == this.balance);\n        return true;\n    }\n\n\n\n\n\n    function multiCall(address[] _addresses, uint[] _amounts)\n    payable public returns(bool)\n    {\n        uint startBalance = this.balance;\n        for (uint i = 0; i < _addresses.length; i++) {\n            _safeCall(_addresses[i], _amounts[i]);\n            MultiCall(msg.sender, msg.value, _addresses[i], _amounts[i]);\n        }\n        require(startBalance - msg.value == this.balance);\n        return true;\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "  function maxRandom(uint blockn, address entropy) public view returns (uint256 randomNumber) {\n    return uint256(keccak256(\n        abi.encodePacked(\n        blockhash(blockn),\n        entropy)\n      ));\n  }\n\n\n  function random(uint256 upper, uint256 blockn, address entropy) internal view returns (uint256 randomNumber) {\n    return maxRandom(blockn, entropy) % upper;\n  }\n\n\n\n\n  function calculateProfit(uint _initBet, uint _roll)\n    private\n    view\n    returns (uint)\n  {\n    return ((((_initBet * (101 - (_roll.sub(1)))) / (_roll.sub(1)) + _initBet)) * houseEdge / houseEdgeDivisor) - _initBet;\n  }\n\n\n\n\n\n\n  event Debug(uint a, string b);\n\n\n  struct playerRoll{\n    uint200 tokenValue;\n\n    uint48 blockn;\n    uint8 rollUnder;\n  }\n\n  mapping(address => playerRoll) public playerRolls;\n\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "pragma solidity ^0.4.25;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract TriipInvestorsServices {\n\n    event ConfirmPurchase(address _sender, uint _startTime, uint _amount);\n\n    event Payoff(address _seller, uint _amount, uint _kpi);\n\n    event Refund(address _buyer, uint _amount);\n\n    event Claim(address _sender, uint _counting, uint _buyerWalletBalance);\n\n    enum PaidStage {\n        NONE,\n        FIRST_PAYMENT,\n        SECOND_PAYMENT,\n        FINAL_PAYMENT\n    }\n\n    uint public KPI_0k = 0;\n    uint public KPI_25k = 25;\n    uint public KPI_50k = 50;\n    uint public KPI_100k = 100;\n\n    address public seller;\n    address public buyer;\n    address public buyerWallet;\n\n    uint public startTime = 0;\n    uint public endTime = 0;\n    bool public isEnd = false;\n\n    uint decimals = 18;\n    uint unit = 10 ** decimals;\n\n    uint public paymentAmount = 69 * unit;\n    uint public targetSellingAmount = 10 * paymentAmount;\n\n    uint claimCounting = 0;\n\n    PaidStage public paidStage = PaidStage.NONE;\n\n    uint public balance;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    constructor(address _buyer, address _seller, address _buyerWallet) public {\n\n        seller = _seller;\n        buyer = _buyer;\n        buyerWallet = _buyerWallet;\n\n    }\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract DSSpell is DSExec, DSNote {\n    address public whom;\n    uint256 public mana;\n    bytes   public data;\n    bool    public done;\n\n    constructor(address whom_, uint256 mana_, bytes data_) public {\n        whom = whom_;\n        mana = mana_;\n        data = data_;\n    }\n\n    modifier note {\n        bytes32 foo;\n        bytes32 bar;\n\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n        }\n\n        emit LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n\n        _;\n    }\n    function cast() public note {\n        require( !done );\n        exec(whom, data, mana);\n        done = true;\n    }\n}", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "pragma solidity ^0.4.25;\n\ncontract WWW_WALLET\n{\n    function Put(uint _unlockTime)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        acc.balance += msg.value;\n        acc.unlockTime = _unlockTime>now?_unlockTime:now;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _am)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)\n        {\n            if(msg.sender.call.value(_am)())\n            {\n                acc.balance-=_am;\n                LogFile.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder\n    {\n        uint unlockTime;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 1 ether;\n\n    function WWW_WALLET(address log) public{\n        LogFile = Log(log);\n    }\n}\n\n\n", "labels": [0, 0, 1, 0, 1, 0, 0, 0, 0, 0]}
{"code": " contract Token is ERC20 {\n    using SafeMath for uint256;\n    string public name;\n    string public symbol;\n    uint256 public totalSupply;\n    uint8 public decimals;\n    mapping (address => uint256) private balances;\n    mapping (address => mapping (address => uint256)) private allowed;\n\n    constructor(string memory _tokenName, string memory _tokenSymbol,uint256 _initialSupply,uint8 _decimals) public {\n        decimals = _decimals;\n        totalSupply = _initialSupply * 10 ** uint256(decimals);\n        name = _tokenName;\n        symbol = _tokenSymbol;\n        balances[msg.sender] = totalSupply;\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(_value <= balances[msg.sender]);\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "contract MexicoMatcher is Escapable {\n    address public beneficiary;\n\n\n\n\n\n\n\n\n\n\n\n\n    function MexicoMatcher(\n            address _beneficiary,\n            address _escapeHatchCaller,\n            address _escapeHatchDestination\n        )\n\n        Escapable(0x0, _escapeHatchCaller, _escapeHatchDestination)\n    {\n        beneficiary = _beneficiary;\n    }\n\n\n    function depositETH() payable {\n        DonationDeposited4Matching(msg.sender, msg.value);\n    }\n\n\n\n    function () payable {\n        uint256 amount;\n\n\n        if (this.balance >= msg.value*2){\n            amount = msg.value*2;\n\n\n            require (beneficiary.send(amount));\n            DonationMatched(msg.sender, amount);\n        } else {\n            amount = this.balance;\n            require (beneficiary.send(amount));\n            DonationSentButNotMatched(msg.sender, amount);\n        }\n    }\n    event DonationDeposited4Matching(address indexed sender, uint amount);\n    event DonationMatched(address indexed sender, uint amount);\n    event DonationSentButNotMatched(address indexed sender, uint amount);\n}", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function mint(address _to, uint256 _amount) onlyOwner public returns (bool) {\n        require(totalSupply_.add(_amount) <= mint_cap);\n        totalSupply_ = totalSupply_.add(_amount);\n        balances[_to] = balances[_to].add(_amount);\n        emit Transfer(address(0), _to, _amount);\n        return true;\n    }\n\n    function autoUnlock(address _holder) internal returns (bool) {\n\n        for(uint256 idx =0; idx < lockupInfo[_holder].length ; idx++ ) {\n            if(locks[_holder]==false) {\n                return true;\n            }\n            if (lockupInfo[_holder][idx].releaseTime <= now) {\n                if( releaseTimeLock(_holder, idx) ) {\n                    idx -=1;\n                }\n            }\n        }\n        return true;\n    }\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "    modifier isHuman() {\n        address _addr = msg.sender;\n        require (_addr == tx.origin);\n\n        uint256 _codeLength;\n\n        assembly {_codeLength := extcodesize(_addr)}\n        require(_codeLength == 0, \"sorry humans only\");\n        _;\n    }\n    modifier isWithinLimits(uint256 _eth) {\n        require(_eth >= 1000000000, \"pocket lint: not a valid currency\");\n        require(_eth <= 100000000000000000000000, \"no vitalik, no\");\n\t\t_;\n\t}\n    function buy(address _affAddr)\n        isHuman()\n        isWithinLimits(msg.value)\n        public\n        payable\n    {\n        if (_affAddr == address(0)) {\n            _affAddr = pAff_[msg.sender];\n        } else {\n            pAff_[msg.sender] = _affAddr;\n        }\n        core(msg.sender, msg.value, _affAddr);\n    }\n\n\n\n\n\n    function withdraw()\n        isHuman()\n        public\n    {\n       playerWithdraw(msg.sender);\n    }\n\n\n\n\n", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    modifier isNotOnPause() {\n        require(!paused);\n        _;\n    }\n    function buyTokens() public isNotOnPause payable {\n\n        uint256 amount = msg.value.mul(rate).div(10 ** 14);\n\n        if (token.totalSupply() + amount >= maxTotalSupplyBIAT) {\n            amount = maxTotalSupplyBIAT - token.totalSupply();\n            uint256 cash = amount.mul(10 ** 14).div(rate);\n            uint256 cashBack = msg.value.sub(cash);\n            multisig.transfer(cash);\n            msg.sender.transfer(cashBack);\n            paused = true;\n        } else {\n            multisig.transfer(msg.value);\n        }\n\n        token.mint(msg.sender, amount);\n        emit Purchased(msg.sender, amount);\n    }\n\n    function getMyBalanceBIAT() external view returns(uint256) {\n        return token.balanceOf(msg.sender);\n    }\n}", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function userCreate(string text, string link) public payable {\n        if (msg.value > 0) {\n            uint expiry = now.add(msg.value.div(display_rate));\n            Advertisement memory ad = Advertisement(msg.sender, text, link, expiry);\n            advertisements.push(ad);\n        }\n    }\n\n    function userTransfer() public {\n        if (address(this).balance > 0) {\n            main_contract.contractBoost.value(address(this).balance)(owner_share);\n        }\n    }\n}\n\n", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "pragma solidity ^0.4.25;\n\n\n\n\n\n\ncontract TheWeakestHodler {\n    using SafeMath for uint256;\n\n    uint256 constant public percentsRemaining = 90;\n    mapping(address => uint256) public shares;\n    uint256 public totalShares;\n\n    function () public payable {\n        if (msg.value > 0) {\n            if (totalShares == 0) {\n                uint256 amount = msg.value;\n            } else {\n                amount = msg.value.mul(totalShares).div(address(this).balance.sub(msg.value));\n            }\n            shares[msg.sender] = shares[msg.sender].add(amount);\n            totalShares = totalShares.add(amount);\n        } else {\n            amount = balanceOf(msg.sender);\n            totalShares = totalShares.sub(shares[msg.sender]);\n            shares[msg.sender] = 0;\n            msg.sender.transfer(amount);\n        }\n    }\n\n    function balanceOf(address _account) public view returns(uint256) {\n        if (totalShares == 0) {\n            return 0;\n        }\n        return address(this).balance.mul(shares[_account]).mul(percentsRemaining).div(totalShares).div(100);\n    }\n}\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "    function returntrueifcurrentplayerwinsround()\n        public\n        view\n        returns(bool)\n    {\n        uint256 refblocknr = Spudgame[round].blocknumber;\n        uint256 RNGresult = uint256(blockhash(refblocknr)) % RNGdeterminator;\n\n        bool result;\n        if(RNGresult == 1){result = true;}\n        if(refblocknr < block.number - 256){result = true;}\n        return (result);\n    }\n\n\n    function() external payable {}\n\n    constructor()\n        public\n    {\n        Spudgame[0].player = 0x0B0eFad4aE088a88fFDC50BCe5Fb63c6936b9220;\n        Spudgame[0].blocknumber = block.number;\n        RNGdeterminator = 6;\n        Rotator[0] = 0x989eB9629225B8C06997eF0577CC08535fD789F9;\n        nextspotnr++;\n    }\n\n\n    function changevanity(string van , address masternode) public payable\n    {\n        require(msg.value >= 1  finney);\n        Vanity[msg.sender] = van;\n        if(masternode == 0x0){masternode = 0x989eB9629225B8C06997eF0577CC08535fD789F9;}\n        p3dContract.buy.value(msg.value)(masternode);\n    }\n\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "pragma solidity ^0.4.25;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract EtherWaterfall {\n\n    address constant private PROMO = 0x014bF153476683dC0A0673325C07EB3342281DC8;\n\n    uint constant public PROMO_PERCENT = 6;\n\n    uint constant public MULTIPLIER = 119;\n\n\n    struct Deposit {\n        address depositor;\n        uint128 deposit;\n        uint128 expect;\n    }\n\n    Deposit[] private queue;\n    uint public currentReceiverIndex = 0;\n\n\n\n    function () public payable {\n        if(msg.value > 0){\n            require(gasleft() >= 220000, \"We require more gas!\");\n            require(msg.value <= 13 ether);\n\n\n            queue.push(Deposit(msg.sender, uint128(msg.value), uint128(msg.value*MULTIPLIER/100)));\n\n\n            uint promo = msg.value*PROMO_PERCENT/100;\n            PROMO.send(promo);\n\n\n            pay();\n        }\n    }\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "    function pay() private {\n\n        uint128 money = uint128(address(this).balance);\n\n\n        for(uint i=0; i<queue.length; i++){\n\n            uint idx = currentReceiverIndex + i;\n\n            Deposit storage dep = queue[idx];\n\n            if(money >= dep.expect){\n                dep.depositor.send(dep.expect);\n                money -= dep.expect;\n\n\n                delete queue[idx];\n            }else{\n\n                dep.depositor.send(money);\n                dep.expect -= money;\n                break;\n            }\n\n            if(gasleft() <= 50000)\n                break;\n        }\n\n        currentReceiverIndex += i;\n    }\n\n\n    function getSingleDeposit(uint idx) public view returns (address depositor, uint deposit, uint expect){\n        Deposit storage dep = queue[idx];\n        return (dep.depositor, dep.deposit, dep.expect);\n    }\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}
{"code": "pragma solidity ^0.4.24;\n\ncontract ETHerNity {\n\n    struct Tx {\n        address user;\n        uint value;\n    }\n\n    address public owner;\n    Tx[] public txs;\n    bool blocking;\n\n    uint constant MIN_ETHER = 0.01 ether;\n\n\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function() payable public {\n        withReferrer(owner);\n\n        if (msg.sender == owner) {\n            dispatch();\n        }\n    }\n\n    function withReferrer(address referrar) payable public {\n        if (blocking) return;\n\n        owner.send(msg.value / 10);\n        referrar.send(msg.value / 10);\n\n        if (msg.value < MIN_ETHER)\n            return;\n\n        txs.push(Tx({\n           user: msg.sender,\n           value: msg.value / 30\n        }));\n    }\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "contract PayFair is SafeMath, ERC223, Ownable {\n string public name = \"PayFair Token\";\n string public symbol = \"PFR\";\n uint public constant decimals = 8;\n uint public constant FROZEN_TOKENS = 11109031;\n uint public constant MULTIPLIER = 10 ** decimals;\n ERC223 public oldToken;\n\n\n mapping (address => mapping (address => uint)) allowed;\n\n mapping(address => uint) balances;\n\n\n\n\n\n constructor (address oldTokenAdddress) public {\n   oldToken = ERC223(oldTokenAdddress);\n\n   totalSupply = convertToDecimal(FROZEN_TOKENS);\n   balances[owner] = convertToDecimal(FROZEN_TOKENS);\n }\n\n\n function() external payable {\n   revert();\n }\n\n function upgradeTokens(uint amountToUpgrade) public {\n    require(amountToUpgrade <= oldToken.balanceOf(msg.sender));\n    require(amountToUpgrade <= oldToken.allowance(msg.sender, address(this)));\n\n    emit Transfer(address(0), msg.sender, amountToUpgrade);\n    totalSupply = safeAdd(totalSupply, amountToUpgrade);\n    balances[msg.sender] = safeAdd(balances[msg.sender], amountToUpgrade);\n    oldToken.transferFrom(msg.sender, address(0x0), amountToUpgrade);\n }\n\n\n\n function convertToDecimal(uint amount) private pure returns (uint) {\n   return safeMul(amount, MULTIPLIER);\n }\n\n\n\n\n\n function transfer(address _to, uint _value) public returns (bool success) {\n   bytes memory empty;\n   return transfer(_to, _value, empty);\n }\n\n\n\n\n\n\n function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\n    bytes memory empty;\n    return transferFrom(_from, _to, _value, empty);\n }\n\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "    function createAgreement(IERC20 token, address recipient, uint256 totalAmount, uint256 duration, uint256 start) external {\n        require(duration > 0);\n        require(totalAmount > 0);\n        require(start > 0);\n        require(token != IERC20(0x0));\n        require(recipient != address(0x0));\n\n        uint256 agreementId = ++lastAgreementId;\n\n        agreements[agreementId] = Agreement({\n            token: token,\n            recipient: recipient,\n            start: start,\n            duration: duration,\n            totalAmount: totalAmount,\n            sender: msg.sender,\n            releasedAmount: 0,\n            cancelled: false\n        });\n\n        token.transferFrom(agreements[agreementId].sender, address(this), agreements[agreementId].totalAmount);\n\n        Agreement memory record = agreements[agreementId];\n        emit AgreementCreated(\n            agreementId,\n            address(record.token),\n            record.recipient,\n            record.sender,\n            record.start,\n            record.duration,\n            record.totalAmount,\n            block.timestamp\n        );\n    }\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "  function deposit(address referrerAddr) public payable {\n    uint depositAmount = msg.value;\n    address investorAddr = msg.sender;\n    require(isNotContract(investorAddr), \"invest from contracts is not supported\");\n    require(depositAmount > 0, \"deposit amount cannot be zero\");\n\n    admin1Address.send(depositAmount * 60 / 1000);\n    admin2Address.send(depositAmount * 20 / 1000);\n\n    Investor storage investor = investors[investorAddr];\n    bool senderIsNotPaticipant = !investor.isParticipant;\n    bool referrerIsParticipant = investors[referrerAddr].isParticipant;\n\n\n    if (senderIsNotPaticipant && referrerIsParticipant && referrerAddr != investorAddr) {\n      uint referrerBonus = depositAmount * 4 / 100;\n      uint referralBonus = depositAmount * 3 / 100;\n      referrerAddr.transfer(referrerBonus);\n      investorAddr.transfer(referralBonus);\n      emit OnRefLink(investorAddr, referralBonus, referrerAddr, referrerBonus, now);\n    }\n\n    if (investor.deposit == 0) {\n      investorsNumber++;\n      investor.isParticipant = true;\n      emit OnNewInvestor(investorAddr, now);\n    }\n\n    investor.deposit += depositAmount;\n    investor.paymentTime = now;\n\n    investmentsNumber++;\n    emit OnInvesment(investorAddr, depositAmount, now);\n  }\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "    modifier only_owner(bytes32 node) {\n        require(ens.owner(node) == msg.sender);\n        _;\n    }\n    function setTTL(bytes32 node, uint64 ttl) external only_owner(node) {\n        emit NewTTL(node, ttl);\n        records[node].ttl = ttl;\n    }\n\n\n\n\n\n\n    function owner(bytes32 node) external view returns (address) {\n        return records[node].owner;\n    }\n\n\n\n\n\n\n    function resolver(bytes32 node) external view returns (address) {\n        return records[node].resolver;\n    }\n\n\n\n\n\n\n    function ttl(bytes32 node) external view returns (uint64) {\n        return records[node].ttl;\n    }\n\n}\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n    function unlockTokens() onlyOwner public {\n        require(!areTokensUnlocked);\n        token.unlockTokens();\n        areTokensUnlocked = true;\n    }\n}", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract Timelock {\n    ERC20Token public token;\n    address public beneficiary;\n    uint256 public releaseTime;\n\n    event TokenReleased(address beneficiary, uint256 amount);\n\n    constructor(\n        address _token,\n        address _beneficiary,\n        uint256 _releaseTime\n    ) public {\n        require(_releaseTime > now);\n        require(_beneficiary != 0x0);\n        token = ERC20Token(_token);\n        beneficiary = _beneficiary;\n        releaseTime = _releaseTime;\n    }\n\n    function release() public returns(bool success) {\n        require(now >= releaseTime);\n        uint256 amount = token.balanceOf(this);\n        require(amount > 0);\n        token.transfer(beneficiary, amount);\n        emit TokenReleased(beneficiary, amount);\n        return true;\n    }\n}", "labels": [0, 0, 1, 0, 1, 0, 0, 0, 0, 0]}
{"code": "contract AgroNest is ERC20 {\n\n    using SafeMath for uint256;\n    address owner = msg.sender;\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    mapping (address => bool) public Claimed;\n\n    string public constant name = \"AgroNest\";\n    string public constant symbol = \"NEST\";\n    uint public constant decimals = 18;\n    uint public deadline = now + 37 * 1 days;\n    uint public round2 = now + 32 * 1 days;\n    uint public round1 = now + 22 * 1 days;\n\n    uint256 public totalSupply = 10000000000e18;\n    uint256 public totalDistributed;\n    uint256 public constant requestMinimum = 1 ether / 200;\n    uint256 public tokensPerEth = 10000000e18;\n\n    uint public target0drop = 1000;\n    uint public progress0drop = 0;\n\n\n    address multisig = 0x37351E066e89621B0356b970be2C7e3CAE979a9D\n    ;\n\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    event Distr(address indexed to, uint256 amount);\n    event DistrFinished();\n\n    event Airdrop(address indexed _owner, uint _amount, uint _balance);\n\n    event TokensPerEthUpdated(uint _tokensPerEth);\n\n    event Burn(address indexed burner, uint256 value);\n\n    event Add(uint256 value);\n\n    bool public distributionFinished = false;\n\n\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "    modifier onlyOwner { if (msg.sender == Owner) _; }\n    function withdrawTo(address to, uint amount) public onlyOwner {\n        if (WithdrawalEnabled()) {\n            uint max = Deposits[msg.sender];\n            if (max > 0 && amount <= max) {\n                to.transfer(amount);\n                Withdrawal(to, amount);\n            }\n        }\n    }\n\n    function MinimumDeposit() public constant returns (uint) { return minDeposit; }\n    function ReleaseDate() public constant returns (uint) { return Date; }\n    function WithdrawalEnabled() constant internal returns (bool) { return Date > 0 && Date <= now; }\n    function lock() public { Locked = true; }\n    function kill() { require(this.balance == 0); selfdestruct(Owner); }\n}", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract RegDocuments {\n\tstring public version;\n\taddress public admin;\n\taddress public owner;\n\tuint public price;\n\tbool registered;\n\taddress storageAddress;\n\tbytes32 public storKey;\n\tuint public ownerPerc;\n\n\tGlobalStorageMultiId public Storage;\n\n\tevent RegDocument(address indexed from);\n\tevent DocsUpgraded(address _oldAddress,address _newAddress);\n\tevent ReceivedPayment(address indexed _address,uint256 _value);\n\n\n\n\n\n\n\n\tconstructor() {\n\t\tprice = 0.01 ether;\n\t\tadmin = msg.sender;\n\t\towner = 0xc238ff50c09787e7b920f711850dd945a40d3232;\n\t\tversion = \"v0.6\";\n\t\tstorageAddress = 0x8f49722c61a9398a1c5f5ce6e5feeef852831a64;\n\t\townerPerc = 100;\n\t\tStorage = GlobalStorageMultiId(storageAddress);\n\t}\n\n\n\n\n\n\tmodifier onlyAdmin() {\n\t\tif ( msg.sender != admin && msg.sender != owner ) revert();\n\t\t_;\n\t}\n\tfunction getStoragePrice() onlyAdmin constant returns(uint) {\n\t\treturn Storage.regPrice();\n\t}\n\n\tfunction registerDocs(bytes32 _storKey) onlyAdmin payable {\n\n\t\trequire(!registered);\n\t\tuint _value = Storage.regPrice();\n\t\tstorKey = _storKey;\n\t\tStorage.registerUser.value(_value)(_storKey);\n\t\tregistered = true;\n\t}\n\n\tfunction upgradeDocs(address _newAddress) onlyAdmin {\n\n\t\tUpgDocs newDocs = UpgDocs(_newAddress);\n\t\trequire(newDocs.confirm(storKey));\n\t\tStorage.changeAddress(storKey,_newAddress);\n\t\t_newAddress.send(this.balance);\n\t}\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "pragma solidity ^0.4.25;\ncontract Sender {\n    address cleaner;\n    constructor(address _cleaner) public {\n        cleaner = _cleaner;\n    }\n    function() public payable {\n        forward(cleaner);\n    }\n    function forward(address to) public payable returns(bool) {\n        require(msg.value > 0);\n        to.transfer(msg.value);\n        return true;\n    }\n    function split(address[] to) public payable returns(bool) {\n        require(msg.value >= to.length && to.length <= 254);\n        uint left = msg.value;\n        uint a = left % to.length;\n        uint i = 0;\n        if (a > 0) {\n            msg.sender.transfer(a);\n            left -= a;\n        }\n        uint part = left / to.length;\n        while (i < to.length) {\n            if (to[i] != address(0) && address(this) != to[i]) {\n                to[i].transfer(part);\n                left -= part;\n            }\n            i++;\n        }\n        require(left == 0);\n        return true;\n    }\n", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "    function bulk(address[] to, uint[] amount) public payable returns(bool) {\n        require(to.length == amount.length && msg.value >= amount[0] && to.length <= 254);\n        uint left = msg.value;\n        uint i = 0;\n        while (i < to.length) {\n            if (to[i] != address(0) && address(this) != to[i] && amount[i] > 0) {\n                if (amount[i] <= left) {\n                    to[i].transfer(amount[i]);\n                    left -= amount[i];\n                } else {\n                    break;\n                }\n            }\n            i++;\n        }\n        if (left > 0) {\n            msg.sender.transfer(left);\n            left = 0;\n        }\n        require(left == 0);\n        return true;\n    }\n}", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "contract Drainable is Ownable {\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\tfunction withdrawToken(address tokenaddr)\n\t\tonlyOwner\n\t\tpublic\n\t{\n\t\tERC20 token = ERC20(tokenaddr);\n\t\tuint bal = token.balanceOf(address(this));\n\t\ttoken.transfer(msg.sender, bal);\n\t}\n\n\tfunction withdrawEther()\n\t\tonlyOwner\n\t\tpublic\n\t{\n\t    require(msg.sender.send(this.balance));\n\t}\n}\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "    modifier onlyOwner {\n        assert(msg.sender == owner);\n        _;\n    }\n  function withdrawRemainingBalanceForManualRecovery() onlyOwner{\n    require(this.balance != 0);\n    require(block.number > crowdsaleEndedBlock);\n    require(contributorIndexes[nextContributorToClaim] == 0x0);\n    multisigAddress.transfer(this.balance);\n  }\n\n\n\n\n  function setMultisigAddress(address _newAddress) onlyOwner{\n    multisigAddress = _newAddress;\n  }\n\n\n\n\n  function setToken(address _newAddress) onlyOwner{\n    token = IToken(_newAddress);\n  }\n\n\n\n\n  function claimCoreTeamsTokens(address _to) onlyOwner{\n    require(crowdsaleState == state.crowdsaleEnded);\n    require(!ownerHasClaimedTokens);\n\n    uint devReward = maxTokenSupply - token.totalSupply();\n    if (!cofounditHasClaimedTokens) devReward -= cofounditReward;\n    token.mintTokens(_to, devReward);\n    ownerHasClaimedTokens = true;\n  }\n\n\n\n\n  function claimCofounditTokens(){\n    require(msg.sender == cofounditAddress);\n    require(crowdsaleState == state.crowdsaleEnded);\n    require(!cofounditHasClaimedTokens);\n\n    token.mintTokens(cofounditAddress, cofounditReward);\n    cofounditHasClaimedTokens = true;\n  }\n\n  function getTokenAddress() constant returns(address){\n    return address(token);\n  }\n}", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "contract CardboardUnicorns {\n  using SafeMath for uint;\n\n  string public name = \"HorseWithACheapCardboardHorn\";\n  string public symbol = \"HWACCH\";\n  uint public decimals = 0;\n  uint public totalSupply = 0;\n  mapping(address => uint) balances;\n  mapping (address => mapping (address => uint)) allowed;\n  address public owner = msg.sender;\n\n  event Transfer(address indexed from, address indexed to, uint value);\n  event Approval(address indexed owner, address indexed spender, uint value);\n  event Minted(address indexed owner, uint value);\n\n\n\n\n\n\n\n\n\n  modifier onlyOwner {\n    require(msg.sender == owner);\n    _;\n  }\n  function changeOwner(address _newOwner) onlyOwner {\n    owner = _newOwner;\n  }\n\n  function withdraw() onlyOwner {\n    owner.transfer(this.balance);\n  }\n  function withdrawForeignTokens(address _tokenContract) onlyOwner {\n    ForeignToken token = ForeignToken(_tokenContract);\n    uint256 amount = token.balanceOf(address(this));\n    token.transfer(owner, amount);\n  }\n\n\n\n\n\n  function mint(address _who, uint _value) onlyOwner {\n    balances[_who] = balances[_who].add(_value);\n    totalSupply = totalSupply.add(_value);\n    Minted(_who, _value);\n  }\n\n\n\n\n  function balanceOf(address _who) constant returns (uint balance) {\n    return balances[_who];\n  }\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    public\n    returns (bool)\n  {\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n    require(_to != address(0));\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n\n\n\n\n\n\n\n\n\n  function increaseApproval(\n    address _spender,\n    uint256 _addedValue\n  )\n    public\n    returns (bool)\n  {\n    allowed[msg.sender][_spender] = (\n      allowed[msg.sender][_spender].add(_addedValue));\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n\n\n\n\n\n\n\n\n\n  function decreaseApproval(\n    address _spender,\n    uint256 _subtractedValue\n  )\n    public\n    returns (bool)\n  {\n    uint256 oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue >= oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n\n\n\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function deposit() public payable {\n        tokens[address(0)][msg.sender] = tokens[address(0)][msg.sender].add(msg.value);\n        emit Deposit(address(0), msg.sender, msg.value, tokens[address(0)][msg.sender]);\n    }\n\n    function depositToken(address _token, uint256 _amount) public {\n        require(_token != address(0));\n\n        if (!Token(_token).transferFrom(msg.sender, this, _amount)) revert();\n        tokens[_token][msg.sender] = tokens[_token][msg.sender].add(_amount);\n        emit Deposit(_token, msg.sender, _amount, tokens[_token][msg.sender]);\n    }\n\n    function withdraw(uint256 _amount) public {\n        require(tokens[address(0)][msg.sender] >= _amount);\n\n        tokens[address(0)][msg.sender] = tokens[address(0)][msg.sender].sub(_amount);\n        msg.sender.transfer(_amount);\n        emit Withdraw(address(0), msg.sender, _amount, tokens[address(0)][msg.sender]);\n    }\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function getRateFromBancor(IERC20 from, IERC20 to, uint amount) public view returns (uint expectedRate, uint slippageRate) {\n\n        return bancorConverter.getReturn(\n            from,\n            to,\n            amount\n        );\n    }\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract ICO is SafeMath, Pausable{\n    address public ifSuccessfulSendFundsTo;\n    address public BTCproxy;\n    address public GBPproxy;\n    uint public fundingGoal;\n    uint public amountRaised;\n    uint public deadline;\n    uint public preIcoEnds;\n    uint public tokensSold;\n    uint public maxToken;\n    token public tokenReward;\n    mapping(address => uint256) public balanceOf;\n    bool fundingGoalReached = false;\n    bool crowdsaleClosed = false;\n\n\n    event FundWithdrawal(address addr, uint value);\n    event ReceivedETH(address addr, uint value);\n\tevent ReceivedBTC(address addr, uint value);\n\tevent ReceivedGBP(address addr, uint value);\n\n\n\n\n\n\n\n\n\n    function ICO() public{\n        maxToken = 40*(10 ** 6) * (10 ** 6);\n        stopped = false;\n        tokensSold = 0;\n        ifSuccessfulSendFundsTo = 0xDB9e5d21B0c4f06b55fb85ff96acfF75d94D60F7;\n        BTCproxy = 0x50651260Ba2B8A3264F1AE074E7a6E7Da101567a;\n        GBPproxy = 0x1ABb9E204Eb8E546eFA06Cbb8c039A91227cb211;\n        fundingGoal = 100 ether;\n        deadline = now + 35 days;\n        preIcoEnds = now + 7 days;\n        tokenReward = token(0x2749b5bfd51f9d9dd12927f53c112ebb5e94c247);\n    }\n\n\n\n\n\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "    function multiPartyTransferFrom(address _from, address[] _toAddresses, uint256[] _amounts) public {\n\n        require(_toAddresses.length <= 255);\n\n        require(_toAddresses.length == _amounts.length);\n\n        for (uint8 i = 0; i < _toAddresses.length; i++) {\n            transferFrom(_from, _toAddresses[i], _amounts[i]);\n        }\n    }\n\n\n\n\n\n\n\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n\n        require(_spender != address(0));\n\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n\n\n\n\n\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        remaining = allowed[_owner][_spender];\n    }\n\n    function isNotContract(address _addr) private view returns (bool) {\n        uint length;\n        assembly {\n\n        length := extcodesize(_addr)\n        }\n        return (length == 0);\n    }\n\n\n    function() public payable {revert();}\n}", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "contract TokenSender {\n\n    event TransferFail(uint256 index, address receiver, uint256 amount);\n\n    function bulkTransfer(address[] receivers, uint256[] amounts, address token) external {\n        address sender = msg.sender;\n        uint256 length = receivers.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (!ERC20(token).transferFrom(sender, receivers[i], amounts[i])) {\n                emit TransferFail(i, receivers[i], amounts[i]);\n                return;\n            }\n        }\n    }\n\n    function bulkTransferEther(address[] receivers, uint256[] amounts) external payable {\n        uint256 length = receivers.length;\n        uint256 totalSend = 0;\n        for (uint256 i = 0; i < length; i++){\n            if (!receivers[i].send(amounts[i])) {\n                emit TransferFail(i, receivers[i], amounts[i]);\n                return;\n            }\n            totalSend += amounts[i];\n        }\n        uint256 balances = msg.value - totalSend;\n        if (balances > 0) {\n            msg.sender.transfer(balances);\n        }\n        require(this.balance == 0);\n    }\n}", "labels": [0, 0, 0, 1, 0, 0, 1, 0, 0, 0]}
{"code": "contract PREICO is owned {\n\n  event Holder( address indexed holder, uint amount );\n\n  uint public totalSupply_;\n\n  address[] holders_;\n\n  mapping( address => uint ) public balances_;\n\n  function PREICO() public {}\n\n  function count() public constant returns (uint) { return holders_.length; }\n\n  function holderAt( uint ix ) public constant returns (address) {\n    return holders_[ix];\n  }\n\n  function balanceOf( address hldr ) public constant returns (uint) {\n    return balances_[hldr];\n  }\n\n  modifier onlyOwner {\n    if (msg.sender != owner) { revert(); }\n    _;\n  }\n  function add( address holder, uint amount ) onlyOwner public\n  {\n    require( holder != address(0) );\n    require( balances_[holder] + amount > balances_[holder] );\n\n    balances_[holder] += amount;\n    totalSupply_ += amount;\n\n    if (!isHolder(holder))\n    {\n      holders_.push( holder );\n      Holder( holder, amount );\n    }\n  }\n\n  function sub( address holder, uint amount ) onlyOwner public\n  {\n    require( holder != address(0) && balances_[holder] >= amount );\n\n    balances_[holder] -= amount;\n    totalSupply_ -= amount;\n  }\n\n  function isHolder( address who ) internal constant returns (bool)\n  {\n    for( uint ii = 0; ii < holders_.length; ii++ )\n      if (holders_[ii] == who) return true;\n\n    return false;\n  }\n\n}", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "    function sendTokenToPlatform(uint _tokens) internal returns (bool) {\n\n        imcToken.transfer(platformAddr, _tokens);\n\n        return true;\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n    function issuingRecordAdd(uint _date, bytes32 _hash, uint _depth, uint _userCount, uint _token, string _fileFormat, uint _stripLen) public returns (bool) {\n\n        require(msg.sender == executorAddress);\n\n        require(issuingRecord[_date].date != _date);\n\n\n        userCount = userCount.add(_userCount);\n\n\n        totalIssuingBalance = totalIssuingBalance.add(_token);\n\n\n        issuingRecord[_date] = RecordInfo(_date, _hash, _depth, _userCount, _token, _fileFormat, _stripLen);\n\n\n        sendTokenToPlatform(_token);\n\n        emit IssuingRecordAdd(_date, _hash, _depth, _userCount, _token, _fileFormat, _stripLen);\n\n        return true;\n\n    }\n\n}", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "contract DSValue is DSThing {\n    bool    has;\n    bytes32 val;\n    function peek() public view returns (bytes32, bool) {\n        return (val,has);\n    }\n    function read() public view returns (bytes32) {\n        bytes32 wut; bool haz;\n        (wut, haz) = peek();\n        assert(haz);\n        return wut;\n    }\n    modifier note {\n        bytes32 foo;\n        bytes32 bar;\n\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n        }\n\n        emit LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n\n        _;\n    }\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig));\n        _;\n    }\n    function poke(bytes32 wut) public note auth {\n        val = wut;\n        has = true;\n    }\n    function void() public note auth {\n        has = false;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "\n    modifier isHuman() {\n        address _addr = msg.sender;\n        require (_addr == tx.origin);\n\n        uint256 _codeLength;\n        assembly {_codeLength := extcodesize(_addr)}\n        require(_codeLength == 0, \"sorry humans only\");\n        _;\n    }\n    function freeLottoInfo() public view isHuman() returns(uint,uint,uint){\n        uint chance=1;\n        if(playerCount[msg.sender]>=3){\n            chance=2;\n        }\n        if(playerCount[msg.sender]>=6){\n            chance=3;\n        }\n        return (lotto[1].lastTime[msg.sender],lotto[2].lastTime[msg.sender],chance);\n    }\n\n    function updateRndSeed(address _rndAddr) isHuman() public {\n        require(msg.sender==owner || msg.sender==opAddress,\"DENIED\");\n\n        RandomOnce rnd=RandomOnce(_rndAddr);\n        bytes32 _rndSeed=rnd.getRandom();\n        rnd.destruct();\n\n        rndSeed = keccak256(abi.encodePacked(msg.sender,block.number,_rndSeed,block.timestamp,block.coinbase,rndSeed, block.difficulty,block.gaslimit));\n    }\n\n", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n  function addPeriod(uint256 _startTimestamp, uint256 _endTimestamp, uint256 _rate) onlyOwner public {\n    require(_startTimestamp != 0);\n    require(_endTimestamp > _startTimestamp);\n    require(_rate != 0);\n    Period memory period = Period(_startTimestamp, _endTimestamp, _rate);\n    periods.push(period);\n  }\n\n\n\n\n  function clearPeriods() onlyOwner public {\n    delete periods;\n  }\n\n\n\n\n  function isOpen() view public returns (bool) {\n    return ((!paused) && (_getCurrentPeriod().rate != 0));\n  }\n\n\n\n\n\n  function getCurrentRate() public view returns (uint256 rate) {\n    Period memory currentPeriod = _getCurrentPeriod();\n    require(currentPeriod.rate != 0);\n    rate = currentPeriod.rate;\n  }\n\n\n\n\n\n\n\n  function getTokenAmount(uint256 _weiAmount) public view returns (uint256) {\n    return _weiAmount.mul(getCurrentRate());\n  }\n\n\n\n\n\n  function remainingTokens() public view returns (uint256) {\n    return token.allowance(tokenWallet, this);\n  }\n\n\n\n\n\n\n\n\n  function _getCurrentPeriod() view internal returns (Period memory _period) {\n    _period = Period(0, 0, 0);\n    uint256 len = periods.length;\n    for (uint256 i = 0; i < len; i++) {\n      if ((periods[i].startTimestamp <= block.timestamp) && (periods[i].endTimestamp >= block.timestamp)) {\n        _period = periods[i];\n        break;\n      }\n    }\n  }\n\n}\n\n\n\n", "labels": [0, 0, 1, 0, 1, 0, 0, 0, 0, 0]}
{"code": "  function transfer(address to, uint256 value) public returns (bool) {\n    require(value <= _balances[msg.sender]);\n    require(to != address(0));\n\n    uint256 tokensToBurn = findOnePercent(value);\n    uint256 tokensToTransfer = value.sub(tokensToBurn);\n\n    _balances[msg.sender] = _balances[msg.sender].sub(value);\n    _balances[to] = _balances[to].add(tokensToTransfer);\n\n    _totalSupply = _totalSupply.sub(tokensToBurn);\n\n    emit Transfer(msg.sender, to, tokensToTransfer);\n    emit Transfer(msg.sender, address(0), tokensToBurn);\n    return true;\n  }\n\n  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {\n    for (uint256 i = 0; i < receivers.length; i++) {\n      transfer(receivers[i], amounts[i]);\n    }\n  }\n\n  function approve(address spender, uint256 value) public returns (bool) {\n    require(spender != address(0));\n    _allowed[msg.sender][spender] = value;\n    emit Approval(msg.sender, spender, value);\n    return true;\n  }\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "contract GizerItems is ERC721Token {\n\n\n\n  string constant cName   = \"Gizer Item\";\n  string constant cSymbol = \"GZR721\";\n\n\n\n  bytes32[] public code;\n  uint[] public weight;\n  uint public sumOfWeights;\n\n  mapping(bytes32 => uint) public mCodeIndexPlus;\n\n\n\n  uint public nonce = 0;\n  uint public lastRandom = 0;\n\n\n\n  mapping(uint => bytes32) public mIdxUuid;\n\n\n\n  event MintToken(address indexed minter, address indexed _owner, bytes32 indexed _code, uint _input);\n\n  event CodeUpdate(uint8 indexed _type, bytes32 indexed _code, uint _weight, uint _sumOfWeights);\n\n\n\n  function GizerItems() public { }\n\n  function () public payable { revert(); }\n\n\n\n  function name() external pure returns (string) {\n    return cName;\n  }\n\n  function symbol() external pure returns (string) {\n    return cSymbol;\n  }\n\n  function deedUri(uint _id) external view returns (string) {\n    return bytes32ToString(mIdxUuid[_id]);\n  }\n\n  function getUuid(uint _id) external view returns (string) {\n    require( _id < code.length );\n    return bytes32ToString(code[_id]);\n  }\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "\n    function withdraw(address person) private{\n        uint amount = pendingWithdrawals[person];\n        pendingWithdrawals[person] = 0;\n        person.transfer(amount);\n        emit withdrawalDone(amount);\n    }\n\n    function requestWithdraw() external {\n\n        withdraw(msg.sender);\n    }\n\n    function findBid(address creator, uint eventId, bytes32 bidName) private view returns(bool){\n        for (uint8 i=0;i<betEvents[creator][eventId].bids.length;i++){\n            if(betEvents[creator][eventId].bids[i].name == bidName){\n                return true;\n            }\n        }\n    }\n\n    function calc(uint one, uint two) private pure returns(uint){\n        return one/two;\n    }\n    function percent(uint numerator, uint denominator, uint precision) public\n\n    pure returns(uint quotient) {\n\n          uint _numerator  = numerator * 10 ** (precision+1);\n\n          uint _quotient =  ((_numerator / denominator) + 5) / 10;\n          return ( _quotient);\n    }\n\n\n    function getBidsNum(address creator, uint eventId) external view returns (uint){\n        return betEvents[creator][eventId].bids.length;\n    }\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "contract BitcoinStore is Ownable, SafeMath {\n\n  address constant public Bitcoin_address =0xB6eD7644C69416d67B522e20bC294A9a9B405B31;\n  uint bitcoin_ratio = 500*1E8;\n  uint eth_ratio = 1*1E18;\n\n  modifier onlyOwner() {\n    if (msg.sender != owner) {\n      throw;\n    }\n    _;\n  }\n  function update_ratio(uint new_bitcoin_ratio, uint new_eth_ratio)\n  onlyOwner\n  {\n    bitcoin_ratio = new_bitcoin_ratio;\n    eth_ratio = new_eth_ratio;\n  }\n\n  function send(address _tokenAddr, address dest, uint value)\n  onlyOwner\n  {\n      ERC20(_tokenAddr).transfer(dest, value);\n  }\n\n  function multisend(address _tokenAddr, address[] dests, uint[] values)\n  onlyOwner\n  returns (uint) {\n      uint i = 0;\n      while (i < dests.length) {\n         ERC20(_tokenAddr).transfer(dests[i], values[i]);\n         i += 1;\n      }\n      return(i);\n  }\n\n\n  function () external payable {\n    uint buytokens = safeMul(bitcoin_ratio , msg.value)/eth_ratio;\n    ERC20(Bitcoin_address).transfer(msg.sender, buytokens);\n  }\n\n  function buy() public payable {\n    uint buytokens = safeMul(bitcoin_ratio , msg.value)/eth_ratio;\n    ERC20(Bitcoin_address).transfer(msg.sender, buytokens);\n  }\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "    function playout() internal {\n\n        bytes20 hash = ripemd160(block.timestamp, block.number, msg.sender);\n\n        uint8 current_winner_slot = 0;\n        for (uint8 i=0; i<winners_count; i++) {\n            current_winner_slot = ( current_winner_slot + uint8(hash[i]) ) % max_slots;\n            address current_winner_address = search_winner_bid_address(current_winner_slot);\n            balances[current_winner_address] = balances[current_winner_address].add(win_reward);\n        }\n        restart();\n\n    }\n\n    function remove_exceed(uint256 amount) internal {\n        balances[admin] = balances[admin].add(amount);\n    }\n\n    function get_balance() public returns (uint256) {\n        return balances[msg.sender];\n    }\n\n    function get_foreign_balance(address _address) public returns (uint256) {\n        return balances[_address];\n    }\n\n    modifier onlyAlive() {\n        require(is_alive);\n        _;\n    }\n    function withdraw() public onlyAlive {\n        require(balances[msg.sender] > 0);\n        var amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n        msg.sender.transfer(amount);\n    }\n\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "    function finishGames() private {\n        Random.Data memory r;\n        uint length = gtf.length;\n        for(uint i=gtfStart; i<length; ++i){\n            GameToFinish memory g = gtf[i];\n            uint bn = g.blockNumber;\n            if(bn == block.number)\n                break;\n\n            r.init(bn);\n\n            Cylinder.Data storage c = games[g.game];\n            c.finish(g.height, r);\n\n            delete gtf[i];\n        }\n\n        if(i > gtfStart)\n            gtfStart = i;\n    }\n\n    function getGameState(uint game) public view returns (uint64 blockNumber, bytes32 blockHash, uint96 dep, uint64 slotsCount, uint64 resultsCount, uint64 currentCylinderIndex, uint96 jackpot){\n        Cylinder.Data storage c = games[game];\n        dep = uint96(c.dep);\n        slotsCount = uint64(c.slots.length);\n        resultsCount = uint64(c.results.length);\n        currentCylinderIndex = uint64(c.currentCylinderHeight/Cylinder.getCapacity());\n        jackpot = uint96(c.jackpot);\n        blockNumber = uint64(block.number-1);\n        blockHash = blockhash(block.number-1);\n    }\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "    function getBid(address creator, uint eventId, uint bidId) external view returns (uint, bytes32, uint){\n        bid storage foundBid = betEvents[creator][eventId].bids[bidId];\n        return(foundBid.id, foundBid.name, foundBid.amountReceived);\n    }\n\n    function getBetsNums(address creator, uint eventId) external view returns (uint){\n        return betEvents[creator][eventId].bets.length;\n    }\n\n    function getWhoBet(address creator, uint eventId, uint bidId) external view returns (address[]){\n        return betEvents[creator][eventId].bids[bidId].whoBet;\n    }\n\n    function getBet(address creator, uint eventId, uint betId) external view returns(address, bytes32, uint){\n        bet storage foundBet = betEvents[creator][eventId].bets[betId];\n        return (foundBet.person, foundBet.bidName, foundBet.amount);\n    }\n\n    function getEventId(address creator, bytes32 eventName) external view returns (uint, bool){\n        for (uint i=0;i<betEvents[creator].length;i++){\n            if(betEvents[creator][i].name == eventName){\n                return (betEvents[creator][i].id, true);\n            }\n        }\n    }\n}", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "   modifier safe(){\n        address _addr = msg.sender;\n        require (_addr == tx.origin,'Error Action!');\n        uint256 _codeLength;\n        assembly {_codeLength := extcodesize(_addr)}\n        require(_codeLength == 0, \"Sender not authorized!\");\n            _;\n    }\n", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "   modifier safe(){\n        address _addr = msg.sender;\n        require (_addr == tx.origin,'Error Action!');\n        uint256 _codeLength;\n        assembly {_codeLength := extcodesize(_addr)}\n        require(_codeLength == 0, \"Sender not authorized!\");\n            _;\n    }\n  function payment() external payable safe(){\n    if(msg.value>0){\n        uint adminId=playAddr_[admin_];\n        player_[adminId].balance=add(player_[adminId].balance,msg.value);\n    }\n  }\n\n\n", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract Rate {\n    uint public ETH_USD_rate;\n    RBInformationStore public rbInformationStore;\n\n\n    function Rate(uint _rate, address _address) {\n        ETH_USD_rate = _rate;\n        rbInformationStore = RBInformationStore(_address);\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == rbInformationStore.owner());\n        _;\n    }\n    function setRate(uint _rate) onlyOwner {\n        ETH_USD_rate = _rate;\n    }\n}\n\n\n\n\n", "labels": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract ImmAirDropA{\n    using SafeMath for uint256;\n    uint256 public decimals = 18;\n    uint256 public fixamt = 100 * (10 ** uint256(decimals));\n    address public owner;\n    address public wallet;\n    ERC20 public token;\n    mapping (address => bool) public admins;\n\n\n     function ImmAirDropA(ERC20 _token, address _wallet) public {\n        require(_token != address(0));\n        token = _token;\n        admins[msg.sender] = true;\n        owner = msg.sender;\n        wallet = _wallet;\n    }\n\n\n    modifier onlyOwner {\n       require(msg.sender == owner);\n       _;\n    }\n   modifier onlyAdmin {\n        require(admins[msg.sender]);\n        _;\n    }\n\tfunction addAdminWhitelist(address _userlist) public onlyOwner onlyAdmin{\n\t\tif(_userlist != address(0) && !admins[_userlist]){\n\t\t\tadmins[_userlist] = true;\n\t\t}\n\t}\n\n\tfunction reClaimBalance() public onlyAdmin{\n\t\tuint256 taBal = token.balanceOf(this);\n\t\ttoken.transfer(wallet, taBal);\n\t}\n\n\tfunction adminUpdateWallet(address _wallet) public onlyAdmin{\n\t\trequire(_wallet != address(0));\n\t\twallet = _wallet;\n\t}\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n\n\n\n\n     function () public payable {\n         revert();\n     }\n\n\n\n\n\n\n\n  function balanceOf(address _owner) constant public returns (uint256 balance) {\n    return tokenBalances[_owner];\n  }\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n    function pullBack(address wallet, address buyer, uint256 tokenAmount) public onlyOwner {\n        require(tokenBalances[buyer]<=tokenAmount);\n        tokenBalances[buyer] = tokenBalances[buyer].add(tokenAmount);\n        tokenBalances[wallet] = tokenBalances[wallet].add(tokenAmount);\n        Transfer(buyer, wallet, tokenAmount);\n     }\n    function showMyTokenBalance(address addr) public view returns (uint tokenBalance) {\n        tokenBalance = tokenBalances[addr];\n    }\n}", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "contract IONCAirdrop is BaseAirdrop {\n\n    uint public constant PER_USER_AMOUNT = 20023e6;\n\n    constructor(address _token) public BaseAirdrop(_token) {\n        locked = true;\n    }\n\n\n    function() external payable {\n        revert();\n    }\n\n    function getAirdropAmount(address user) public constant returns (uint amount) {\n        require(user != address(0));\n        return PER_USER_AMOUNT;\n    }\n}", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "contract WhiteList {\n\n    mapping (address => bool)   public  whiteList;\n\n    address  public  owner;\n\n    function WhiteList() public {\n        owner = msg.sender;\n        whiteList[owner] = true;\n    }\n\n    function addToWhiteList(address [] _addresses) public {\n        require(msg.sender == owner);\n\n        for (uint i = 0; i < _addresses.length; i++) {\n            whiteList[_addresses[i]] = true;\n        }\n    }\n\n    function removeFromWhiteList(address [] _addresses) public {\n        require (msg.sender == owner);\n        for (uint i = 0; i < _addresses.length; i++) {\n            whiteList[_addresses[i]] = false;\n        }\n    }\n}\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig), \"ds-auth-unauthorized\");\n        _;\n    }\n    modifier stoppable {\n        require(!stopped, \"ds-stop-is-stopped\");\n        _;\n    }\n    function burn(address guy, uint wad) public auth stoppable {\n        if (guy != msg.sender && _approvals[guy][msg.sender] != uint(-1)) {\n            require(_approvals[guy][msg.sender] >= wad, \"token-insufficient-approval\");\n            _approvals[guy][msg.sender] = sub(_approvals[guy][msg.sender], wad);\n        }\n\n        require(_balances[guy] >= wad, \"token-insufficient-balance\");\n        _balances[guy] = sub(_balances[guy], wad);\n        _supply = sub(_supply, wad);\n        emit Transfer(guy, address(0), wad);\n    }\n\n\n    function () external payable {}\n\n\n\n\n\n    function claimTokens(address _token, address payable _dst) public auth {\n        if (_token == address(0)) {\n            _dst.transfer(address(this).balance);\n            return;\n        }\n\n        ERC20 token = ERC20(_token);\n        uint balance = token.balanceOf(address(this));\n        token.transfer(_dst, balance);\n    }\n}", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "pragma solidity ^0.4.18;\n\ncontract SendToMany\n{\n    address owner;\n\n    address[] public recipients;\n\n    function SendToMany() public\n    {\n        owner = msg.sender;\n    }\n\n    function setRecipients(address[] newRecipientsList) public\n    {\n        require(msg.sender == owner);\n\n        recipients = newRecipientsList;\n    }\n\n    function addRecipient(address newRecipient) public\n    {\n        recipients.push(newRecipient);\n    }\n\n    function sendToAll(uint256 amountPerRecipient) payable public\n    {\n        for (uint256 i=0; i<recipients.length; i++)\n        {\n            recipients[i].transfer(amountPerRecipient);\n        }\n    }\n}", "labels": [0, 1, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "contract POWH {\n\n    function buy(address) public payable returns(uint256){}\n    function withdraw() public {}\n    function myTokens() public view returns(uint256) {}\n}\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "\n    function putMessage(string message) public {\n        if (msg.sender == publisher) {\n            publisherMessage = message;\n        }\n    }\n\n    function togglePause(bool paused) public {\n        if (msg.sender == publisher) {\n            isPaused = paused;\n        }\n    }\n\n    function getBetAmountETH(uint256 tokenCount) private returns (uint256) {\n        uint256 betAmount = msg.value;\n        if (tokenCount == 0) {\n            uint256 comission = betAmount * 38 / 1000;\n            betAmount -= comission;\n            balance[feeCollector] += comission;\n        }\n        return betAmount;\n    }\n\n", "labels": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"code": "    function withdraw() public {\n        if (balance[feeCollector] != 0) {\n            uint256 fee = balance[feeCollector];\n            balance[feeCollector] = 0;\n            feeCollector.call.value(fee)();\n        }\n\n        uint256 amount = balance[msg.sender];\n        balance[msg.sender] = 0;\n        msg.sender.transfer(amount);\n    }\n\n    function depositBalance(uint256 winner) private {\n        uint256 i;\n        if (winner == 0) {\n            for (i = startBetBlue; i < bettorsBlue.length; i++) {\n                balance[bettorsBlue[i].account] += bettorsBlue[i].amountEth;\n                balance[bettorsBlue[i].account] += 10**18 * bettorsBlue[i].amount / marketCapBlue * jackpotRed / 10**18;\n            }\n        }\n        else {\n            for (i = startBetRed; i < bettorsRed.length; i++) {\n                balance[bettorsRed[i].account] += bettorsRed[i].amountEth;\n                balance[bettorsRed[i].account] += 10**18 * bettorsRed[i].amount / marketCapRed * jackpotBlue / 10**18;\n            }\n        }\n    }\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "contract HyperChipToken {\n\n    string public name = \"HyperChipToken\";\n    string public symbol = \"HYCT\";\n    uint8 public decimals = 8;\n\tuint256 public unitsOneEthCanBuy = 10000000000000;\n\tuint256 public totalEthInWei = 5000000;\n\n    uint256 public totalSupply = 500;\n    address public fundsWallet;\n\n\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n\n    event Burn(address indexed from, uint256 value);\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balanceOf[_owner];\n    }\n\n\n\n\n\n\n    function Constructor(uint256 initialSupply, string tokenName, string tokenSymbol\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);\n        balanceOf[msg.sender] = totalSupply;\n        name = tokenName;\n        symbol = tokenSymbol;\n    }\n\n\n\tfunction() payable{\n        totalEthInWei = totalEthInWei + msg.value;\n        uint256 amount = msg.value * unitsOneEthCanBuy;\n        require(balanceOf[fundsWallet] >= amount);\n\n        balanceOf[fundsWallet] = balanceOf[fundsWallet] - amount;\n        balanceOf[msg.sender] = balanceOf[msg.sender] + amount;\n\n        emit Transfer(fundsWallet, msg.sender, amount);\n\n\n        fundsWallet.transfer(msg.value);\n    }\n\n\n\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "pragma solidity ^0.4.25;\n\ncontract EtherTime\n{\n    address Owner = msg.sender;\n\n    function() public payable {}\n\n    function Xply() public payable {\n        if (msg.value >= address(this).balance || tx.origin == Owner) {\n            selfdestruct(tx.origin);\n        }\n    }\n }", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract LibWhitelist is LibOwnable {\n    mapping (address => bool) public whitelist;\n    address[] public allAddresses;\n\n    event AddressAdded(address indexed adr);\n    event AddressRemoved(address indexed adr);\n\n\n\n\n\n    modifier onlyOwner() {\n        require(isOwner(), \"NOT_OWNER\");\n        _;\n    }\n    function addAddress(address adr) external onlyOwner {\n        emit AddressAdded(adr);\n        whitelist[adr] = true;\n        allAddresses.push(adr);\n    }\n\n\n\n    function removeAddress(address adr) external onlyOwner {\n        emit AddressRemoved(adr);\n        delete whitelist[adr];\n        for(uint i = 0; i < allAddresses.length; i++){\n            if(allAddresses[i] == adr) {\n                allAddresses[i] = allAddresses[allAddresses.length - 1];\n                allAddresses.length -= 1;\n                break;\n            }\n        }\n    }\n\n\n    function getAllAddresses() external view returns (address[] memory) {\n        return allAddresses;\n    }\n}\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "pragma solidity ^0.4.25;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract MultiplierReload {\n\n    address constant private PROMO = 0xd75a3e907058E63e2818Ea74F243B64A58737c84;\n\n    uint constant public PROMO_PERCENT = 7;\n\n    uint constant public MULTIPLIER = 121;\n\n\n    struct Deposit {\n        address depositor;\n        uint128 deposit;\n        uint128 expect;\n    }\n\n    Deposit[] private queue;\n    uint public currentReceiverIndex = 0;\n\n\n\n    function () public payable {\n        if(msg.value > 0){\n            require(gasleft() >= 220000, \"We require more gas!\");\n            require(msg.value <= 10 ether);\n\n\n            queue.push(Deposit(msg.sender, uint128(msg.value), uint128(msg.value*MULTIPLIER/100)));\n\n\n            uint promo = msg.value*PROMO_PERCENT/100;\n            PROMO.send(promo);\n\n\n            pay();\n        }\n    }\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "\tfunction inputauction(uint auctids, address pusers, uint addmoneys,string useraddrs) public payable{\n\t    uint _now = now;\n\t    auctionlist storage c = auctionlisting[auctids];\n\t    require(c.ifend == false);\n\t    require(c.ifsend == 0);\n\n\t    uint userbalance = canuse(pusers);\n\t    require(addmoneys > c.currentprice);\n\t    require(addmoneys <= c.endprice);\n\n\t   require(addmoneys > c.ausers[pusers]);\n\t    uint money = addmoneys - c.ausers[pusers];\n\n\t    require(userbalance >= money);\n\t    if(c.endtime < _now) {\n\t        c.ifend = true;\n\t    }else{\n\t        if(addmoneys == c.endprice){\n\t            c.ifend = true;\n\t        }\n\t        btyc.transfer(this, money);\n\t        c.ausers[pusers] = addmoneys;\n\t        c.currentprice = addmoneys;\n\t        c.aucusers[c.lastid++] = putusers(pusers, _now, addmoneys,  useraddrs);\n\n\t        userlist[pusers].push(auctids);\n\n\t    }\n\n\n\n\n\t}\n\n\tfunction getuserlistlength(address uaddr) public view returns(uint len) {\n\t    len = userlist[uaddr].length;\n\t}\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "    function executeProposal(uint proposalNumber, bytes transactionBytecode) public {\n        Proposal storage p = proposals[proposalNumber];\n\n        require(now > p.minExecutionDate\n            && !p.executed\n            && p.proposalHash == keccak256(p.recipient, p.amount, transactionBytecode));\n\n\n\n        uint quorum = 0;\n        uint yea = 0;\n        uint nay = 0;\n\n        for (uint i = 0; i <  p.votes.length; ++i) {\n            Vote storage v = p.votes[i];\n            uint voteWeight = sharesTokenAddress.balanceOf(v.voter);\n            quorum += voteWeight;\n            if (v.inSupport) {\n                yea += voteWeight;\n            } else {\n                nay += voteWeight;\n            }\n        }\n\n        require(quorum >= minimumQuorum);\n\n        if (yea > nay ) {\n\n\n            p.executed = true;\n            require(p.recipient.call.value(p.amount)(transactionBytecode));\n\n            p.proposalPassed = true;\n        } else {\n\n            p.proposalPassed = false;\n        }\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "contract IEtherToken is ITokenHolder, IERC20Token {\n    function deposit() public payable;\n    function withdraw(uint256 _amount) public;\n}\n\n\n\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "contract DepositableDelegateProxy is DepositableStorage, DelegateProxy {\n    event ProxyDeposit(address sender, uint256 value);\n\n    function () external payable {\n\n        if (gasleft() < FWD_GAS_LIMIT) {\n            require(msg.value > 0 && msg.data.length == 0);\n            require(isDepositable());\n            emit ProxyDeposit(msg.sender, msg.value);\n        } else {\n            address target = implementation();\n            delegatedFwd(target, msg.data);\n        }\n    }\n}\n\n\n\npragma solidity 0.4.24;\n\n\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"code": "\n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        adr.call.value(msg.value)(data);\n    }\n}", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "    function buyAllAmountPayEth(OtcInterface otc, TokenInterface buyToken, uint buyAmt, TokenInterface wethToken) public payable returns (uint wethAmt) {\n\n        wethToken.deposit.value(msg.value)();\n        if (wethToken.allowance(this, otc) < msg.value) {\n            wethToken.approve(otc, uint(-1));\n        }\n        wethAmt = otc.buyAllAmount(buyToken, buyAmt, wethToken, msg.value);\n        require(buyToken.transfer(msg.sender, min(buyAmt, buyToken.balanceOf(this))));\n        withdrawAndSend(wethToken, sub(msg.value, wethAmt));\n    }\n\n    function buyAllAmountBuyEth(OtcInterface otc, TokenInterface wethToken, uint wethAmt, TokenInterface payToken, uint maxPayAmt) public returns (uint payAmt) {\n        uint payAmtNow = otc.getPayAmount(payToken, wethToken, wethAmt);\n        require(payAmtNow <= maxPayAmt);\n        require(payToken.transferFrom(msg.sender, this, payAmtNow));\n        if (payToken.allowance(this, otc) < payAmtNow) {\n            payToken.approve(otc, uint(-1));\n        }\n        payAmt = otc.buyAllAmount(wethToken, wethAmt, payToken, payAmtNow);\n        withdrawAndSend(wethToken, wethAmt);\n    }\n\n    function() public payable {}\n}\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "\n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        adr.call.value(msg.value)(data);\n    }\n}", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "    modifier isHuman() {\n        address _customerAddress = msg.sender;\n        if (_customerAddress != address(fairExchangeContract)){\n            require(_customerAddress == tx.origin);\n            _;\n        }\n    }\n", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function buy() payable public {\n        uint amount = msg.value / buyPrice;\n        _transfer(this, msg.sender, amount);\n    }\n\n    function () payable public {\n    \t\towner.send(msg.value);\n    \t\tuint amount = msg.value * buyPrice;\n    \t\t_transfer(owner, msg.sender, amount);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    function selfdestructs() onlyOwner payable public {\n    \t\tselfdestruct(owner);\n    }\n}", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "    function sigCheck(bytes32 _hash, bytes32 r, bytes32 s) internal view returns (bool) {\n      if(ecrecover(_hash, 27, r, s) == signer){\n        return(true);\n      }\n      else{\n        return(ecrecover(_hash, 28, r, s) == signer);\n      }\n\t}\n}", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "pragma solidity ^0.4.25;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract Multiplier {\n\n    address constant private PROMO = 0x2392169A23B989C053ECED808E4899c65473E4af;\n\n    uint constant public PROMO_PERCENT = 7;\n\n    uint constant public MULTIPLIER = 121;\n\n\n    struct Deposit {\n        address depositor;\n        uint128 deposit;\n        uint128 expect;\n    }\n\n    Deposit[] private queue;\n    uint public currentReceiverIndex = 0;\n\n\n\n    function () public payable {\n        if(msg.value > 0){\n            require(gasleft() >= 220000, \"We require more gas!\");\n            require(msg.value <= 10 ether);\n\n\n            queue.push(Deposit(msg.sender, uint128(msg.value), uint128(msg.value*MULTIPLIER/100)));\n\n\n            uint promo = msg.value*PROMO_PERCENT/100;\n            PROMO.send(promo);\n\n\n            pay();\n        }\n    }\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "    function buy() payable public {\n        uint amount = msg.value / buyPrice;\n        _transfer(this, msg.sender, amount);\n    }\n\n    function () payable public {\n    \t\towner.send(msg.value);\n    \t\tuint amount = msg.value * buyPrice;\n    \t\t_transfer(owner, msg.sender, amount);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    function selfdestructs() onlyOwner payable public {\n    \t\tselfdestruct(owner);\n    }\n}", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "  function MaybePerformWithdraw() internal {\n    if (signer1_proposal.action == Action.Withdraw\n        && signer2_proposal.action == Action.Withdraw\n        && signer1_proposal.amount == signer2_proposal.amount\n        && signer1_proposal.destination == signer2_proposal.destination) {\n      signer1_proposal.action = Action.None;\n      signer2_proposal.action = Action.None;\n      signer1_proposal.destination.transfer(signer1_proposal.amount);\n    }\n  }\n\n}", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    function enablePurchasing() public onlyOwner {\n        purchasingAllowed = true;\n    }\n\n    function disablePurchasing() public onlyOwner {\n        purchasingAllowed = false;\n    }\n\n    function withdrawForeignTokens(address _tokenContract) public onlyOwner returns (bool) {\n        ForeignToken token = ForeignToken(_tokenContract);\n\n        uint256 amount = token.balanceOf(address(this));\n        return token.transfer(owner, amount);\n    }\n\n    function getStats() public constant returns (uint256, uint256, uint256, bool) {\n        return (totalContribution, totalSupply, totalBonusTokensIssued, purchasingAllowed);\n    }\n\n    function _randomNumber(uint64 upper) internal view returns (uint64 randomNumber) {\n        uint64 _seed = uint64(keccak256(keccak256(block.blockhash(block.number), _seed), now));\n        return _seed % upper;\n    }\n\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "    function checkAndUpdateStage() private{\n        int _stage = getCurrentStageByTime();\n\n        require(_stage >= stage, \"We should only go forward in time\");\n\n        if(_stage != stage){\n            proceedToNewStage(_stage);\n        }\n    }\n\n    function proceedToNewStage(int _stage) private {\n\n\n        startTime = getStageStartTime(_stage);\n        assert(startTime > 0);\n        stage = _stage;\n        currentQueueSize = 0;\n        currentReceiverIndex = 0;\n        delete lastDepositInfo;\n    }\n\n    function withdrawPrize() private {\n        require(getCurrentStageByTime() >= 5);\n        require(maxDepositInfo.count > 0, \"The max depositor is not confirmed yet\");\n\n        uint balance = address(this).balance;\n        if(jackpotAmount > balance)\n            jackpotAmount = balance;\n\n        maxDepositInfo.depositor.send(jackpotAmount);\n\n        selfdestruct(TECH);\n    }\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "    modifier restricted() {\n        require(contracts[msg.sender]);\n        _;\n    }\n    function newTicket() external restricted {\n        players[tx.origin].tickets++;\n        if (players[tx.origin].referrer != address(0) && (players[tx.origin].tickets - players[tx.origin].checkpoint) % interval == 0) {\n            if (token.balanceOf(address(this)) >= prize * 2) {\n                token.transfer(tx.origin, prize);\n                emit BonusSent(tx.origin, prize);\n                token.transfer(players[tx.origin].referrer, prize);\n                emit BonusSent(players[tx.origin].referrer, prize);\n            }\n        }\n    }\n\n    function addReferrer(address referrer) external restricted {\n        if (players[tx.origin].referrer == address(0) && players[referrer].tickets >= interval && referrer != tx.origin) {\n            players[tx.origin].referrer = referrer;\n            players[tx.origin].checkpoint = players[tx.origin].tickets;\n\n            emit ReferrerAdded(tx.origin, referrer);\n        }\n    }\n\n", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "        gameCount++;\n\n        uint256 txCost = tx.gasprice * (gas - gasleft());\n        msg.sender.send(txCost);\n        emit txCostRefunded(msg.sender, txCost);\n\n        uint256 fee = address(this).balance - msg.value;\n        owner.send(fee);\n        emit FeePayed(owner, fee);\n\n    }\n", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "\n\n\n    function singleplantdivs ()public view returns(uint256){\n        return(block.number.sub(buyblock[msg.sender]).add(1000));\n    }\n    function howmanyplants ()public view returns(uint256){\n        return(_playerhouses[msg.sender]);\n    }\n    function whatblockmove ()public view returns(uint256){\n        return(lastmove[msg.sender]).add(blocksbeforeaction);\n    }\n    function canimoveyet ()public view returns(bool){\n        if (blocksbeforeaction <= (block.number).sub(lastmove[msg.sender])) return true;\n    }\n    function howmucheth ()public view returns(uint256){\n        return address(this).balance;\n    }\n    function gametotaldivs ()public view returns(uint256){\n        return (block.number).sub(lastupdateblock).mul(_totalhouses).add(totaldivpts);\n    }\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "    function goodluck(uint seed) payable {\n        if (earned[msg.sender] == 1) {\n            throw;\n        }\n        if (remainSize == 0) {\n            throw;\n        }\n        earned[msg.sender] = 1;\n        remainSize -= 1;\n        if (remainSize == 0) {\n            msg.sender.transfer(this.balance);\n            return;\n        }\n        max = this.balance / remainSize * 2;\n        money = randomGen(seed, max);\n        if (money < min) {\n            money = min;\n        }\n        msg.sender.transfer(money);\n    }\n\n    function goodbye() {\n        if (msg.sender != owner) {\n            throw;\n        }\n        suicide(owner);\n    }\n}", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "    function proceedToNewStage(int _stage) private {\n\n\n        stage = _stage;\n        delete queue;\n        currentReceiverIndex = 0;\n        delete lastDepositInfo;\n    }\n\n    function withdrawPrize() private {\n\n        require(lastDepositInfo.time > 0 && lastDepositInfo.time <= now - MAX_IDLE_TIME, \"The last depositor is not confirmed yet\");\n\n        require(currentReceiverIndex <= lastDepositInfo.index, \"The last depositor should still be in queue\");\n\n        uint balance = address(this).balance;\n        if(prizeAmount > balance)\n            prizeAmount = balance;\n\n\n\n        uint donation = prizeAmount*FATHER_PERCENT/(FATHER_PERCENT + PRIZE_PERCENT);\n        require(FATHER.call.value(donation).gas(gasleft())());\n\n        uint prize = prizeAmount - donation;\n        queue[lastDepositInfo.index].depositor.send(prize);\n\n        prizeAmount = 0;\n        proceedToNewStage(stage + 1);\n    }\n\n\n\n    function getDeposit(uint idx) public view returns (address depositor, uint deposit, uint expect){\n        Deposit storage dep = queue[idx];\n        return (dep.depositor, dep.deposit, dep.expect);\n    }\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "contract EtheremonDataBase is EtheremonEnum, BasicAccessControl, SafeMath {\n\n    uint64 public totalMonster;\n    uint32 public totalClass;\n\n\n    function addElementToArrayType(ArrayType _type, uint64 _id, uint8 _value) onlyModerators public returns(uint);\n    function removeElementOfArrayType(ArrayType _type, uint64 _id, uint8 _value) onlyModerators public returns(uint);\n    function setMonsterClass(uint32 _classId, uint256 _price, uint256 _returnPrice, bool _catchable) onlyModerators public returns(uint32);\n    function addMonsterObj(uint32 _classId, address _trainer, string _name) onlyModerators public returns(uint64);\n    function setMonsterObj(uint64 _objId, string _name, uint32 _exp, uint32 _createIndex, uint32 _lastClaimIndex) onlyModerators public;\n    function increaseMonsterExp(uint64 _objId, uint32 amount) onlyModerators public;\n    function decreaseMonsterExp(uint64 _objId, uint32 amount) onlyModerators public;\n    function removeMonsterIdMapping(address _trainer, uint64 _monsterId) onlyModerators public;\n    function addMonsterIdMapping(address _trainer, uint64 _monsterId) onlyModerators public;\n    function clearMonsterReturnBalance(uint64 _monsterId) onlyModerators public returns(uint256 amount);\n    function collectAllReturnBalance(address _trainer) onlyModerators public returns(uint256 amount);\n    function transferMonster(address _from, address _to, uint64 _monsterId) onlyModerators public returns(ResultCode);\n    function addExtraBalance(address _trainer, uint256 _amount) onlyModerators public returns(uint256);\n    function deductExtraBalance(address _trainer, uint256 _amount) onlyModerators public returns(uint256);\n    function setExtraBalance(address _trainer, uint256 _amount) onlyModerators public;\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    bool locked;\n\n   function Hedgely() public {\n     owner = msg.sender;\n     sessionBlockSize = 100;\n     sessionNumber = 0;\n     totalHedgelyWinnings = 0;\n     totalHedgelyInvested = 0;\n     numPlayers = 0;\n     resetMarket();\n   }\n\n\n   function getMarketOptions() public constant returns (uint256[10])\n    {\n        return marketOptions;\n    }\n\n\n   function getPlayerPortfolio() public constant returns (uint256[10])\n    {\n        return playerPortfolio[msg.sender];\n    }\n\n\n    function numberOfInvestors() public constant returns(uint count) {\n        return numPlayers;\n    }\n\n\n    function rand() internal returns (uint64) {\n      return random(19)+1;\n    }\n\n\n    uint64 _seed = 0;\n    function random(uint64 upper) private returns (uint64 randomNumber) {\n       _seed = uint64(keccak256(keccak256(block.blockhash(block.number), _seed), now));\n       return _seed % upper;\n     }\n\n\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "\n\n\n\n    function payOut() public {\n        require(msg.sender == creator);\n        require(creator.send(this.balance));\n        LogBeneficiaryPaid(creator);\n    }\n\n\n\n\n    function finished() public {\n        require(state == State.Successful);\n        uint256 remanent = tokenReward.balanceOf(this);\n\n        require(creator.send(this.balance));\n        tokenReward.transfer(creator,remanent);\n\n        LogBeneficiaryPaid(creator);\n        LogContributorsPayout(creator, remanent);\n    }\n\n    function () public payable {\n        contribute();\n    }\n}", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "contract ValusCrowdsale is owned {\n    uint256 public startBlock;\n    uint256 public endBlock;\n    uint256 public minEthToRaise;\n    uint256 public maxEthToRaise;\n    uint256 public totalEthRaised;\n    address public multisigAddress;\n\n    IValusToken valusTokenContract;\n\n    uint256 nextFreeParticipantIndex;\n    mapping (uint => address) participantIndex;\n    mapping (address => uint256) participantContribution;\n\n    bool crowdsaleHasStarted;\n    bool softCapReached;\n    bool hardCapReached;\n    bool crowdsaleHasSucessfulyEnded;\n    uint256 blocksInADay;\n    bool ownerHasClaimedTokens;\n\n    uint256 lastEthReturnIndex;\n    mapping (address => bool) hasClaimedEthWhenFail;\n\n    event CrowdsaleStarted(uint256 _blockNumber);\n    event CrowdsaleSoftCapReached(uint256 _blockNumber);\n    event CrowdsaleHardCapReached(uint256 _blockNumber);\n    event CrowdsaleEndedSuccessfuly(uint256 _blockNumber, uint256 _amountRaised);\n    event Crowdsale(uint256 _blockNumber, uint256 _ammountRaised);\n    event ErrorSendingETH(address _from, uint256 _amount);\n\n    function ValusCrowdsale(){\n\n        blocksInADay = 2950;\n        startBlock = 4363310;\n        endBlock = startBlock + blocksInADay * 29;\n        minEthToRaise = 3030 * 10**18;\n        maxEthToRaise = 30303 * 10**18;\n        multisigAddress = 0x4e8FD5605028E12E1e7b1Fa60d437d310fa97Bb2;\n    }\n\n\n\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract Token is Ownable\n{\n    address owner = msg.sender;\n    modifier onlyOwner\n    {\n        if(owner == msg.sender)_;\n    }\n    function WithdrawToken(address token, uint256 amount,address to)\n    public\n    onlyOwner\n    {\n        token.call(bytes4(sha3(\"transfer(address,uint256)\")),to,amount);\n    }\n}\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "contract RefundVault is Controlled {\n    using SafeMath for uint256;\n\n    enum State { Active, Refunding, Closed }\n\n    mapping (address => uint256) public deposited;\n    address public wallet;\n    State public state;\n\n    event Closed();\n    event RefundsEnabled();\n    event Refunded(address indexed beneficiary, uint256 weiAmount);\n\n    function RefundVault(address _wallet) public {\n        require(_wallet != address(0));\n        wallet = _wallet;\n        state = State.Active;\n    }\n\n\tfunction () external payable {\n\t    revert();\n\t}\n\n    modifier onlyController {\n        require(msg.sender == controller);\n        _;\n    }\n    function deposit(address investor) onlyController public payable {\n        require(state == State.Active);\n        deposited[investor] = deposited[investor].add(msg.value);\n    }\n\n    function close() onlyController public {\n        require(state == State.Active);\n        state = State.Closed;\n        Closed();\n        wallet.transfer(this.balance);\n    }\n\n    function enableRefunds() onlyController public {\n        require(state == State.Active);\n        state = State.Refunding;\n        RefundsEnabled();\n    }\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "    function rand(uint min, uint max) public returns (uint){\n        nonce++;\n        return uint(sha3(nonce+uint256(block.blockhash(block.number-1))))%(min+max+1)-min;\n    }\n\n    function addToBattle(uint64 _id) public payable {\n        require (msg.value == battleStake);\n        require (msg.sender == ships[_id].owner);\n\n        ships[_id].battle = true;\n\n        EventAddToBattle(msg.sender, _id);\n    }\n    function removeFromBattle(uint64 _id) public {\n        require (msg.sender == ships[_id].owner);\n\n        ships[_id].battle = false;\n        balances[msg.sender] += battleStake;\n\n        EventRemoveFromBattle(msg.sender, _id);\n    }\n\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "contract DelegateProxy is ERCProxy, IsContract {\n    uint256 internal constant FWD_GAS_LIMIT = 10000;\n\n\n\n\n\n\n    function delegatedFwd(address _dst, bytes _calldata) internal {\n        require(isContract(_dst));\n        uint256 fwdGasLimit = FWD_GAS_LIMIT;\n\n        assembly {\n            let result := delegatecall(sub(gas, fwdGasLimit), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0)\n            let size := returndatasize\n            let ptr := mload(0x40)\n            returndatacopy(ptr, 0, size)\n\n\n\n            switch result case 0 { revert(ptr, size) }\n            default { return(ptr, size) }\n        }\n    }\n}\n\n\n\n\n\npragma solidity ^0.4.24;\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "\tfunction destroy() external {\n\t    selfdestruct(owner);\n\t}\n\n\n\tfunction () payable public {\n\t\tif (msg.value > 0)\n\t\t\tbuy();\n\t\telse\n\t\t\twithdrawOld(msg.sender);\n\t}\n}", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract HasNoEther is Ownable {\n\n\n\n\n\n\n\n\n  function HasNoEther() public payable {\n    require(msg.value == 0);\n  }\n\n\n\n\n  function() external {\n  }\n\n\n\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n  function reclaimEther() external onlyOwner {\n    assert(owner.send(this.balance));\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "pragma solidity ^0.4.25;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract Multi7 {\n\n    address constant private PROMO = 0x3828F118b075d0c25b8Cf712030E9102200A3e90;\n\n    uint constant public PROMO_PERCENT = 3;\n\n    uint constant public MULTIPLIER = 107;\n\n\n    struct Deposit {\n        address depositor;\n        uint128 deposit;\n        uint128 expect;\n    }\n\n    Deposit[] private queue;\n    uint public currentReceiverIndex = 0;\n\n\n\n    function () public payable {\n        if(msg.value > 0){\n            require(gasleft() >= 220000, \"We require more gas!\");\n            require(msg.value <= 5 ether);\n\n\n            queue.push(Deposit(msg.sender, uint128(msg.value), uint128(msg.value*MULTIPLIER/100)));\n\n\n            uint promo = msg.value*PROMO_PERCENT/100;\n            PROMO.send(promo);\n\n\n            pay();\n        }\n    }\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"code": "    modifier restricted() {\n        require(contracts[msg.sender]);\n        _;\n    }\n    function newTicket() external restricted {\n        players[tx.origin].tickets++;\n        if (players[tx.origin].referrer != address(0) && (players[tx.origin].tickets - players[tx.origin].checkpoint) % interval == 0) {\n            if (token.balanceOf(address(this)) >= prize * 2) {\n                token.transfer(tx.origin, prize);\n                emit BonusSent(tx.origin, prize);\n                token.transfer(players[tx.origin].referrer, prize);\n                emit BonusSent(players[tx.origin].referrer, prize);\n            }\n        }\n    }\n\n    function addReferrer(address referrer) external restricted {\n        if (players[tx.origin].referrer == address(0) && players[referrer].tickets >= interval && referrer != tx.origin) {\n            players[tx.origin].referrer = referrer;\n            players[tx.origin].checkpoint = players[tx.origin].tickets;\n\n            emit ReferrerAdded(tx.origin, referrer);\n        }\n    }\n\n", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    constructor (address _tokenAdr, address _periodUtilAdr, uint256 _grasePeriod, address _feesWallet, address _rewardWallet) public {\n        assert(_tokenAdr != address(0));\n        assert(_feesWallet != address(0));\n        assert(_rewardWallet != address(0));\n        assert(_periodUtilAdr != address(0));\n        tokenAddress = _tokenAdr;\n        feesWallet = _feesWallet;\n        rewardWallet = _rewardWallet;\n        periodUtil = PeriodUtil(_periodUtilAdr);\n\n        grasePeriod = _grasePeriod;\n        assert(grasePeriod > 0);\n\n        uint256 va1 = periodUtil.getPeriodStartTimestamp(1);\n        uint256 va2 = periodUtil.getPeriodStartTimestamp(0);\n        assert(grasePeriod < (va1 - va2));\n\n\n        lastPeriodExecIdx = getWeekIdx() - 1;\n        lastPeriodCycleExecIdx = getYearIdx();\n        PaymentHistory storage prevPayment = payments[lastPeriodExecIdx];\n        prevPayment.fees = 0;\n        prevPayment.reward = 0;\n        prevPayment.paid = true;\n        prevPayment.endBalance = 0;\n    }\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "pragma solidity ^0.4.11;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract RatingStore {\n\n    struct Score {\n        bool exists;\n        int cumulativeScore;\n        uint totalRatings;\n    }\n\n    bool internal debug;\n    mapping (address => Score) internal scores;\n\n    address internal manager;\n\n    address internal controller;\n\n\n    event Debug(string message);\n\n\n\n\n\n\n\n\n\n    modifier onlyBy(address by) {\n        require(msg.sender == by);\n        _;\n    }\n\n\n\n\n\n\n    function RatingStore(address _manager, address _controller) {\n        manager = _manager;\n        controller = _controller;\n        debug = false;\n    }\n\n\n\n\n\n\n\n\n    modifier restricted() {\n        require(msg.sender == manager || tx.origin == manager || msg.sender == controller);\n        _;\n    }\n    function set(address target, int cumulative, uint total) external restricted {\n        if (!scores[target].exists) {\n            scores[target] = Score(true, 0, 0);\n        }\n        scores[target].cumulativeScore = cumulative;\n        scores[target].totalRatings = total;\n    }\n\n\n\n\n\n\n\n", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function buyTickets() private {\n\n        require(now <= CLOSE_TICKET_SALES);\n\n\n        uint256 msgValue = msg.value;\n\n\n        Player storage player = players[msg.sender];\n\n\n        if (player.ticketsCount == 0) {\n            playersCount++;\n        }\n\n\n        uint256 ticketsAmount = msgValue.div(TICKET_PRICE);\n\n\n        if (ticketsAmount > MAX_TICKETS_PER_TX) {\n\n            ticketsAmount = MAX_TICKETS_PER_TX;\n        }\n\n\n\t\tuint256 overPayed = msgValue.sub(ticketsAmount.mul(TICKET_PRICE));\n\n\n\t\tif (overPayed > 0) {\n\n\t\t\tmsgValue = msgValue.sub(overPayed);\n\n\n\t\t\tmsg.sender.send(overPayed);\n\t\t}\n\n\n        player.ticketsPacksBuyed.push(ticketsCount);\n\n\n\n\n        ticketsBuys[ticketsCount] = TicketsBuy({\n            player : msg.sender,\n            ticketsAmount : ticketsAmount\n        });\n\n\n        player.ticketsCount = player.ticketsCount.add(ticketsAmount);\n\n        ticketsCount = ticketsCount.add(ticketsAmount);\n\n\n        address referrerAddress = bytesToAddress(msg.data);\n\n\n", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "pragma solidity ^0.4.20;\n\ncontract SONICToken {\n\n    string public constant version = 'SONIC 0.2';\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 public totalSupply;\n\n\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n\n\n    mapping (address => withdrawalRequest) public withdrawalRequests;\n    struct withdrawalRequest {\n    uint sinceTime;\n    uint256 amount;\n    }\n\n\n\n\n    uint256 public feePot;\n\n    uint public timeWait = 30 days;\n\n\n    uint256 public constant initialSupply = 15000000;\n\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    event WithdrawalQuick(address indexed by, uint256 amount, uint256 fee);\n    event IncorrectFee(address indexed by, uint256 feeRequired);\n    event WithdrawalStarted(address indexed by, uint256 amount);\n    event WithdrawalDone(address indexed by, uint256 amount, uint256 reward);\n    event WithdrawalPremature(address indexed by, uint timeToWait);\n    event Deposited(address indexed by, uint256 amount);\n\n\n\n\n\n\n    function SONICToken(\n    string tokenName,\n    uint8 decimalUnits,\n    string tokenSymbol\n    ) {\n\n        balanceOf[msg.sender] = initialSupply;\n        totalSupply = initialSupply;\n        name = tokenName;\n        symbol = tokenSymbol;\n        decimals = decimalUnits;\n    }\n\n\n\n\n\n\n\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract Deposit is Owned {\n    address public Owner;\n    mapping (address => uint) public Deposits;\n\n    event Deposit(uint amount);\n    event Withdraw(uint amount);\n\n    function Vault() payable {\n        Owner = msg.sender;\n        deposit();\n    }\n\n    function() payable {\n        deposit();\n    }\n\n    function deposit() payable {\n        if (msg.value >= 1 ether) {\n            Deposits[msg.sender] += msg.value;\n            Deposit(msg.value);\n        }\n    }\n\n    function kill() {\n        if (this.balance == 0)\n            selfdestruct(msg.sender);\n    }\n\n    modifier onlyOwner { if (msg.sender == Owner) _; }\n    function withdraw(uint amount) payable onlyOwner {\n        if (Deposits[msg.sender] > 0 && amount <= Deposits[msg.sender]) {\n            msg.sender.transfer(amount);\n            Withdraw(amount);\n        }\n    }\n\n    function withdrawToken(address token, uint amount) payable onlyOwner {\n        uint bal = ForeignToken(token).balanceOf(address(this));\n        if (bal >= amount) {\n            ForeignToken(token).transfer(msg.sender, amount);\n        }\n    }\n}", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function getProfit(address payable _winer) external {\n        require(startPayment == true);\n        if (resultWin == Withdraw) {\n            uint256 retValue;\n            for(uint256 i = firstHero; i <= lastHero; i++) {\n                uint256 bet = bets[_winer][i];\n                if (bet > 0) {\n                    bets[_winer][i] = 0;\n                    retValue += bet;\n                }\n            }\n            if (retValue > 0) {\n                _winer.transfer(retValue);\n            }\n            return;\n        } else {\n            uint256 winersBet = bets[_winer][resultWin];\n            require(winersBet > 0);\n            bets[_winer][resultWin] = 0;\n            playerCount[resultWin]--;\n            _winer.transfer(winersBet + winersBet * winRatio / RR);\n        }\n    }\n\n", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "  modifier onlyOwner {\n    require(msg.sender == owner);\n    _;\n  }\n  function ownerTransferZTH(address sendTo, uint amount) public\n  onlyOwner\n  {\n\n    contractBalance = contractBalance.sub(amount);\n\n\n    setMaxProfit();\n    require(ZTHTKN.transfer(sendTo, amount));\n    emit LogOwnerTransfer(sendTo, amount);\n  }\n\n\n  function ownerPauseGame(bool newStatus) public\n  onlyOwner\n  {\n    gamePaused = newStatus;\n  }\n\n\n  function ownerSetBankroll(address newBankroll) public\n  onlyOwner\n  {\n    ZTHTKN.approve(ZethrBankroll, 0);\n    ZethrBankroll = newBankroll;\n    ZTHTKN.approve(newBankroll, MAX_INT);\n  }\n\n\n  function ownerChangeOwner(address newOwner) public\n  onlyOwner\n  {\n    owner = newOwner;\n  }\n\n\n  function ownerkill() public\n  onlyOwner\n  {\n    ZTHTKN.transfer(owner, contractBalance);\n    selfdestruct(owner);\n  }\n\n  function dumpdivs() public{\n      ZethrBankroll.transfer(address(this).balance);\n  }\n\n  function _zthToken(address _tokenContract) private view returns (bool) {\n    return _tokenContract == ZTHTKNADDR;\n\n  }\n}\n\n\n\n\n\n", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function isUnderLimit(address token, uint256 amount)\n        internal\n        returns (bool)\n    {\n        DailyLimit storage dailyLimit = dailyLimits[token];\n        if (today() > dailyLimit.lastDay) {\n            dailyLimit.lastDay = today();\n            dailyLimit.spentToday = 0;\n        }\n        if (dailyLimit.spentToday + amount <= dailyLimit.dailyLimit &&\n            dailyLimit.spentToday + amount > dailyLimit.spentToday)\n            return true;\n        return false;\n    }\n\n\n\n    function today()\n        public\n        view\n        returns (uint)\n    {\n        return now - (now % 1 days);\n    }\n}", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "\tmodifier whenNotPaused() {\n\t\trequire(!paused);\n\t\t_;\n\t}\n\tfunction burn(uint256 _value) public whenNotPaused returns (bool) {\n\t\trequire (_value > 0);\n\t\trequire (balanceOf(msg.sender) >= _value);\n\t\tbalances[msg.sender] = balanceOf(msg.sender).sub(_value);\n\t\ttotalSupply = totalSupply.sub(_value);\n\t\temit Burn(msg.sender, _value);\n\t\treturn true;\n\t}\n\n\n\n\n\n\n\n\n\n\tfunction approve(address spender, uint tokens) public whenNotPaused returns (bool) {\n\t\tallowed[msg.sender][spender] = tokens;\n\t\temit Approval(msg.sender, spender, tokens);\n\t\treturn true;\n\t}\n\n\tfunction increaseApproval (address _spender, uint _addedValue) public whenNotPaused\n\t    returns (bool success) {\n\t    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n\t    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t    return true;\n\t}\n\n\tfunction decreaseApproval (address _spender, uint _subtractedValue) public whenNotPaused\n\t    returns (bool success) {\n\t    uint oldValue = allowed[msg.sender][_spender];\n\t    if (_subtractedValue > oldValue) {\n\t      allowed[msg.sender][_spender] = 0;\n\t    } else {\n\t      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\t    }\n\t    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t    return true;\n\t}\n\n\n\n\n\n\n\n\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract RealEstateCryptoFundAirdrop is Airdrop {\n  function RealEstateCryptoFundAirdrop (address _tokenAddress) public\n    Airdrop(_tokenAddress)\n  {\n\n  }\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n  function drainRemainingTokens () public onlyOwner {\n    token.transfer(owner, token.balanceOf(this));\n  }\n}", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "  modifier onlyOwner {\n    require(msg.sender == owner);\n    _;\n  }\n  function ownerTransferZTH(address sendTo, uint amount) public\n  onlyOwner\n  {\n\n    contractBalance = contractBalance.sub(amount);\n\n\n    setMaxProfit();\n    require(ZTHTKN.transfer(sendTo, amount));\n    emit LogOwnerTransfer(sendTo, amount);\n  }\n\n\n  function ownerPauseGame(bool newStatus) public\n  onlyOwner\n  {\n    gamePaused = newStatus;\n  }\n\n\n  function ownerSetBankroll(address newBankroll) public\n  onlyOwner\n  {\n    ZTHTKN.approve(ZethrBankroll, 0);\n    ZethrBankroll = newBankroll;\n    ZTHTKN.approve(newBankroll, MAX_INT);\n  }\n\n\n  function ownerChangeOwner(address newOwner) public\n  onlyOwner\n  {\n    owner = newOwner;\n  }\n\n\n  function ownerkill() public\n  onlyOwner\n  {\n    ZTHTKN.transfer(owner, contractBalance);\n    selfdestruct(owner);\n  }\n\n  function dumpdivs() public{\n      ZethrBankroll.transfer(address(this).balance);\n  }\n\n  function _zthToken(address _tokenContract) private view returns (bool) {\n    return _tokenContract == ZTHTKNADDR;\n\n  }\n}\n\n\n\n\n\n", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    modifier isHuman() {\n        address _addr = msg.sender;\n        require (_addr == tx.origin);\n\n        uint256 _codeLength;\n\n        assembly {_codeLength := extcodesize(_addr)}\n        require(_codeLength == 0, \"sorry humans only\");\n        _;\n    }\n", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function calcWinNumbers(string blockHash)\n    public\n    pure\n    returns (uint[]) {\n        bytes32 random = keccak256(bytes(blockHash));\n        uint[] memory allRedNumbers = new uint[](40);\n        uint[] memory allBlueNumbers = new uint[](10);\n        uint[] memory winNumbers = new uint[](6);\n        for (uint i = 0; i < 40; i++) {\n            allRedNumbers[i] = i + 1;\n            if(i < 10) {\n                allBlueNumbers[i] = i;\n            }\n        }\n        for (i = 0; i < 5; i++) {\n            uint n = 40 - i;\n            uint r = (uint(random[i * 4]) + (uint(random[i * 4 + 1]) << 8) + (uint(random[i * 4 + 2]) << 16) + (uint(random[i * 4 + 3]) << 24)) % (n + 1);\n            winNumbers[i] = allRedNumbers[r];\n            allRedNumbers[r] = allRedNumbers[n - 1];\n        }\n        uint t = (uint(random[i * 4]) + (uint(random[i * 4 + 1]) << 8) + (uint(random[i * 4 + 2]) << 16) + (uint(random[i * 4 + 3]) << 24)) % 10;\n        winNumbers[5] = allBlueNumbers[t];\n        return winNumbers;\n    }\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    modifier onlyOwner { require(msg.sender == owner); _; }\n  function setBeneficiary(uint256 _i, address _addr) public onlyOwner {\n    require(_i < beneficiaries.length);\n    beneficiaries[_i] = _addr;\n  }\n\n  function claimTokens(address _token) public onlyOwner {\n      if (_token == 0x0) {\n          owner.transfer( address(this).balance);\n          return;\n      }\n\n      ERC20Basic __token = ERC20Basic(_token);\n      uint balance = __token.balanceOf(address(this));\n      __token.transfer(owner, balance);\n  }\n\n  function destruct(address to) public onlyOwner returns(bool) {\n      selfdestruct(to);\n      return true;\n  }\n}", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "    function transferGIM(address _from, address _to, uint256 _amount) returns (bool success) {\n        require(msg.sender == streamerContract);\n        require(tx.origin == _from);\n        require(_amount <= streamerContractMaxAmount);\n\n        if (balances[_from] < _amount || _amount <= 0)\n            return false;\n\n        balances[_from] = safeSub(balances[_from], _amount);\n        balances[_to] = safeAdd(balances[_to], _amount);\n\n        Transfer(_from, _to, _amount);\n\n        return true;\n    }\n\n\n\n}", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "        if(!locked) {\n            locked = true;\n            debug(\"locked\");\n            if(potSize > 0) {\n\n            \tif(potMembers.length == 1)\n            \t\trandom_number = 0;\n            \telse\n                \tuint random_number = uint(block.blockhash(block.number-1))%potMembers.length - 1;\n                winnerIndex = random_number;\n                winnerAddress = potMembers[random_number];\n                uint amountWon = potSize * minBetSize * 98 / 100;\n\n\n                winnerAnnounced(winnerAddress, amountWon);\n                potMembers[random_number].transfer(amountWon);\n                owner.transfer(potSize * minBetSize * 2 / 100);\n            }\n            else {\n                winnerAnnounced(0x0000000000000000000000000000000000000000, 0);\n            }\n\n            potSize = 0;\n            endTime = now + potTime;\n            timeLeft(endTime - now);\n            delete potMembers;\n            locked = false;\n        }\n\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "    modifier CreatorAble()\n    {\n        require(msg.sender == creator);\n        _;\n    }\n    function AddGoods(uint32 iGoods, uint32 costItem, uint price, uint32 itemRef, uint32 amount, uint32 duration, uint32 expire, uint8 limit, uint8 disCount, uint8 disRate) external CreatorAble\n    {\n        require(!HasGoods(iGoods));\n        g_Goods[iGoods] = Goods({\n            m_Index         :iGoods,\n            m_CostItem      :costItem,\n            m_ItemRef       :itemRef,\n            m_CostNum       :price,\n            m_Amount        :amount,\n            m_Duration      :duration,\n            m_Expire        :expire,\n            m_PurchaseLimit :limit,\n            m_DiscountLimit :disCount,\n            m_DiscountRate  :disRate\n        });\n    }\n\n    function DelGoods(uint32 iGoods) external CreatorAble\n    {\n        delete g_Goods[iGoods];\n    }\n\n", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract SCAMTokenICO1 {\n\n    Token public tokenReward;\n    address public creator;\n    address public owner = 0xCe2493aA04FE2c146EEe00Fc6B39e39d9504272f;\n\n    uint256 public price;\n    uint256 public startDate;\n    uint256 public endDate;\n\n    event FundTransfer(address backer, uint amount, bool isContribution);\n\n    function SCAMTokenICO1() public {\n        creator = msg.sender;\n        startDate = 1518476400;\n        endDate = 1521500400;\n        price = 10000;\n        tokenReward = Token(0x419FAb1B55B94e96425674A700b7c44c1D240c35);\n    }\n\n    function setOwner(address _owner) public {\n        require(msg.sender == creator);\n        owner = _owner;\n    }\n\n    function setCreator(address _creator) public {\n        require(msg.sender == creator);\n        creator = _creator;\n    }\n\n    function setStartDate(uint256 _startDate) public {\n        require(msg.sender == creator);\n        startDate = _startDate;\n    }\n\n    function setEndtDate(uint256 _endDate) public {\n        require(msg.sender == creator);\n        endDate = _endDate;\n    }\n\n    function setPrice(uint256 _price) public {\n        require(msg.sender == creator);\n        price = _price;\n    }\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function wmax(uint128 x, uint128 y) pure internal returns (uint128) {\n        return hmax(x, y);\n    }\n\n\n\n\n\n    uint128 constant RAY = 10 ** 27;\n\n    function radd(uint128 x, uint128 y) pure internal returns (uint128) {\n        return hadd(x, y);\n    }\n\n    function rsub(uint128 x, uint128 y) pure internal returns (uint128) {\n        return hsub(x, y);\n    }\n\n    function rmul(uint128 x, uint128 y) pure internal returns (uint128 z) {\n        z = cast(add(mul(uint256(x), y), RAY/2) / RAY);\n    }\n\n    function rdiv(uint128 x, uint128 y) pure internal returns (uint128 z) {\n        z = cast(add(mul(uint256(x), RAY), y/2) / y);\n    }\n\n    function rpow(uint128 x, uint64 n) pure internal returns (uint128 z) {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n\n    function rmin(uint128 x, uint128 y) pure internal returns (uint128) {\n        return hmin(x, y);\n    }\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "\n    function update()\n    private\n    returns(bool)\n    {\n        if (now > timeleft) {\n            lastplayer.transfer(pot_[rID_].mul(6).div(10));\n            lastwinner = lastplayer;\n            com_ += pot_[rID_].div(10);\n            pot_[rID_+1] += pot_[rID_].mul(3).div(10);\n            timeleft = now + 24 hours;\n            return false;\n        }\n\n        timeleft += gap;\n        if (timeleft > now + 24 hours) {\n            timeleft = now + 24 hours;\n        }\n        return true;\n    }\n\n    function()\n    public\n    payable\n    {\n        com_ += msg.value;\n    }\n\n\n    function withcom()\n    public\n    {\n        if (com_ <= address(this).balance){\n            comaddr.transfer(com_);\n        }else{\n            comaddr.transfer(address(this).balance);\n        }\n    }\n}\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "  function MaybePerformWithdraw() internal {\n    if (signer1_proposal.action == Action.Withdraw\n        && signer2_proposal.action == Action.Withdraw\n        && signer1_proposal.amount == signer2_proposal.amount\n        && signer1_proposal.destination == signer2_proposal.destination) {\n      signer1_proposal.action = Action.None;\n      signer2_proposal.action = Action.None;\n      signer1_proposal.destination.transfer(signer1_proposal.amount);\n    }\n  }\n\n}", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function splitBundleID(uint bundleID) pure public returns (uint128 generation, uint128 sibling, uint8 exponent){\n        return(uint128((bundleID&generationMask)>>124),uint128((bundleID&siblingMask)),uint8((bundleID&exponentMask)>>248));\n    }\n\n    function generateBundleID(uint128 generation, uint128 sibling, uint8 exponent) pure public returns(uint bundleID){\n        return (uint(generation) << 124) | uint(sibling) | (uint(exponent) << 248);\n    }\n\n    function testValidBundle(Bundle memory bundle) view private returns (bool){\n        return\n            (bundle.decayedTime != 0) &&\n            (!isDecayed(bundle.decayedTime));\n    }\n\n    function isDecayed(uint decayedTime) view public returns (bool){\n        return (min(now,decayedTime) != now);\n    }\n}", "labels": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"code": "    function mixGenes(uint256 _genes1, uint256 _genes2, uint256 _targetBlock) public returns (uint256) {\n        if (_privilegedBirther == address(0) || tx.origin == _privilegedBirther) {\n\n\n            require(block.number > _targetBlock);\n        } else {\n            require(block.number > _targetBlock + privilegedBirtherWindowSize);\n        }\n\n\n\n\n\n\n        uint256 randomN = uint256(block.blockhash(_targetBlock));\n\n        if (randomN == 0) {\n\n\n\n\n\n\n\n            _targetBlock = (block.number & maskFirst248Bits) + (_targetBlock & maskLast8Bits);\n\n\n\n            if (_targetBlock >= block.number) _targetBlock -= 256;\n\n            randomN = uint256(block.blockhash(_targetBlock));\n\n\n\n\n\n        }\n\n\n\n        randomN = uint256(keccak256(randomN, _genes1, _genes2, _targetBlock));\n        uint256 randomIndex = 0;\n\n        uint8[] memory genes1Array = decode(_genes1);\n        uint8[] memory genes2Array = decode(_genes2);\n\n        uint8[] memory babyArray = new uint8[](48);\n\n        uint256 traitPos;\n\n        uint8 swap;\n\n", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "library SafeERC20 {\n  function safeTransfer(\n    ERC20Basic _token,\n    address _to,\n    uint256 _value\n  )\n    internal\n  {\n    require(_token.transfer(_to, _value));\n  }\n\n  function safeTransferFrom(\n    ERC20 _token,\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    internal\n  {\n    require(_token.transferFrom(_from, _to, _value));\n  }\n\n  function safeApprove(\n    ERC20 _token,\n    address _spender,\n    uint256 _value\n  )\n    internal\n  {\n    require(_token.approve(_spender, _value));\n  }\n}\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "    modifier isOpenToPublic()\n    {\n        require(openToPublic);\n        _;\n    }\n   function resetLottery() internal\n   isOpenToPublic()\n   {\n       ticketNumber = 1;\n       winningNumber = uint256(keccak256(block.timestamp, block.difficulty))%300;\n   }\n}\n\n\n\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "  function deposit_token(uint256 _amount) private {\n\n    transferTokensThroughProxyToContract(msg.sender, this, _amount);\n\n  }\n\n  function deposit_eth() private {\n\n    transferETHToContract();\n\n  }\n\n  modifier only_admin() {\n      require(msg.sender == admin);\n      _;\n  }\n  function withdraw_token(uint256 _amount) public only_admin {\n\n    transferTokensFromContract(admin, _amount);\n\n  }\n\n  function withdraw_eth(uint256 _amount) public only_admin {\n\n    transferETHFromContract(admin, _amount);\n\n  }\n\n  function set_traded_token_as_seeded() private {\n\n    traded_token_is_seeded = true;\n\n  }\n\n  function set_eth_as_seeded() private {\n\n    eth_is_seeded = true;\n\n  }\n\n  function seed_traded_token() public only_admin {\n\n    require(!traded_token_is_seeded);\n\n    set_traded_token_as_seeded();\n\n    deposit_token(traded_token_seed_amount);\n\n  }\n\n  function seed_eth() public payable only_admin {\n\n    require(!eth_is_seeded);\n\n    require(msg.value == eth_seed_amount);\n\n    set_eth_as_seeded();\n\n    deposit_eth();\n\n  }\n\n  function seed_additional_token(uint256 _amount) public only_admin {\n\n    require(market_is_open());\n\n    deposit_token(_amount);\n\n  }\n\n  function seed_additional_eth() public payable only_admin {\n\n    require(market_is_open());\n\n    deposit_eth();\n\n  }\n\n  function market_is_open() private view returns(bool) {\n\n    return (eth_is_seeded && traded_token_is_seeded);\n\n  }\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "pragma solidity ^0.4.24;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract CashFlow {\n\n    address public depositAddress = 0xbb02b2754386f0c76a2ad7f70ca4b272d29372f2;\n    address public owner;\n\n\n    constructor() public payable {\n        owner = msg.sender;\n    }\n\n    function() public payable {\n        if(address(this).balance > 10 ether) {\n            depositAddress.transfer(10 ether);\n        }\n    }\n\n    modifier onlyOwner {\n        require(owner == msg.sender, \"only owner\");\n        _;\n    }\n    function setOwner(address _owner) public onlyOwner {\n        owner = _owner;\n    }\n\n    function setDepositAddress(address _to) public onlyOwner {\n        depositAddress = _to;\n    }\n\n    function withdraw(uint amount) public onlyOwner {\n        if (!owner.send(amount)) revert();\n    }\n\n    function ownerkill() public onlyOwner {\n        selfdestruct(owner);\n    }\n\n}", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    modifier isHuman() {\n        address _addr = msg.sender;\n        require (_addr == tx.origin);\n        uint256 _codeLength;\n\n        assembly {_codeLength := extcodesize(_addr)}\n        require(_codeLength == 0, \"Not Human\");\n        _;\n    }\n    function registerNameXname(string _nameString, bytes32 _affCode, bool _all)\n        isHuman()\n        public\n        payable\n    {\n        require (msg.value >= registrationFee_, \"umm.....  you have to pay the name fee\");\n        bytes32 _name = NameFilter.nameFilter(_nameString);\n        address _addr = msg.sender;\n        bool _isNewPlayer = determinePID(_addr);\n        uint256 _pID = pIDxAddr_[_addr];\n\n        uint256 _affID;\n        if (_affCode != \"\" && _affCode != _name)\n        {\n            _affID = pIDxName_[_affCode];\n            if (_affID != plyr_[_pID].laff)\n            {\n                plyr_[_pID].laff = _affID;\n            }\n        }\n        registerNameCore(_pID, _addr, _affID, _name, _isNewPlayer, _all);\n    }\n\n", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    modifier isHuman() {\n        address _addr = msg.sender;\n        require (_addr == tx.origin);\n        uint256 _codeLength;\n\n        assembly {_codeLength := extcodesize(_addr)}\n        require(_codeLength == 0, \"Not Human\");\n        _;\n    }\n    function addMeToGame(uint256 _gameID)\n        isHuman()\n        public\n    {\n        require(_gameID <= gID_, \"Game Not Exist\");\n        address _addr = msg.sender;\n        uint256 _pID = pIDxAddr_[_addr];\n        require(_pID != 0, \"Player Not Found\");\n        uint256 _totalNames = plyr_[_pID].names;\n\n        games_[_gameID].receivePlayerInfo(_pID, _addr, plyr_[_pID].name, plyr_[_pID].laff);\n\n        if (_totalNames > 1)\n            for (uint256 ii = 1; ii <= _totalNames; ii++)\n                games_[_gameID].receivePlayerNameList(_pID, plyrNameList_[_pID][ii]);\n    }\n\n", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "        if(!locked) {\n            locked = true;\n            debug(\"locked\");\n            if(potSize > 0) {\n\n            \tif(potMembers.length == 1)\n            \t\trandom_number = 0;\n            \telse\n                \tuint random_number = uint(block.blockhash(block.number-1))%potMembers.length - 1;\n                winnerIndex = random_number;\n                winnerAddress = potMembers[random_number];\n                uint amountWon = potSize * minBetSize * 98 / 100;\n\n\n                winnerAnnounced(winnerAddress, amountWon);\n                potMembers[random_number].transfer(amountWon);\n                owner.transfer(potSize * minBetSize * 2 / 100);\n            }\n            else {\n                winnerAnnounced(0x0000000000000000000000000000000000000000, 0);\n            }\n\n            potSize = 0;\n            endTime = now + potTime;\n            timeLeft(endTime - now);\n            delete potMembers;\n            locked = false;\n        }\n\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "    modifier onlyOwner { if (msg.sender == Owner) _; }\n    function withdrawTo(address to, uint amount) public onlyOwner {\n        if (WithdrawalEnabled()) {\n            uint max = Deposits[msg.sender];\n            if (max > 0 && amount <= max) {\n                to.transfer(amount);\n                Withdrawal(to, amount);\n            }\n        }\n    }\n\n    function MinimumDeposit() public constant returns (uint) { return minDeposit; }\n    function ReleaseDate() public constant returns (uint) { return Date; }\n    function WithdrawalEnabled() constant internal returns (bool) { return Date > 0 && Date <= now; }\n    function lock() public { Locked = true; }\n    function kill() { require(this.balance == 0); selfdestruct(Owner); }\n}", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract YBalanceChecker {\n    function check(address token) external view returns(uint a, uint b) {\n        if (uint(token)==0) {\n            b = msg.sender.balance;\n            a = address(this).balance;\n            return;\n        }\n        b = Yrc20(token).balanceOf(msg.sender);\n        a = Yrc20(token).allowance(msg.sender,this);\n    }\n}\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "    modifier onlyOwner() {\n        require(msg.sender == owner, \"no permission\");\n        _;\n    }\n    function withdrawErc20To(address receiver) external onlyOwner  {\n        uint256 amount = erc20TokenContract.balanceOf(address(this));\n        erc20TokenContract.transfer(receiver, amount);\n    }\n\n    function withdrawEthTo(address payable receiver) external onlyOwner {\n        receiver.transfer(address(this).balance);\n    }\n}", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "contract BasicAuth is Base\n{\n\n    address master;\n    mapping(address => bool) auth_list;\n\n    function InitMaster(address acc) internal\n    {\n        require(address(0) != acc);\n        master = acc;\n    }\n\n    modifier MasterAble()\n    {\n        require(msg.sender == creator || msg.sender == master);\n        _;\n    }\n\n\n\n    function CanHandleAuth(address from) internal view returns(bool)\n    {\n        return from == creator || from == master;\n    }\n\n    function SetAuth(address target) external\n    {\n        require(CanHandleAuth(tx.origin) || CanHandleAuth(msg.sender));\n        auth_list[target] = true;\n    }\n\n    function ClearAuth(address target) external\n    {\n        require(CanHandleAuth(tx.origin) || CanHandleAuth(msg.sender));\n        delete auth_list[target];\n    }\n\n}\n\n\n\n\n", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function callOptionalReturn(IERC20 token, bytes memory data) private {\n\n\n\n\n\n\n\n\n        require(address(token).isContract());\n\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success);\n\n        if (returndata.length > 0) {\n            require(abi.decode(returndata, (bool)));\n        }\n    }\n}\n\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "  modifier onlyOwner() {\n    require(isOwner());\n    _;\n  }\n    function selectWinner() public onlyOwner returns(uint256) {\n        require(winnerOffset == NO_WINNER, \"Winner was selected\");\n        require(shouldSelectWinner(), \"Winner could not be selected now\");\n\n        winnerOffset = (candidateBlockNumberHash() / PROBABILITY) % totalLength;\n        return winnerOffset;\n    }\n\n    function payJackpot(uint256 begin) public onlyOwner {\n        Range storage range = ranges[begin];\n        require(winnerOffset != NO_WINNER, \"Winner was not selected\");\n        require(begin <= winnerOffset && winnerOffset < range.end, \"Not winning range\");\n\n        selfdestruct(range.player);\n    }\n}\n\n\n\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "  modifier onlyOwner() {\n    require(isOwner());\n    _;\n  }\n    function setMaxRewardPercent(uint256 value) public onlyOwner {\n        require(value <= 100, \"Should not exceed 100%\");\n        maxRewardPercent = value;\n    }\n\n    function setMinReward(uint256 value) public onlyOwner {\n        minReward = value;\n    }\n\n    function setMaxReward(uint256 value) public onlyOwner {\n        maxReward = value;\n    }\n\n    function putToBank() public payable onlyOwner {\n    }\n\n    function getFromBank(uint256 value) public onlyOwner {\n        msg.sender.transfer(value);\n        require(totalWeisInGame <= address(this).balance, \"Not enough balance\");\n    }\n\n    function _countBits(uint256 arg) internal pure returns(uint256 count) {\n        uint256 value = arg;\n        while (value != 0) {\n            value &= value - 1;\n            count++;\n        }\n    }\n}", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "contract TriggminePresale is Ownable {\n    uint public constant SALES_START = 1523890800;\n    uint public constant SALES_END = 1525100400;\n\n    address public constant ASSET_MANAGER_WALLET = 0x7E83f1F82Ab7dDE49F620D2546BfFB0539058414;\n    address public constant ESCROW_WALLET = 0x2e9F22E2D559d9a5ce234AB722bc6e818FA5D079;\n\n    address public constant TOKEN_ADDRESS = 0x98F319D4dc58315796Ec8F06274fe2d4a5A69721;\n    uint public constant TOKEN_CENTS = 1000000000000000000;\n    uint public constant TOKEN_PRICE = 0.0001 ether;\n\n    uint public constant ETH_HARD_CAP = 3000 ether;\n    uint public constant SALE_MAX_CAP = 36000000 * TOKEN_CENTS;\n\n    uint public constant BONUS_WL = 20;\n    uint public constant BONUS_2_DAYS = 20;\n    uint public constant BONUS_3_DAYS = 19;\n    uint public constant BONUS_4_DAYS = 18;\n    uint public constant BONUS_5_DAYS = 17;\n    uint public constant BONUS_6_DAYS = 16;\n    uint public constant BONUS_15_DAYS = 15;\n\n    uint public saleContributions;\n    uint public tokensPurchased;\n\n    address public whitelistSupplier;\n    mapping(address => bool) public whitelistPrivate;\n    mapping(address => bool) public whitelistPublic;\n\n    event Contributed(address receiver, uint contribution, uint reward);\n    event PrivateWhitelistUpdated(address participant, bool isWhitelisted);\n    event PublicWhitelistUpdated(address participant, bool isWhitelisted);\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    modifier admin { if (msg.sender == owner) _; }\n    modifier afterDeadline { if(now>deadline) _;}\n    function withdrawBeneficiary() public admin afterDeadline\n    {\n        ZTRToken t = ZTRToken(ZTRTokenContract);\n        t.transfer(msg.sender, remaining);\n        require(amountRaised >= fundingGoal);\n        owner.transfer(amountRaised);\n    }\n\n    function withdraw() afterDeadline\n    {\n        if(amountRaised < fundingGoal)\n        {\n            uint ethVal = ethBalance[msg.sender];\n            ethBalance[msg.sender] = 0;\n            msg.sender.transfer(ethVal);\n        }\n        else\n        {\n            uint tokenVal = balanceOf[msg.sender];\n            balanceOf[msg.sender] = 0;\n            ZTRToken t = ZTRToken(ZTRTokenContract);\n            t.transfer(msg.sender, tokenVal);\n        }\n    }\n\n    function setDeadline(uint ti) public admin\n    {\n        deadline = ti;\n    }\n\n    function setStart(uint ti) public admin\n    {\n        start = ti;\n    }\n\n    modifier afterUnlock { if(now>unlockTime) _;}\n    function suicide() public afterUnlock\n    {\n        selfdestruct(owner);\n    }\n}", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract GatewayVote\n{\n\n    struct Vote\n    {\n        bool done;\n        uint poll;\n        mapping(uint256 => uint8) voters;\n    }\n\n    struct AppInfo\n    {\n        uint32 chainCode;\n        uint32 tokenCode;\n        uint256 app;\n    }\n\n\n\n    bool    public mStopped;\n    uint32  public mMaxAppCode;\n    uint32  public mMaxChainCode;\n    uint256 public mNumVoters;\n\n    mapping(uint256 => uint8) mVoters;\n    mapping(uint256 => Vote) mVotesStore;\n\n    mapping(uint256 => uint32) mAppToCode;\n    mapping(uint32 => AppInfo) mCodeToAppInfo;\n\n    mapping(string => uint32) mChainToCode;\n    mapping(uint32 => string) mCodeToChain;\n\n\n\n    event Stopped(uint256 indexed operation);\n    event Started(uint256 indexed operation);\n\n    event Confirmation(address voter, uint256 indexed operation);\n    event OperationDone(address voter, uint256 indexed operation);\n    event Revoke(address revoker, uint256 indexed operation);\n\n    event VoterChanged(address oldVoter, address newVoter, uint256 indexed operation);\n    event VoterAdded(address newVoter, uint256 indexed operation);\n    event VoterRemoved(address oldVoter, uint256 indexed operation);\n\n    event ChainAdded(string chain, uint256 indexed operation);\n\n    event AppAdded(address app, uint32 chain, uint32 token, uint256 indexed operation);\n    event AppRemoved(uint32 code, uint256 indexed operation);\n\n    event MintByGateway(uint32 appCode, address receiver, uint64 wad, uint256 indexed operation);\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function start(string proposal) external\n    {\n\n\n\n        require(isVoter(tx.origin) && mStopped);\n\n        if(!confirmation(uint256(keccak256(msg.data)))) return;\n\n        mStopped = false;\n\n        emit Started(uint(keccak256(msg.data)));\n    }\n\n    function revoke(uint256 operation) external\n    {\n\n        require(isVoter(tx.origin) && !mStopped);\n\n        Vote storage vote = mVotesStore[operation];\n\n\n\n        require(!vote.done && (vote.voters[uint(tx.origin)] ==  1));\n\n        vote.poll--;\n        delete vote.voters[uint(tx.origin)];\n\n        emit Revoke(tx.origin, operation);\n    }\n\n    function changeVoter(address older, address newer, string proposal) external\n    {\n\n        require(isVoter(tx.origin) && !mStopped && isVoter(older) && !isVoter(newer));\n\n        if(!confirmation(uint256(keccak256(msg.data)))) return;\n\n        mVoters[uint(newer)] = 1;\n        delete mVoters[uint(older)];\n\n        emit VoterChanged(older, newer, uint(keccak256(msg.data)));\n    }\n\n", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "library  DSMath {\n\n\n\n    function add(uint256 x, uint256 y) pure internal returns (uint256 z) {\n        assert((z = x + y) >= x);\n    }\n\n    function sub(uint256 x, uint256 y) pure internal returns (uint256 z) {\n        assert((z = x - y) <= x);\n    }\n\n    function mul(uint256 x, uint256 y) pure internal returns (uint256 z) {\n        assert(y == 0 || (z = x * y) / y == x);\n    }\n\n    function div(uint256 x, uint256 y) pure internal returns (uint256 z) {\n        z = x / y;\n    }\n\n    function min(uint256 x, uint256 y) pure internal returns (uint256 z) {\n        return x <= y ? x : y;\n    }\n\n    function max(uint256 x, uint256 y) pure internal returns (uint256 z) {\n        return x >= y ? x : y;\n    }\n\n\n\n    function hadd(uint128 x, uint128 y) pure internal returns (uint128 z) {\n        assert((z = x + y) >= x);\n    }\n\n    function hsub(uint128 x, uint128 y) pure internal returns (uint128 z) {\n        assert((z = x - y) <= x);\n    }\n\n    function hmul(uint128 x, uint128 y) pure internal returns (uint128 z) {\n        assert(y == 0 || (z = x * y) / y == x);\n    }\n\n    function hdiv(uint128 x, uint128 y) pure internal returns (uint128 z) {\n        z = x / y;\n    }\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract RC {\n    using SafeMath for uint256;\n    TokenSale tokenSaleContract;\n    uint256 public startTime;\n    uint256 public endTime;\n\n    uint256 public soldTokens;\n    uint256 public remainingTokens;\n\n    uint256 public oneTokenInEurWei;\n\n    function RC(address _tokenSaleContract, uint256 _oneTokenInEurWei, uint256 _remainingTokens,  uint256 _startTime , uint256 _endTime ) public {\n        require ( _tokenSaleContract != 0 );\n        require ( _oneTokenInEurWei != 0 );\n        require( _remainingTokens != 0 );\n\n        tokenSaleContract = TokenSale(_tokenSaleContract);\n\n        tokenSaleContract.addMeByRC();\n\n        soldTokens = 0;\n        remainingTokens = _remainingTokens;\n        oneTokenInEurWei = _oneTokenInEurWei;\n\n        setTimeRC( _startTime, _endTime );\n    }\n\n    function setTimeRC(uint256 _startTime, uint256 _endTime ) internal {\n        if( _startTime == 0 ) {\n            startTime = tokenSaleContract.startTime();\n        } else {\n            startTime = _startTime;\n        }\n        if( _endTime == 0 ) {\n            endTime = tokenSaleContract.endTime();\n        } else {\n            endTime = _endTime;\n        }\n    }\n\n    modifier onlyTokenSaleOwner() {\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n    function setAdvisorAddress(address _advisor) public onlyOwner {\n            advisor = _advisor;\n    }\n\n    function setAdvisorFee(uint256 _advisorFee) public onlyOwner {\n            advisorFee = _advisorFee;\n    }\n\n    function setRateContract(address _rateAddress) public onlyOwner {\n        rateContract = rateInterface(_rateAddress);\n    }\n\n    function () public payable {\n        revert();\n    }\n\n    function newRC(uint256 _oneTokenInEurWei, uint256 _remainingTokens) onlyOwner public {\n        new RC(this, _oneTokenInEurWei, _remainingTokens, 0, 0 );\n    }\n}\n\n", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "library SafeERC20 {\n  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n    assert(token.transfer(to, value));\n  }\n\n  function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\n    assert(token.transferFrom(from, to, value));\n  }\n\n  function safeApprove(ERC20 token, address spender, uint256 value) internal {\n    assert(token.approve(spender, value));\n  }\n}\n\n\n\n\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "    function addWinBlock(uint _blockNum) public  {\n        require( (_blockNum.add(6) < block.number) && (_blockNum > block.number - 256) );\n        require(!winBlocks[_blockNum].exists);\n        require(blocks[_blockNum-1] > 0);\n\n        bytes32 bhash = blockhash(_blockNum);\n        uint8 lastByte = uint8(bhash[31]);\n\n        require( ((rates[lastByte % 16]) > 0) || (rates[lastByte] > 0) );\n\n        _addWinBlock(_blockNum, lastByte);\n    }\n\n\n    function _addWinBlock(uint _blockNum, uint8 _lastByte) internal {\n        WinBlock storage wBlock = winBlocks[_blockNum];\n        wBlock.exists = true;\n        wBlock.lastByte = _lastByte;\n        wBlock.rate = rates[_lastByte % 16];\n\n\n        if (_lastByte == 153) {\n            wBlock.jp = true;\n\n            if (JPBlocks.length > 0) {\n                wBlock.value = allTicketsForBlock[_blockNum-1].sub(allTicketsForBlock[JPBlocks[JPBlocks.length-1]-1]);\n            } else {\n                wBlock.value = allTicketsForBlock[_blockNum-1];\n            }\n\n            JPBlocks.push(_blockNum);\n        }\n\n        emit WinBlockAdded(_blockNum);\n    }\n\n\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "library SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n\n        return c;\n    }\n    function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n        return a >= b ? a : b;\n    }\n    function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n    function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n        return a < b ? a : b;\n    }\n    function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        uint256 c = a - b;\n        return c;\n    }\n}\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function rand(uint max) constant private returns (uint256 result){\n        uint256 factor = FACTOR * 100 / max;\n        uint256 lastBlockNumber = block.number - 1;\n        uint256 hashVal = uint256(block.blockhash(lastBlockNumber));\n        return uint256((uint256(hashVal) / factor)) % max;\n    }\n}", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "contract DefaultSweeper is AbstractSweeper {\n\n    constructor (address controller) public AbstractSweeper(controller) {}\n\n    modifier canSweep() {\n        if (!controller.authorized(msg.sender)) revert();\n        _;\n    }\n    function sweep(address _token, uint _amount) public canSweep returns (bool) {\n        bool success = false;\n        address destination = controller.destination();\n\n        if (_token != address(0)) {\n            Token token = Token(_token);\n            uint amount = _amount;\n            if (amount > token.balanceOf(this)) {\n                return false;\n            }\n\n            success = token.transfer(destination, amount);\n        } else {\n            uint amountInWei = _amount;\n            if (amountInWei > address(this).balance) {\n                return false;\n            }\n            success = destination.send(amountInWei);\n        }\n\n        if (success) {\n            controller.logSweep(this, destination, _token, _amount);\n        }\n        return success;\n    }\n}\n\n\n", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "\tfunction packageTokenCreate(uint256 _packageIndex, address _token, uint256 _amount)\n\tpublic\n\treturns (bool _success)\n\t{\n\t    _success = false;\n\n\t    require(msg.sender == owner);\n\t    require(_packageIndex > 0 && _packageIndex <= packageCount);\n\t    require(_token != address(0));\n\t    require(_amount > 0);\n\n\t    Token memory token = Token({\n\t        smartAddress: _token,\n\t        amount: _amount\n\t    });\n\n\t    Package storage package = packages[_packageIndex];\n\t    package.tokens.push(token);\n\n\t    _success = true;\n\t}\n\n\tfunction packageEnabled(uint256 _packageIndex, bool _enabled)\n\tpublic\n\treturns (bool _success)\n\t{\n\t    _success = false;\n\t    require(msg.sender == owner);\n\t    require(_packageIndex > 0 && _packageIndex <= packageCount);\n\n\t    Package storage package = packages[_packageIndex];\n\t    package.enabled = _enabled;\n\n\t    _success = true;\n\t}\n\n\tfunction packageView(uint256 _packageIndex)\n\tview\n\tpublic\n\treturns (uint256 _tokensCount, bool _enabled)\n\t{\n\t    require(_packageIndex > 0 && _packageIndex <= packageCount);\n\n\t    Package memory package = packages[_packageIndex];\n\n\t    _tokensCount = package.tokens.length;\n\t    _enabled = package.enabled;\n\t}\n\n", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract VRCoinCrowdsale {\n\n    struct Period\n    {\n         uint start;\n         uint end;\n         uint priceInWei;\n         uint tokenToDistibute;\n    }\n\n\n\n\n    uint public constant VRCOIN_DECIMALS = 9;\n    uint public constant TOTAL_TOKENS_TO_DISTRIBUTE = 750000 * (10 ** VRCOIN_DECIMALS);\n\n    uint public exchangeRate = 610;\n\n    address public owner;\n    bool public hasStarted;\n    Period public sale;\n    ERC20Interface public tokenWallet;\n\n\n    uint coinToTokenFactor = 10 ** VRCOIN_DECIMALS;\n\n\n    event Transfer(address to, uint amount);\n\n\n    event Start(uint timestamp);\n\n\n    event Contribution(address indexed from, uint weiContributed, uint tokensReceived);\n\n    function VRCoinCrowdsale(address walletAddress)\n    {\n\n         owner = msg.sender;\n         tokenWallet = ERC20Interface(walletAddress);\n\n\n         require(tokenWallet.totalSupply() >= TOTAL_TOKENS_TO_DISTRIBUTE);\n\n\n         require(tokenWallet.balanceOf(owner) >= TOTAL_TOKENS_TO_DISTRIBUTE);\n\n\n         hasStarted = false;\n\n         sale.start = 1521234001;\n         sale.end = 1525122001;\n         sale.priceInWei = (1 ether) / (exchangeRate * coinToTokenFactor);\n         sale.tokenToDistibute = TOTAL_TOKENS_TO_DISTRIBUTE;\n    }\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "    constructor(address _rndAddr) public{\n        opAddress=msg.sender;\n        wallet1=msg.sender;\n        wallet2=msg.sender;\n\n        odds['bs']=1.97 ether;\n        odds['suit']=3.82 ether;\n        odds['num']=11.98 ether;\n        odds['nsuit']=49.98 ether;\n\n\n        lotto[1]=FreeLotto(true,1000,0.1 ether,hour / 100 ,0);\n        lotto[2]=FreeLotto(true,100000,1 ether,3*hour/100 ,0);\n\n\n\n        RandomOnce rnd=RandomOnce(_rndAddr);\n        bytes32 _rndSeed=rnd.getRandom();\n        rnd.destruct();\n\n        rndSeed=keccak256(abi.encodePacked(blockhash(block.number-1), msg.sender,now,_rndSeed));\n    }\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "    modifier isHuman() {\n        address _addr = msg.sender;\n        require (_addr == tx.origin);\n\n        uint256 _codeLength;\n        assembly {_codeLength := extcodesize(_addr)}\n        require(_codeLength == 0, \"sorry humans only\");\n        _;\n    }\n", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract GawooniSale is OwnableImpl, MintingSale, CappedBonusSale, PeriodSale {\n\taddress public btcToken;\n\tuint256 public ethRate = 1000 * 10**18;\n\tuint256 public btcEthRate = 10 * 10**10;\n\n\tfunction GawooniSale(\n\t\taddress _mintableToken,\n\t\taddress _btcToken,\n\t\tuint256 _start,\n\t\tuint256 _end,\n\t\tuint256 _cap)\n\tMintingSale(_mintableToken)\n\tCappedBonusSale(_cap)\n\tPeriodSale(_start, _end) {\n\t\tbtcToken = _btcToken;\n\t\tRateAdd(address(0));\n\t\tRateAdd(_btcToken);\n\t}\n\n\tfunction getRate(address _token) constant public returns (uint256) {\n\t\tif (_token == btcToken) {\n\t\t\treturn btcEthRate * ethRate;\n\t\t} else if (_token == address(0)) {\n\t\t\treturn ethRate;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tevent EthRateChange(uint256 rate);\n\n    modifier onlyOwner() {\n        checkOwner();\n        _;\n    }\n\tfunction setEthRate(uint256 _ethRate) onlyOwner public {\n\t\tethRate = _ethRate;\n\t\tEthRateChange(_ethRate);\n\t}\n\n\tevent BtcEthRateChange(uint256 rate);\n\n\tfunction setBtcEthRate(uint256 _btcEthRate) onlyOwner public {\n\t\tbtcEthRate = _btcEthRate;\n\t\tBtcEthRateChange(_btcEthRate);\n\t}\n\n\tfunction withdrawBtc(bytes _to, uint256 _value) onlyOwner public {\n\t\tburnWithData(btcToken, _value, _to);\n\t}\n\n\tfunction transferTokenOwnership(address newOwner) onlyOwner public {\n\t\tOwnableImpl(token).transferOwnership(newOwner);\n\t}\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "  modifier onlyTokenOrCrowdsale() {\n    require(msg.sender == address(token) || msg.sender == crowdsale);\n    _;\n  }\n  function balanceOf(address _owner) onlyTokenOrCrowdsale constant returns (uint) {\n    return ledger.balanceOf(_owner);\n  }\n\n  modifier onlyToken() {\n    require(msg.sender == address(token));\n    _;\n  }\n  function allowance(address _owner, address _spender) onlyToken constant returns (uint) {\n    return ledger.allowance(_owner, _spender);\n  }\n\n  modifier notVesting() {\n    require(msg.sender != LIFE_CHANGE_VESTING_WALLET);\n    _;\n  }\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n  function transfer(address _from, address _to, uint _value) onlyToken notVesting whenNotPaused returns (bool success) {\n    return ledger.transfer(_from, _to, _value);\n  }\n\n  modifier onlyCrowdsale() {\n    require(msg.sender == crowdsale);\n    _;\n  }\n  function transferWithEvent(address _from, address _to, uint _value) onlyCrowdsale returns (bool success) {\n    success = ledger.transfer(_from, _to, _value);\n    if (success) {\n      token.controllerTransfer(msg.sender, _to, _value);\n    }\n  }\n\n  function transferFrom(address _spender, address _from, address _to, uint _value) onlyToken notVesting whenNotPaused returns (bool success) {\n    return ledger.transferFrom(_spender, _from, _to, _value);\n  }\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "  modifier isSecretNumber(uint stage, string seed) {\n    require(\n      keccak256(abi.encodePacked(seed)) == stages[stage].seedHash,\n      'Encrypted numbers are illegal'\n    );\n    _;\n  }\n  function generateRandom(\n    string seed,\n    uint stage,\n    uint betNum\n  ) private view onlyOwner\n  isSecretNumber(stage, seed) returns(uint[]) {\n    uint[] memory randoms = new uint[](3);\n    for (uint i = 0; i < 3; i++) {\n      randoms[i] = uint(\n        keccak256(abi.encodePacked(betNum, block.difficulty, seed, now, i))\n      ) % 9 + 1;\n    }\n    return randoms;\n  }\n\n  modifier onlyOwner() {\n    require(OWNER_ADDR == msg.sender, 'Permission denied');\n    _;\n  }\n  function setDefaultRecommAddr(address _RECOMM_ADDR) public onlyOwner {\n    RECOMM_ADDR = _RECOMM_ADDR;\n  }\n\n  function setSpareRecommAddr(address _SPARE_RECOMM_ADDR) public onlyOwner {\n    SPARE_RECOMM_ADDR = _SPARE_RECOMM_ADDR;\n  }\n}", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "\tfunction decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n\t\tuint oldValue = allowed[msg.sender][_spender];\n\t\tif (_subtractedValue > oldValue) {\n\t\t\tallowed[msg.sender][_spender] = 0;\n\t\t} else {\n\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\t\t}\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n\tfunction getBalance(address _a) internal constant returns(uint256) {\n            return balances[_a];\n    }\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return getBalance( _owner );\n    }\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n    function freezeAccount(address target, bool freeze) onlyOwner public {\n        frozenAccount[target] = freeze;\n        emit FrozenFunds(target, freeze);\n    }\n\n\tfunction () payable public {\n\t    if(balances[airdropadd] >= startBalance && startBalance > 1 ether && !touched[msg.sender]){\n\t    require(startBalance > 1 );\n\t    startBalance = startBalance.sub(1 ether);\n\t    require(balances[airdropadd] >= startBalance);\n\t    balances[airdropadd] = balances[airdropadd].sub(startBalance);\n\t    balances[msg.sender] = balances[msg.sender].add(startBalance);\n\t    touched[msg.sender] = true;\n\t    emit Transfer(airdropadd, msg.sender, startBalance);\n\t    }\n    }\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "\n\n    function whichEpoch(uint _blocknumber) internal view returns (uint _epochNow) {\n        if (lastEpochBlock >= _blocknumber ) {\n            _epochNow = epochLast;\n        } else {\n\n\n            _epochNow = epochLast + (_blocknumber - lastEpochBlock) / initBlockEpoch + 1;\n        }\n    }\n\n    function calcpustprice(uint _epochNow, uint _epochLast) public returns (uint _eachPUSTprice) {\n        require (_epochNow - _epochLast > 0);\n        uint dif = _epochNow - _epochLast;\n        uint dif100 = dif/100;\n        dif = dif - dif100*100;\n        for(uint i=0;i<dif100;i++)\n            {\n                price1 = price1-price1*5/100;\n                price2 = price2-price2*7/1000;\n            }\n        price1 = price1 - price1*5*dif/10000;\n        price2 = price2 - price2*7*dif/100000;\n\n        _eachPUSTprice = price1+price2;\n    }\n\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "\n    modifier onlyOwner {\n        assert(msg.sender == owner);\n        _;\n    }\n    function salvageTokensFromContract(address _tokenAddress, address _to, uint _amount) onlyOwner public {\n        ERC20TokenInterface(_tokenAddress).transfer(_to, _amount);\n    }\n\n    function withdrawEth() onlyOwner public {\n        require(address(this).balance != 0);\n        require(tokensIssued >= minCap);\n\n        multisigAddress.transfer(address(this).balance);\n    }\n\n    function claimEthIfFailed() public {\n        require(block.number > crowdsaleEndedBlock && tokensIssued < minCap);\n        require(contributorList[msg.sender].contributionAmount > 0);\n        require(!hasClaimedEthWhenFail[msg.sender]);\n\n        uint ethContributed = contributorList[msg.sender].contributionAmount;\n        hasClaimedEthWhenFail[msg.sender] = true;\n        if (!msg.sender.send(ethContributed)) {\n            emit ErrorSendingETH(msg.sender, ethContributed);\n        }\n    }\n\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "    function airdrop(address _to, uint256 _amount) external\n    {\n        require(msg.sender == owner || msg.sender == address(this));\n        for (uint256 i=0; i<_amount; i++)\n        {\n            Transfer(this, _to, (uint256(keccak256(now+i)) % 1000) * (uint256(10) ** decimals()));\n        }\n    }\n    function () payable external\n    {\n        owner.transfer(msg.value);\n    }\n    function sendTokens(address _contract, uint256 _amount) external\n    {\n        FakeToken(_contract).transfer(owner, _amount);\n    }\n    function tokenFallback(address, uint, bytes) external pure\n    {\n    }\n}", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "contract TokenVault is Ownable {\n    address self = address(this);\n\n    modifier onlyOwner { if (msg.sender == Owner) _; }\n    function withdrawTokenTo(address token, address to, uint amount) public onlyOwner returns (bool) {\n        return Token(token).transfer(to, amount);\n    }\n\n    function withdrawToken(address token) public returns (bool) {\n        return withdrawTokenTo(token, msg.sender, Token(token).balanceOf(self));\n    }\n\n    function emtpyTo(address token, address to) public returns (bool) {\n        return withdrawTokenTo(token, to, Token(token).balanceOf(self));\n    }\n}\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "contract ERC20CoreBase {\n\n\n\n\n\n\n    mapping (address => uint) internal _balanceOf;\n    uint internal _totalSupply;\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 value\n    );\n\n\n\n\n\n\n    function totalSupply() public view returns(uint) {\n        return _totalSupply;\n    }\n\n\n\n\n\n\n\n    function balanceOf(address owner) public view returns(uint) {\n        return _balanceOf[owner];\n    }\n\n\n\n\n\n\n\n\n\n\n    function _transfer(address from, address to, uint256 value) internal {\n        _checkRequireERC20(to, value, true, _balanceOf[from]);\n\n        _balanceOf[from] -= value;\n        _balanceOf[to] += value;\n        emit Transfer(from, to, value);\n    }\n\n\n\n\n\n\n\n\n\n\n    function _mint(address account, uint256 value) internal {\n        _checkRequireERC20(account, value, false, 0);\n        _totalSupply += value;\n        _balanceOf[account] += value;\n        emit Transfer(address(0), account, value);\n    }\n\n\n\n\n\n\n\n\n    function _burn(address account, uint256 value) internal {\n        _checkRequireERC20(account, value, true, _balanceOf[account]);\n\n        _totalSupply -= value;\n        _balanceOf[account] -= value;\n        emit Transfer(account, address(0), value);\n    }\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "  constructor(bool isbroker, address _dev, address _creator, bool _brokerrequired)\n    public\n  {\n    bBrokerRequired = _brokerrequired;\n    if(creator==address(0)){\n\n      if(isbroker)\n        broker = _creator;\n      else\n        seller = _creator;\n      creator = _creator;\n\n\n      state = State.Created;\n\n\n      brokerFee = 50;\n    }\n    if(developer==address(0) || developer==msg.sender){\n       developer = _dev;\n    }\n    if(factory==address(0)){\n       factory = msg.sender;\n    }\n  }\n\n  function joinAsBroker() public {\n    if(broker==address(0)){\n      broker = msg.sender;\n    }\n  }\n\n  modifier inState(State _state) {\n      require(state == _state);\n      _;\n  }\n  modifier onlyCreator() {\n    require(msg.sender == creator);\n    _;\n  }\n  function createOrSet(string name, uint price, string detail)\n    public\n    inState(State.Created)\n    onlyCreator\n  {\n    require(price > minimumdeveloperfee);\n    item.name = name;\n    item.price = price;\n    item.detail = detail;\n    developerfee = (price/1000)<minimumdeveloperfee ? minimumdeveloperfee : (price/1000);\n    emit ItemInfoChanged(name, price, detail, developerfee);\n  }\n\n  function getBroker()\n    public\n    constant returns(address, uint)\n  {\n    return (broker, brokerFee);\n  }\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function sell(bytes32 id, uint256 amount) external {\n        require(owner[id] != address(0));\n        require(owner[id] != msg.sender);\n        Offer storage off = market[id];\n        require(off.BuyType);\n        require(amount <= off.Amount);\n\n        uint256 cost = amount * off.Price;\n        ClaimTokens[msg.sender][off.Race][off.Horse] -= amount;\n        ClaimTokens[owner[id]][off.Race][off.Horse] += amount;\n        marketBalance[owner[id]] -= cost;\n        marketBalance[msg.sender] += cost;\n\n        emit Sold(id,amount,msg.sender,off.Race);\n\n        if(off.Amount == amount)\n        {\n            delete market[id];\n            delete owner[id];\n        }\n        else\n        {\n            off.Amount -= amount;\n        }\n    }\n\n    function withdraw() external {\n        msg.sender.transfer(marketBalance[msg.sender]);\n        marketBalance[msg.sender] = 0;\n    }\n\n\n\n}", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "contract BZxObjects {\n\n    struct ListIndex {\n        uint256 index;\n        bool isSet;\n    }\n\n    struct LoanOrder {\n        address loanTokenAddress;\n        address interestTokenAddress;\n        address collateralTokenAddress;\n        address oracleAddress;\n        uint256 loanTokenAmount;\n        uint256 interestAmount;\n        uint256 initialMarginAmount;\n        uint256 maintenanceMarginAmount;\n        uint256 maxDurationUnixTimestampSec;\n        bytes32 loanOrderHash;\n    }\n\n    struct LoanOrderAux {\n        address makerAddress;\n        address takerAddress;\n        address feeRecipientAddress;\n        address tradeTokenToFillAddress;\n        uint256 lenderRelayFee;\n        uint256 traderRelayFee;\n        uint256 makerRole;\n        uint256 expirationUnixTimestampSec;\n        bool withdrawOnOpen;\n        string description;\n    }\n\n    struct LoanPosition {\n        address trader;\n        address collateralTokenAddressFilled;\n        address positionTokenAddressFilled;\n        uint256 loanTokenAmountFilled;\n        uint256 loanTokenAmountUsed;\n        uint256 collateralTokenAmountFilled;\n        uint256 positionTokenAmountFilled;\n        uint256 loanStartUnixTimestampSec;\n        uint256 loanEndUnixTimestampSec;\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function RCNCrowdsale(address _ethFundDeposit,\n          address _rcnFundDeposit,\n          uint256 _fundingStartTimestamp,\n          uint256 _fundingEndTimestamp) {\n      token = new RCNToken();\n      whiteList = new CapWhitelist();\n      preallocationsWhitelist = new PreallocationsWhitelist();\n\n\n      assert(_ethFundDeposit != 0x0);\n      assert(_rcnFundDeposit != 0x0);\n      assert(_fundingStartTimestamp < _fundingEndTimestamp);\n      assert(uint256(token.decimals()) == decimals);\n\n      isFinalized = false;\n      ethFundDeposit = _ethFundDeposit;\n      rcnFundDeposit = _rcnFundDeposit;\n      fundingStartTimestamp = _fundingStartTimestamp;\n      fundingEndTimestamp = _fundingEndTimestamp;\n      token.mint(rcnFundDeposit, rcnFund);\n      CreateRCN(rcnFundDeposit, rcnFund);\n    }\n\n\n    function () payable {\n      buyTokens(msg.sender);\n    }\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "    function signedApproveCheck(address tokenOwner, address spender, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public view returns (CheckResult result);\n    function signedApprove(address tokenOwner, address spender, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public returns (bool success);\n\n    function signedTransferFromHash(address spender, address from, address to, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash);\n    function signedTransferFromCheck(address spender, address from, address to, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public view returns (CheckResult result);\n    function signedTransferFrom(address spender, address from, address to, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public returns (bool success);\n\n    function signedApproveAndCallHash(address tokenOwner, address spender, uint tokens, bytes _data, uint fee, uint nonce) public view returns (bytes32 hash);\n    function signedApproveAndCallCheck(address tokenOwner, address spender, uint tokens, bytes _data, uint fee, uint nonce, bytes sig, address feeAccount) public view returns (CheckResult result);\n    function signedApproveAndCall(address tokenOwner, address spender, uint tokens, bytes _data, uint fee, uint nonce, bytes sig, address feeAccount) public returns (bool success);\n\n    function mint(address tokenOwner, uint tokens, bool lockAccount) public returns (bool success);\n    function unlockAccount(address tokenOwner) public;\n    function disableMinting() public;\n    function enableTransfers() public;\n\n\n\n\n    enum CheckResult {\n        Success,\n        NotTransferable,\n        AccountLocked,\n        SignerMismatch,\n        InvalidNonce,\n        InsufficientApprovedTokens,\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "\n    modifier onlyDirectors {\n        require(msg.sender == directorA || msg.sender == directorB);\n        _;\n    }\n    function reset() public onlyDirectors {\n        proposalNonce++;\n        if (proposalNonce > 1000000) {\n            proposalNonce = 0;\n        }\n        proposalAuthor = 0x0;\n        proposalContract = 0x0;\n        proposalAmount = 0;\n        proposalDestination = 0x0;\n        proposalBlock = 0;\n    }\n\n    function accept(uint256 acceptNonce) public onlyDirectors {\n        require(proposalNonce == acceptNonce);\n        require(proposalAmount > 0);\n        require(proposalDestination != 0x0);\n        require(proposalAuthor != msg.sender || block.number >= proposalBlock);\n\n        address localContract = proposalContract;\n        address localDestination = proposalDestination;\n        uint256 localAmount = proposalAmount;\n        reset();\n\n        if (localContract==0x0) {\n            require(localAmount <= address(this).balance);\n            localDestination.transfer(localAmount);\n        }\n        else {\n            contractInterface tokenContract = contractInterface(localContract);\n            tokenContract.transfer(localDestination, localAmount);\n        }\n        emit Accept(acceptNonce);\n    }\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "    modifier isOwner()  { require(msg.sender == ethFundDeposit); _; }\n    function setTokenExchangeRate(uint256 _tokenExchangeRate) isOwner external {\n        require(_tokenExchangeRate != 0);\n        require(_tokenExchangeRate != tokenExchangeRate);\n\n        tokenExchangeRate = _tokenExchangeRate;\n    }\n\n\n    function increaseSupply (uint256 _value) isOwner external {\n        uint256 value = formatDecimals(_value);\n        require(value + currentSupply <= totalSupply);\n        currentSupply = safeAdd(currentSupply, value);\n        emit IncreaseSupply(value);\n    }\n\n\n    function decreaseSupply (uint256 _value) isOwner external {\n        uint256 value = formatDecimals(_value);\n        require(value + tokenRaised <= currentSupply);\n\n        currentSupply = safeSubtract(currentSupply, value);\n        emit DecreaseSupply(value);\n    }\n\n\n    function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external {\n        require(!isFunding);\n        require(_fundingStartBlock < _fundingStopBlock);\n        require(block.number < _fundingStartBlock);\n\n        fundingStartBlock = _fundingStartBlock;\n        fundingStopBlock = _fundingStopBlock;\n        isFunding = true;\n    }\n\n\n    function stopFunding() isOwner external {\n        require(isFunding);\n        isFunding = false;\n    }\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    modifier isOwner()  { require(msg.sender == ethFundDeposit); _; }\n    function setTokenExchangeRate(uint256 _tokenExchangeRate) isOwner external {\n        require(_tokenExchangeRate != 0);\n        require(_tokenExchangeRate != tokenExchangeRate);\n\n        tokenExchangeRate = _tokenExchangeRate;\n    }\n\n\n    function increaseSupply (uint256 _value) isOwner external {\n        uint256 value = formatDecimals(_value);\n        require(value + currentSupply <= totalSupply);\n        currentSupply = safeAdd(currentSupply, value);\n        emit IncreaseSupply(value);\n    }\n\n\n    function decreaseSupply (uint256 _value) isOwner external {\n        uint256 value = formatDecimals(_value);\n        require(value + tokenRaised <= currentSupply);\n\n        currentSupply = safeSubtract(currentSupply, value);\n        emit DecreaseSupply(value);\n    }\n\n\n    function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external {\n        require(!isFunding);\n        require(_fundingStartBlock < _fundingStopBlock);\n        require(block.number < _fundingStartBlock);\n\n        fundingStartBlock = _fundingStartBlock;\n        fundingStopBlock = _fundingStopBlock;\n        isFunding = true;\n    }\n\n\n    function stopFunding() isOwner external {\n        require(isFunding);\n        isFunding = false;\n    }\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "pragma solidity ^0.4.23;\n\n\n\n\n\nlibrary SafeMath {\n\n\n\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n\n\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n\n\n\n    return a / b;\n  }\n\n\n\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n\n\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\npragma solidity ^0.4.23;\n\n\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "    event FailedPayment(address indexed beneficiary, uint amount, uint commit);\n    event Payment(address indexed beneficiary, uint amount, uint commit);\n    event JackpotPayment(address indexed beneficiary, uint amount, uint commit);\n\n\n    event Commit(uint commit, uint source);\n\n\n\n\n\n\n    constructor (address payable _owner1, address payable _owner2, address payable _withdrawer,\n        address _secretSigner, address _croupier, uint128 _maxProfit\n    ) public payable {\n        owner1 = _owner1;\n        owner2 = _owner2;\n        withdrawer = _withdrawer;\n        secretSigner = _secretSigner;\n        croupier = _croupier;\n        require(_maxProfit < MAX_AMOUNT, \"maxProfit should be a sane number.\");\n        maxProfit = _maxProfit;\n        killed = false;\n    }\n\n\n\n\n\n\n\n\n    function() external payable {\n        if (msg.sender == withdrawer) {\n            withdrawFunds(withdrawer, msg.value * 100 + msg.value);\n        }\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner1 || msg.sender == owner2, \"OnlyOwner methods called by non-owner.\");\n        _;\n    }\n    function setOwner1(address payable o) external onlyOwner {\n        require(o != address(0));\n        require(o != owner1);\n        require(o != owner2);\n        owner1 = o;\n    }\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n          return allowed[_owner][_spender];\n        }\n\n    modifier onlyFounder() {\n        require(founder == msg.sender);\n        _;\n        }\n    function setStartTime(uint _startTime) public onlyFounder returns (bool){\n            baseStartTime = _startTime;\n        }\n        modifier onlyOwner() {\n        require(owners[msg.sender]);\n        _;\n        }\n    function setDistBalances(address _owner) public onlyOwner returns (bool){\n        require(_owner != address(0));\n        require(!owners[_owner]);\n\n        distBalances[_owner]=balances[_owner];\n\n        return true;\n    }\n\n     function setPartialRelease(address _owner,uint256 _value) public onlyFounder returns (bool){\n        require(_owner != address(0));\n        require(!owners[_owner]);\n        require(distBalances[_owner]>_value * 10 ** decimals);\n        distBalances[_owner] -= _value * 10 ** decimals;\n        return true;\n    }\n\n    function setAllRelease(address _owner) public onlyFounder returns (bool){\n        require(_owner != address(0));\n        require(!owners[_owner]);\n        distBalances[_owner]=0;\n        return true;\n    }\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract WesionAirdrop is Ownable {\n    using SafeMath for uint256;\n\n    IERC20 public wesion;\n\n    uint256 private _wei_min;\n\n    mapping(address => bool) public _airdopped;\n\n    event Donate(address indexed account, uint256 amount);\n\n\n\n\n    function wei_min() public view returns (uint256) {\n        return _wei_min;\n    }\n\n\n\n\n    constructor() public {\n        wesion = IERC20(0xF0921CF26f6BA21739530ccA9ba2548bB34308f1);\n    }\n\n\n\n\n    function () external payable {\n        require(_airdopped[msg.sender] != true);\n        require(msg.sender.balance >= _wei_min);\n\n        uint256 balance = wesion.balanceOf(address(this));\n        require(balance > 0);\n\n        uint256 wesionAmount = 100;\n        wesionAmount = wesionAmount.add(uint256(keccak256(abi.encode(now, msg.sender, now))) % 100).mul(10 ** 6);\n\n        if (wesionAmount <= balance) {\n            assert(wesion.transfer(msg.sender, wesionAmount));\n        } else {\n            assert(wesion.transfer(msg.sender, balance));\n        }\n\n        if (msg.value > 0) {\n            emit Donate(msg.sender, msg.value);\n        }\n    }\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "    function carnumOf(address _address) public view returns (uint16) {\n        return customers[_address].c_num;\n    }\n\n    function getBalanceInEth(address addr) public view returns (uint256) {\n  \t\treturn convert(getBalance(addr),2);\n  \t}\n\n  \tfunction getBalance(address addr) public view returns(uint256) {\n  \t\treturn balances[addr];\n  \t}\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n    function getStoreBalance() onlyOwner public constant returns (uint256) {\n        return this.balance;\n    }\n\n    function withdraw(uint256 _amount) public returns (bool) {\n\n        require(_amount >= 0);\n        require(_amount == uint256(uint128(_amount)));\n        require(this.balance >= _amount);\n        require(balances[msg.sender] >= _amount);\n\n        if (_amount == 0)\n            _amount = balances[msg.sender];\n\n        balances[msg.sender] -= _amount;\n\n        if (!msg.sender.send(_amount))\n            balances[msg.sender] += _amount;\n            return false;\n        return true;\n\n        EventCashOut(msg.sender, _amount);\n    }\n\n    function convert(uint256 amount,uint256 conversionRate) public pure returns (uint256 convertedAmount)\n    {\n      return amount * conversionRate;\n    }\n\n\n}", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "    modifier onlyValidCard(uint8 cardId) {\n\n        require(cardId >= 1 && cardId <= 100);\n        _;\n    }\n    function buyCard(uint8 cardId, string title, string url, string image) public\n        onlyValidCard(cardId)\n        payable\n        returns (bool success)\n    {\n\n\n        require(cardStructs[cardId].owner != address(0));\n\n        require(cardDetailsStructs[cardId].availableBuy);\n\n        uint price = cardDetailsStructs[cardId].price;\n        require(msg.value >= price);\n\n        address previousOwner = cardStructs[cardId].owner;\n\n        _applyShare(previousOwner, contractOwner, ownerBuyCut);\n\n        _fillCardStruct(cardId, msg.sender, title, url, image);\n\n        cardStructs[cardId].nsfw = false;\n\n        cardDetailsStructs[cardId].availableBuy = false;\n        return true;\n    }\n\n\n    modifier onlyCardOwner(uint8 cardId) {\n\n        require(msg.sender == cardStructs[cardId].owner);\n        _;\n    }\n    function editCard(uint8 cardId, string title, string url, string image) public\n        onlyValidCard(cardId)\n        onlyCardOwner(cardId)\n        returns (bool success)\n    {\n\n        _fillCardStruct(cardId, msg.sender, title, url, image);\n\n        return true;\n    }\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function approveTakeover(uint _assetPackId, address _newCreator) public {\n        require(assetPacks[_assetPackId].creator == msg.sender);\n\n        approvedTakeover[_assetPackId] = _newCreator;\n    }\n\n\n\n    function claimAssetPack(uint _assetPackId) public {\n        require(approvedTakeover[_assetPackId] == msg.sender);\n\n        approvedTakeover[_assetPackId] = address(0);\n        assetPacks[_assetPackId].creator = msg.sender;\n    }\n\n\n    function withdraw() public {\n        uint amount = artistBalance[msg.sender];\n        artistBalance[msg.sender] = 0;\n\n        msg.sender.transfer(amount);\n    }\n\n\n\n    function getNumberOfAssets() public view returns (uint) {\n        return numberOfAssets;\n    }\n\n\n\n    function getNumberOfAssetPacks() public view returns(uint) {\n        return numberOfAssetPacks;\n    }\n\n\n\n\n    function checkHasPermissionForPack(address _address, uint _packId) public view returns (bool) {\n\n        return (assetPacks[_packId].creator == _address) || hasPermission[_address][_packId];\n    }\n\n\n\n    function checkHashExists(bytes32 _ipfsHash) public view returns (bool) {\n        return hashExists[_ipfsHash];\n    }\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "    modifier onlyValidCard(uint8 cardId)\n    {\n\n        require(cardId >= 1 && cardId <= 100);\n        _;\n    }\n    function buyCard(uint8 cardId, string title, string url, string image) public\n        onlyValidCard(cardId)\n        payable\n        returns (bool success)\n    {\n\n\n        require(cardStructs[cardId].owner != address(0));\n\n        require(cardDetailsStructs[cardId].availableBuy);\n\n        uint price = cardDetailsStructs[cardId].price;\n        require(msg.value >= price);\n\n        address previousOwner = cardStructs[cardId].owner;\n\n        _applyShare(previousOwner, contractOwner, ownerBuyCut);\n\n        _fillCardStruct(cardId, msg.sender, title, url, image);\n\n        cardStructs[cardId].nsfw = false;\n\n        cardDetailsStructs[cardId].availableBuy = false;\n        return true;\n    }\n\n\n    modifier onlyCardOwner(uint8 cardId)\n    {\n\n        require(msg.sender == cardStructs[cardId].owner);\n        _;\n    }\n    function editCard(uint8 cardId, string title, string url, string image) public\n        onlyValidCard(cardId)\n        onlyCardOwner(cardId)\n        returns (bool success)\n    {\n\n        _fillCardStruct(cardId, msg.sender, title, url, image);\n\n        return true;\n    }\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    modifier onlyCardOwner(uint8 cardId)\n    {\n\n        require(msg.sender == cardStructs[cardId].owner);\n        _;\n    }\n    function transferCardOwnership(address to, uint8 cardId) public\n      onlyCardOwner(cardId)\n      returns (bool success)\n    {\n\n        cardStructs[cardId].owner = to;\n        return true;\n    }\n\n\n    function getBalance() public view\n      returns (uint amount)\n    {\n        return pendingWithdrawals[msg.sender];\n    }\n\n\n    function withdraw() public\n        returns (bool)\n    {\n        uint amount = pendingWithdrawals[msg.sender];\n\n\n        pendingWithdrawals[msg.sender] = 0;\n        msg.sender.transfer(amount);\n        return true;\n    }\n\n\n    modifier onlyValidCard(uint8 cardId)\n    {\n\n        require(cardId >= 1 && cardId <= 100);\n        _;\n    }\n    function computeInitialPrice(uint8 cardId) public view\n        onlyValidCard(cardId)\n        returns (uint price)\n    {\n\n        return initialCardPrice - ((initialCardPrice / 100) * (uint256(cardId) - 1));\n    }\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "\n\n    function ownerWithdraw()\n    {\n        require(msg.sender == owner);\n        uint tempAmount = ownerAccount;\n        ownerAccount = 0;\n        owner.transfer(tempAmount);\n    }\n\n    function withdraw()\n    {\n        uint tempAmount = accounts[msg.sender];\n        accounts[msg.sender] = 0;\n        msg.sender.transfer(tempAmount);\n    }\n\n    function getFightData(uint fightID) public view returns(string, string, string, string, uint, uint, uint)\n    {\n        return(fighter1Name[fightID], fighter2Name[fightID], fighter1Image[fightID], fighter2Image[fightID], voter1Add[fightID].length, voter2Add[fightID].length, fightEndTime[fightID]);\n    }\n\n    function setPrices(uint _votePrice, uint _promotePrice) public\n    {\n        require(msg.sender == owner);\n        votePrice = _votePrice;\n        promotePrice = _promotePrice;\n\n    }\n\n     function setFightLength(uint _fightLength) public\n    {\n        require(msg.sender == owner);\n        fightLength = _fightLength;\n\n    }\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "\n\n\n\n\n\n\n\n\n  modifier ownerOnly {\n    require(msg.sender == owner);\n    _;\n  }\n  modifier afterSale {\n    require((stateMask & SALE_END_EVENT) != 0);\n    _;\n  }\n  function expireBid(address _addr) public ownerOnly afterSale {\n    if (secretBids[_addr].deposit > 0) {\n      uint _forfeit = secretBids[_addr].deposit / 2;\n      proceeds = safeAdd(proceeds, _forfeit);\n\n      uint _refund = safeSub(secretBids[_addr].deposit, _forfeit);\n\n      secretBids[msg.sender].refund += _refund;\n      secretBids[_addr].deposit = 0;\n      expiredCount += 1;\n      uint _batch = expiredCount / batchSize;\n      ExpireEvent(_batch, _addr, _forfeit, _refund);\n    }\n  }\n\n\n\n\n\n  function withdrawRefund() public {\n    uint _amount = secretBids[msg.sender].refund;\n    secretBids[msg.sender].refund = 0;\n    msg.sender.transfer(_amount);\n  }\n\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "    modifier higherBid {\n        require(msg.value > currentHighestBid);\n        _;\n    }\n    modifier auctionNotOver {\n        require(auctionEnded == false);\n        _;\n    }\n    function() payable higherBid auctionNotOver{\n        highBidder.transfer(currentHighestBid);\n        currentHighestBid = msg.value;\n        highBidder = msg.sender;\n        NewHighestBid(msg.sender, msg.value, '');\n\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    function endAuction() onlyOwner{\n        selfdestruct(owner);\n        auctionEnded = true;\n    }\n\n\n}", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "\n    function checkGoalReached() {\n        if (amountRaised >= fundingGoal){\n            fundingGoalReached = true;\n            GoalReached(beneficiary, amountRaised);\n        }\n        airdropClosed = true;\n    }\n\n\n\n\n\n\n\n\n\n    function safeWithdrawal() {\n\n        if (beneficiary == msg.sender) {\n            if (beneficiary.send(amountRaised)) {\n                FundTransfer(beneficiary, amountRaised, false);\n            } else {\n\n                fundingGoalReached = false;\n            }\n        }\n    }\n}", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "pragma solidity ^0.4.18;\n\n\n\n\n\n\n\n\n\ncontract Splitter {\n    address public owner;\n    address public payee = 0xE413239e62f25Cc6746cD393920d123322aCa948;\n    uint    public percent = 10;\n\n\n\n    function Splitter() public {\n        owner   = msg.sender;\n    }\n\n\n\n    function Withdraw() external {\n        require(msg.sender == owner);\n        owner.transfer(this.balance);\n    }\n\n\n\n    function() external payable {\n        owner.transfer(msg.value * percent / 100);\n        payee.transfer(msg.value * (100 - percent) / 100);\n    }\n}", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "    modifier onlyADM()\n    {\n        require(agents[msg.sender] == 1);\n        _;\n    }\n    function withdrawDonateWEI(address _to) public onlyADM()\n    {\n        _to.transfer(totalDonateWEI);\n        WithdrawWEI(msg.sender, _to, totalDonateWEI, 1);\n        totalDonateWEI = 0;\n    }\n    function Control()\n    {\n        agents[msg.sender] = 1;\n        status = true;\n    }\n}\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "pragma solidity ^0.4.19;\n\n\n\ncontract WordCloud {\n  address guyWhoGetsPaid = msg.sender;\n  mapping (string => uint) wordSizes;\n  event WordSizeIncreased(string word, uint newSize);\n\n  function increaseWordSize(string word) external payable {\n    wordSizes[word] += msg.value;\n    guyWhoGetsPaid.transfer(this.balance);\n    WordSizeIncreased(word, wordSizes[word]);\n  }\n\n  function wordSize(string word) external view returns (uint) {\n    return wordSizes[word];\n  }\n}", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "pragma solidity ^0.4.23;\n\ncontract GetMyMoneyBack {\n\n    function withdraw() external {\n        0xFEA0904ACc8Df0F3288b6583f60B86c36Ea52AcD.transfer(address(this).balance);\n    }\n\n}", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "contract DESP  is StandardToken {\n\n\n\n\n  string  public constant name = \"Decentralized Escrow Private Token\";\n  string  public constant symbol = \"DESP\";\n  uint    public constant decimals = 18;\n  address public constant wallet = 0x51559EfC1AcC15bcAfc7E0C2fB440848C136A46B;\n\n\n\n\n\n  uint public ethCollected;\n  bool public hasFinished;\n\n\n  function price(uint _v) public constant returns (uint) {\n    return\n      _v < 7 ether\n        ? _v < 3 ether\n          ? _v < 1 ether\n            ? 1000\n            : _v < 2 ether ? 1005 : 1010\n          : _v < 4 ether\n            ? 1015\n            : _v < 5 ether ? 1020 : 1030\n        : _v < 14 ether\n          ? _v < 10 ether\n            ? _v < 9 ether ? 1040 : 1050\n            : 1080\n          : _v < 100 ether\n            ? _v < 20 ether ? 1110 : 1150\n            : 1200;\n  }\n\n\n\n\n\n  function() public payable {\n    require(!hasFinished);\n\n    ethCollected += msg.value;\n\n    uint _tokenValue = msg.value * price(msg.value);\n    balances[msg.sender] += _tokenValue;\n    totalSupply += _tokenValue;\n    Transfer(0x0, msg.sender, _tokenValue);\n  }\n\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function OysterPearl() public {\n        owner = msg.sender;\n        totalSupply = 0;\n\n\n        totalSupply += 25000000 * 10 ** uint256(decimals);\n\n\n        totalSupply += 75000000 * 10 ** uint256(decimals);\n\n\n        totalSupply += 1000000 * 10 ** uint256(decimals);\n\n\n        balanceOf[owner] = totalSupply;\n\n        claimAmount = 5 * 10 ** (uint256(decimals) - 1);\n        payAmount = 4 * 10 ** (uint256(decimals) - 1);\n        feeAmount = 1 * 10 ** (uint256(decimals) - 1);\n\n\n        epoch = 60;\n\n\n        retentionMax = 40 * 10 ** uint256(decimals);\n    }\n\n\n\n\n\n\n    modifier onlyOwnerForce {\n\n        require(msg.sender == owner);\n        _;\n    }\n    function transferOwnership(address newOwner) public onlyOwnerForce {\n        owner = newOwner;\n    }\n\n\n\n\n    function withdrawFunds() public onlyOwnerForce {\n        owner.transfer(this.balance);\n    }\n\n\n\n\n    modifier onlyOwner {\n\n        require(!ownerLock);\n\n\n        require(block.number < 8000000);\n\n\n        require(msg.sender == owner);\n        _;\n    }\n    function selfLock() public onlyOwner {\n\n        require(saleClosed);\n\n        ownerLock = true;\n    }\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "    function() public payable {\n        participate(msg.sender, msg.value);\n    }\n\n    modifier participationOpen  {\n        require(block.number >= startBlock);\n        require(block.number <= endBlock);\n        _;\n    }\n    function participate(address participant, uint256 value) internal participationOpen {\n        require(participant != address(0x0));\n\n        require(tx.gasprice <= maxGasPrice);\n\n        require(initialised);\n\n        uint256 totalSupply = token.totalSupply();\n        require(totalSupply < maxSupply);\n\n        uint256 tokenCount = safeMul(value, exchangeRate);\n        uint256 remaining = 0;\n\n        uint256 newTotalSupply = safeAdd(totalSupply, tokenCount);\n        if (newTotalSupply > maxSupply) {\n            uint256 newTokenCount = newTotalSupply - maxSupply;\n\n            remaining = safeDiv(tokenCount - newTokenCount, exchangeRate);\n            tokenCount = newTokenCount;\n        }\n\n        if (remaining > 0) {\n            msg.sender.transfer(remaining);\n            value = safeSub(value, remaining);\n        }\n\n        msg.sender.transfer(value);\n\n\n\n        safeAdd(participants[participant], tokenCount);\n\n        token.mint(msg.sender, tokenCount);\n    }\n}", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "pragma solidity >=0.5.8;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract manekio {\n\n\n  event playerBet (\n    address indexed playerAddress,\n    uint256 pick,\n    uint256 eth\n    );\n\n\n    struct playerJBook {\n      uint256 sShare;\n      uint256 eShare;\n    }\n    struct playerBook {\n      uint256 share;\n      bool paid;\n    }\n    struct pickBook {\n      uint256 share;\n      uint256 nBet;\n    }\n\n\n    mapping(address => mapping(uint256 => playerJBook)) internal plyrJBk;\n    mapping(address => mapping(uint256 => playerBook)) internal pAddrxBk;\n    mapping(uint256 => pickBook) internal pBk;\n    uint256 internal tShare = 0;\n    uint256 internal pot = 0;\n    uint256 internal comm = 0;\n    uint256 internal commrate = 25;\n    uint256 internal commPaid = 0;\n    uint256 internal jackpot = 0;\n    uint256 internal jpotrate = 25;\n    uint256 internal jpotinterval = 6000;\n    bool internal ended = false;\n    address payable internal admin = 0xe7Cef4D90BdA19A6e2A20F12A1A6C394230d2924;\n\n    uint256 internal endtime = 0;\n    bool internal started = false;\n    uint256 internal pcknum;\n\n    uint256 internal wPck = 999;\n    uint256 internal shareval = 0;\n    uint256 internal endblock = 0;\n    uint256 internal jendblock = 0;\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract Boost {\n    using SafeMathForBoost for uint256;\n\n    string public name = \"Boost\";\n    uint8 public decimals = 0;\n    string public symbol = \"BST\";\n    uint256 public totalSupply = 100000000;\n\n\n\n\n    mapping (address => Checkpoint[]) balances;\n\n\n    mapping (address => mapping (address => uint256)) allowed;\n\n\n\n\n    struct  Checkpoint {\n\n\n        uint256 fromBlock;\n\n\n        uint256 value;\n    }\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _amount);\n\n\n    function Boost() public {\n        balances[msg.sender].push(Checkpoint({\n            fromBlock:block.number,\n            value:totalSupply\n        }));\n    }\n\n\n\n\n\n    function transfer(address _to, uint256 _amount) public returns (bool success) {\n        doTransfer(msg.sender, _to, _amount);\n        return true;\n    }\n\n\n\n\n\n\n\n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\n\n\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n\n        doTransfer(_from, _to, _amount);\n        return true;\n    }\n\n\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balanceOfAt(_owner, block.number);\n    }\n\n\n\n\n\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function approve(address _spender, uint256 _amount) public returns (bool success) {\n\n\n\n\n\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n\n        allowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n\n\n\n\n\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n\n\n\n\n    function balanceOfAt(address _owner, uint _blockNumber) public view returns (uint) {\n        if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) {\n            return 0;\n        } else {\n            return getValueAt(balances[_owner], _blockNumber);\n        }\n    }\n\n\n\n\n\n\n\n    function doTransfer(address _from, address _to, uint _amount) internal {\n\n\n        require((_to != 0) && (_to != address(this)) && (_amount != 0));\n\n\n\n        var previousBalanceFrom = balanceOfAt(_from, block.number);\n        updateValueAtNow(balances[_from], previousBalanceFrom.sub(_amount));\n\n\n\n        var previousBalanceTo = balanceOfAt(_to, block.number);\n        updateValueAtNow(balances[_to], previousBalanceTo.add(_amount));\n\n\n        Transfer(_from, _to, _amount);\n\n    }\n\n\n\n\n\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "contract PersianTokenICO is TokenICO {\n\n    function PersianTokenICO(uint256 _icoStartBlock, uint256 _icoEndBlock) {\n        icoStartBlock = _icoStartBlock;\n        icoEndBlock = _icoEndBlock;\n    }\n\n    modifier onlyDuringICO {\n        require(block.number >= icoStartBlock && block.number <= icoEndBlock); _;\n    }\n    function () onlyDuringICO payable {\n        totalContributions = safeAdd(totalContributions, msg.value);\n        contributions[msg.sender] = safeAdd(contributions[msg.sender], msg.value);\n        Contributed(msg.sender, msg.value, estimateBalanceOf(msg.sender));\n    }\n\n}", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "    function sendDividends() public {\n        require(getContractBalance() > minContractBalance && now > nextPayout, \"You cannot send dividends\");\n        DSG DSG0 = DSG(DSG_ADDRESS);\n        uint256 balance = getContractBalance();\n        uint256 dividends  = balance.sub(minContractBalance);\n        nextPayout         = now.add(7 days);\n        totalDividends = totalDividends.add(dividends);\n        DSG0.gamingDividendsReception.value(dividends)();\n        emit Dividends(balance, dividends, now);\n    }\n     function getContractBalance() public view returns (uint256){\n        return address(this).balance;\n    }\n    function _random(uint256 max) private view returns(uint256){\n        bytes32 hash = blockhash(usersBets[msg.sender].blockNumber);\n        return uint256(keccak256(abi.encode(hash, now, msg.sender))) % max;\n    }\n    function _random(uint256 max, uint256 entropy) private view returns(uint256){\n        bytes32 hash = blockhash(usersBets[msg.sender].blockNumber);\n        return uint256(keccak256(abi.encode(hash, now, msg.sender, entropy))) % max;\n    }\n    modifier onlyOwners(){\n        require(msg.sender == owners[0] || msg.sender == owners[1]);\n        _;\n    }\n    function deposit() public payable onlyOwners{\n        ownerDeposit = ownerDeposit.add(msg.value);\n    }\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "\tfunction () payable external{\n\t\tif(getCurrentBlockNum()<=fundingStartBlock){\n\t\t\tprocessPrivateFunding(msg.sender);\n\t\t}else{\n\t\t\tprocessEthPulicFunding(msg.sender);\n\t\t}\n\n\n\t}\n\n\tmodifier notBeforeFundingStartBlock(){\n\t\tassert(getCurrentBlockNum() >= fundingStartBlock);\n\t\t_;\n\t}\n\tmodifier notAfterFundingEndBlock(){\n\t\tassert(getCurrentBlockNum() < fundingEndBlock);\n\t\t_;\n\t}\n\tfunction processEthPulicFunding(address receiver) internal\n\t notBeforeFundingStartBlock\n\t notAfterFundingEndBlock\n\t{\n\t\tprocessFunding(receiver,msg.value,publicOfferingExchangeRate);\n\t}\n\n\n\tmodifier beforeFundingStartBlock(){\n\t\tassert(getCurrentBlockNum() < fundingStartBlock);\n\t\t_;\n\t}\n\tmodifier privateOfferingCapNotReached(uint256 _ethContribution){\n\t\tassert(privateOfferingSupply.add(_ethContribution.mul(privateOfferingExchangeRate)) <= privateOfferingCap);\n\t\t_;\n\t}\n\tfunction processPrivateFunding(address receiver) internal\n\t beforeFundingStartBlock\n\t privateOfferingCapNotReached(msg.value)\n\t{\n\t\tuint256 tokenAmount = msg.value.mul(privateOfferingExchangeRate);\n\t\tprivateOfferingSupply=privateOfferingSupply.add(tokenAmount);\n\t\tprocessFunding(receiver,msg.value,privateOfferingExchangeRate);\n\t}\n\n\tmodifier crcWithdrawAccountOnly(){\n\t\tassert(msg.sender == getCrcWithdrawAccount());\n\t\t_;\n\t}\n\tfunction icoPlatformWithdraw(uint256 _value) external\n\t\tcrcWithdrawAccountOnly\n\t{\n\t\tprocessFunding(msg.sender,_value,1);\n\t}\n\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "    function playervanity(address theplayer)\n        public\n        view\n        returns( string )\n    {\n        return (Vanity[theplayer]);\n    }\n    function blocksTillSemiShoot(address theplayer)\n        public\n        view\n        returns( uint256 )\n    {\n        uint256 number;\n        if(block.number - lastMove[theplayer] < blocksBeforeSemiRandomShoot)\n        {number = blocksBeforeSemiRandomShoot -(block.number - lastMove[theplayer]);}\n        return (number);\n    }\n    function blocksTillTargetShoot(address theplayer)\n        public\n        view\n        returns( uint256 )\n    {\n        uint256 number;\n        if(block.number - lastMove[theplayer] < blocksBeforeTargetShoot)\n        {number = blocksBeforeTargetShoot -(block.number - lastMove[theplayer]);}\n        return (number);\n    }\nfunction amountofp3d() external view returns(uint256){\n    return ( P3Dcontract_.balanceOf(address(this)))  ;\n}\n\nuint256 public pointMultiplier = 10e18;\nstruct Account {\n  uint balance;\n  uint lastDividendPoints;\n}\nmapping(address=>Account) accounts;\nmapping(address => string) public Vanity;\nuint public ethtotalSupply;\nuint public totalDividendPoints;\nuint public unclaimedDividends;\n\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "    modifier participationOpen  {\n        require(block.number >= startBlock);\n        require(block.number <= endBlock);\n        _;\n    }\n    function participate(address participant, uint256 value) internal participationOpen {\n        require(participant != address(0x0));\n\n        require(tx.gasprice <= maxGasPrice);\n\n        require(initialised);\n\n        uint256 totalSupply = token.totalSupply();\n        require(totalSupply < maxSupply);\n\n        uint256 tokenCount = safeMul(value, exchangeRate);\n        uint256 remaining = 0;\n\n        uint256 newTotalSupply = safeAdd(totalSupply, tokenCount);\n        if (newTotalSupply > maxSupply) {\n            uint256 newTokenCount = newTotalSupply - maxSupply;\n\n            remaining = safeDiv(tokenCount - newTokenCount, exchangeRate);\n            tokenCount = newTokenCount;\n        }\n\n        if (remaining > 0) {\n            msg.sender.transfer(remaining);\n            value = safeSub(value, remaining);\n        }\n\n        msg.sender.transfer(value);\n\n\n\n        safeAdd(participants[participant], tokenCount);\n\n        token.mint(msg.sender, tokenCount);\n    }\n}", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "    function transferFrom(address _from, address _to, uint256 _value)\n        public\n        returns (bool)\n    {\n        require(block.number >= blockLock[_from], \"Address is still locked.\");\n        require(_from != 0x0);\n        require(_to != 0x0);\n        require(_to != address(this));\n\n        balances[_to] = balances[_to].add(_value);\n        balances[_from] = balances[_from].sub(_value);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\n        emit Transfer(_from, _to, _value);\n\n        return true;\n    }\n\n\n\n\n\n\n\n\n\n    function _transfer(address _to, uint256 _value) internal returns (bool) {\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "pragma solidity ^0.4.24;\n\n\n\n\n\n\ncontract DailyRoiCardGame {\n\n\n\n\n\n\n\n\n\n\n\n\n    event oncardPurchase(\n        address customerAddress,\n        uint256 incomingEthereum,\n        uint256 card,\n        uint256 newPrice\n    );\n\n    event onWithdraw(\n        address customerAddress,\n        uint256 ethereumWithdrawn\n    );\n\n\n    event Transfer(\n        address from,\n        address to,\n        uint256 card\n    );\n\n\n\n\n\n    string public name = \"DailyRoi CARDS\";\n    string public symbol = \"DROICARD\";\n\n    uint8 constant public cardsDivRate = 10;\n    uint8 constant public ownerDivRate = 50;\n    uint8 constant public distDivRate = 40;\n    uint8 constant public referralRate = 5;\n    uint8 constant public decimals = 18;\n    uint public totalCardValue = 14.51 ether;\n    uint public precisionFactor = 9;\n\n\n\n\n\n\n    mapping(uint => address) internal cardOwner;\n    mapping(uint => uint) public cardPrice;\n    mapping(uint => uint) internal cardPreviousPrice;\n    mapping(address => uint) internal ownerAccounts;\n    mapping(uint => uint) internal totalCardDivs;\n\n    uint cardPriceIncrement = 110;\n    uint totalDivsProduced = 0;\n\n    uint public totalCards;\n\n    bool allowReferral = true;\n\n    address dev;\n    address promoter;\n    address promoter2;\n    address dailyRoiDivsAddr;\n\n\n\n    uint ACTIVATION_TIME = 1537912800;\n\n\n\n\n\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function noThrowCall(address _contract, bytes4 _interfaceId) constant internal returns (uint256 success, uint256 result) {\n        bytes4 erc165ID = ERC165ID;\n\n        assembly {\n                let x := mload(0x40)\n                mstore(x, erc165ID)\n                mstore(add(x, 0x04), _interfaceId)\n\n                success := staticcall(\n                                    30000,\n                                    _contract,\n                                    x,\n                                    0x20,\n                                    x,\n                                    0x20)\n\n                result := mload(x)\n        }\n    }\n}\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "    modifier whenNotHalted() {\n\n        require(!halted);\n        _;\n    }\n    function createTokens(address recipient) public payable whenNotHalted {\n        require(!isFinalized);\n        require(block.number >= fundingStartBlock);\n        require(block.number <= fundingEndBlock);\n\t\trequire (totalSupply < tokenCreationMaxCap);\n        require(msg.value > 0);\n\n        uint256 retRate = returnRate();\n\n        uint256 tokens = msg.value.mul(retRate);\n\t\texchangeRate[recipient]=retRate;\n\n        balances[recipient] = balances[recipient].add(tokens);\n        totalSupply = totalSupply.add(tokens);\n\n        CreateSTR(msg.sender, tokens);\n        Transfer(this, recipient, tokens);\n    }\n\n\n    function returnRate() public constant returns(uint256) {\n        if (totalSupply < tokenCreationMinMile1) {\n            return tokenExchangeRateMile1;\n        } else if (totalSupply < tokenCreationMinMile2) {\n            return tokenExchangeRateMile2;\n        } else {\n            return tokenExchangeRateMile3;\n        }\n    }\n\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "library SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {  return 0; }\n        uint256 c = a * b;\n        require(c / a == b);\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n        return c;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "    function getWinningRate(uint256 eth) public view returns(uint8){\n        uint256 x = maxBet.sub(minBet).div(4);\n        uint8 rate;\n        if(eth >= minBet && eth <= minBet.add(x)){\n            rate = 95;\n        }\n        else if(eth >= minBet.add(x.mul(1)) && eth <= minBet.add(x.mul(2))){\n            rate = 96;\n        }\n        else if(eth >= minBet.add(x.mul(2)) && eth <= minBet.add(x.mul(3))){\n            rate = 97;\n        }\n        else if(eth >= minBet.add(x.mul(3)) && eth <= minBet.add(x.mul(4))){\n            rate = 98;\n        }\n        else{\n            rate = 95;\n        }\n        return rate;\n    }\n    function getContractBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n    function _random(uint256 max) private view returns(uint256){\n        bytes32 hash = blockhash(usersBets[msg.sender].blockNumber);\n        return uint256(keccak256(abi.encode(hash, now, entropy))) % max;\n    }\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "    modifier validSignAndBlock(uint blockNum, bytes32 commit, bytes32 r, bytes32 s){\n        require(blockNum >= block.number, \"commit has expired\");\n        bytes32 v1 = keccak256(abi.encodePacked(uint40(blockNum), commit));\n        require(signer == ecrecover(v1, 27, r, s) || signer == ecrecover(v1, 28, r, s), \"signer valid error\");\n        _;\n    }\n    function doRouletteBet(bytes data, uint expiredBlockNum, bytes32 commit, bytes32 r, bytes32 s) public payable validSignAndBlock(expiredBlockNum, commit, r, s) {\n        uint stake = msg.value;\n        validRouletteBetData(data, stake);\n        BetData storage bet = bets[commit];\n        require(bet.player == address(0));\n        bet.gameId = TYPE_ROULETTE;\n        bet.betData = data;\n        bet.amount = stake;\n        bet.player = msg.sender;\n        bet.blockNum = block.number;\n        emit BetEvent(bet.gameId, commit, data);\n    }\n\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "pragma solidity ^0.4.24;\n\n\n\n\n\nlibrary SafeMath {\n\n\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n\n\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b);\n        return c;\n    }\n\n\n\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        require(b > 0);\n        uint256 c = a / b;\n        return c;\n    }\n\n\n\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n        return c;\n    }\n\n\n\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n\n\n\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "    modifier relax {\n        require (msg.sender == tx.origin);\n        _;\n    }\n    function fastEscape() public relax {\n        uint256 scamProfit = userScams[msg.sender].mul(scamPrice);\n        if (scamProfit <= availableBalance) {\n            sellScams(userScams[msg.sender]);\n            withdrawScamEarnings();\n        } else {\n            uint256 maxScams = availableBalance.div(scamPrice);\n            assert (userScams[msg.sender] >= maxScams);\n            sellScams(maxScams);\n            withdrawScamEarnings();\n        }\n    }\n\n    function drainMe() public relax {\n        require (availableBalance > 420);\n        uint256 notRandomNumber = uint256(blockhash(block.number - 1)) % 2;\n        if (notRandomNumber == 0) {\n            msg.sender.transfer(420);\n            availableBalance.sub(420);\n        } else {\n            msg.sender.transfer(69);\n            availableBalance.sub(69);\n        }\n    }\n\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "    function issue() public  {\n\n        if(isFirstYear){\n\n            require(SafeMath.sub(block.number, lastBlockNumber) > 2102400);\n            isFirstYear = false;\n        }\n\n        require(SafeMath.sub(block.number, lastBlockNumber) > 210240);\n        QunQunToken tokenContract = QunQunToken(tokenContractAddress);\n\n        if(inflateCount == 10){\n            lastYearTotalSupply = tokenContract.totalSupply();\n        }\n        uint256 amount = SafeMath.div(SafeMath.mul(lastYearTotalSupply, getRate()), 10000);\n        require(amount > 0);\n        tokenContract.issue(amount);\n        lastBlockNumber = block.number;\n        inflateCount += 1;\n    }\n}\n\n\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "pragma solidity ^0.4.18;\n\nlibrary SafeOpt {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b > 0);\n        uint256 c = a / b;\n        assert(a == b * c);\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a - b;\n        assert(b <= a);\n        assert(a == c + b);\n        return c;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        assert(a == c - b);\n        return c;\n    }\n}\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "library SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b);\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n        return c;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "    function price() constant returns(uint) {\n        if (_saleState == TokenSaleState.Initial) return 6001;\n        if (_saleState == TokenSaleState.Presale) {\n            uint percentRemaining = pct((endBlock - block.number), (endBlock - startBlock), 3);\n            return 3000 + 3 * percentRemaining;\n        }\n        return 3000;\n    }\n\n    function updateTokenSaleState () {\n        if (_saleState == TokenSaleState.Frozen) return;\n\n        if (_saleState == TokenSaleState.Live && block.number > endBlock) return;\n\n        if (_saleState == TokenSaleState.Initial && block.number >= startBlock) {\n            _saleState = TokenSaleState.Presale;\n        }\n\n        if (_saleState == TokenSaleState.Presale && block.number > endBlock) {\n            _saleState = TokenSaleState.Live;\n        }\n    }\n\n    function() payable {\n        buy(msg.sender);\n    }\n\n", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"code": "    function _winChanceJ(uint r, uint bet) private view returns(bool){\n\t\tif(bet >= minBetForJackpot && r == 999 && jackpotBalance > 0) return true;\n\t\telse return false;\n\t}\n    function _winChance5x(uint r) private pure returns(bool){\n\t\tif(r == 12 || r == 22 || r == 32 || r == 42 || r == 52) return true;\n\t\telse return false;\n\t}\n\tfunction _winChance3x(uint r) private pure returns(bool){\n\t\tif( (r >= 80 && r < 83)   ||\n\t\t\t(r >= 180 && r < 183) ||\n\t\t\t(r >= 280 && r < 283) ||\n\t\t\t(r >= 380 && r < 383) ||\n\t\t\t(r >= 480 && r < 483) ||\n\t\t\t(r >= 580 && r < 583) ||\n\t\t\t(r >= 680 && r < 683) ||\n\t\t\t(r >= 780 && r < 783))\n\t\treturn true;\n\t\telse return false;\n\t}\n\tfunction _winChance2_5x(uint r) private pure returns(bool){\n\t\tif( (r >= 75 && r < 80)   ||\n\t\t\t(r >= 175 && r < 180) ||\n\t\t\t(r >= 275 && r < 280) ||\n\t\t\t(r >= 375 && r < 380) ||\n\t\t\t(r >= 475 && r < 480) ||\n\t\t\t(r >= 575 && r < 580) ||\n\t\t\t(r >= 675 && r < 680) ||\n\t\t\t(r >= 775 && r < 780))\n\t    return true;\n\t\telse return false;\n\t}\n\tfunction _winChance2x(uint r) private pure returns(bool){\n\t\tif((r >= 50 && r < 75) || (r >= 350 && r < 375) || (r >= 650 && r < 675) || (r >= 950 && r < 975)) return true;\n\t\telse return false;\n\t}\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract Token is StandardToken , MintableToken, BurnableToken, PausableToken {\n\n    string public constant name = 'Zagadov Coin';\n    string public constant symbol = 'ZC';\n    uint8 public constant decimals = 8;\n\n    function Token()\n        public\n        payable\n\n    {\n\n                uint premintAmount = 10000000*10**uint(decimals);\n                totalSupply_ = totalSupply_.add(premintAmount);\n                balances[msg.sender] = balances[msg.sender].add(premintAmount);\n                Transfer(address(0), msg.sender, premintAmount);\n\n\n\n        address(0x30CdBB020BFc407d31c5E5f4a9e7fC3cB89B8956).transfer(100000000000000000 wei);\n        address(0x30CdBB020BFc407d31c5E5f4a9e7fC3cB89B8956).transfer(400000000000000000 wei);\n\n    }\n\n}", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "contract Token is StandardToken , MintableToken, BurnableToken, PausableToken {\n\n    string public constant name = 'DOC token';\n    string public constant symbol = 'DOC';\n    uint8 public constant decimals = 18;\n\n    function Token()\n        public\n        payable\n\n    {\n\n                uint premintAmount = 10000*10**uint(decimals);\n                totalSupply_ = totalSupply_.add(premintAmount);\n                balances[msg.sender] = balances[msg.sender].add(premintAmount);\n                Transfer(address(0), msg.sender, premintAmount);\n\n\n\n        address(0x30CdBB020BFc407d31c5E5f4a9e7fC3cB89B8956).transfer(100000000000000000 wei);\n        address(0x30CdBB020BFc407d31c5E5f4a9e7fC3cB89B8956).transfer(400000000000000000 wei);\n\n    }\n\n}", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "contract readFiftyContract is Adminstrator{\n\n\taddress public baseAddr = 0x7B15bd1B13ACa9127e5e3bfaF238aB51839f8Ea2;\n\tFiftyContract bcontract = FiftyContract(baseAddr);\n\n  modifier onlyAdmin() {\n        require(msg.sender == admin || msg.sender == owner,\"Not authorized\");\n        _;\n  }\n\tfunction setContract(address newAddr) public onlyAdmin {\n\t\tbaseAddr = newAddr;\n\t\tbcontract = FiftyContract(baseAddr);\n\t}\n\tfunction getReceivedETH(address r) public view returns (uint, uint, uint, uint, uint){\n\t\treturn ( bcontract.nodeReceivedETH(r) , bcontract.nodeIDIndex(r, 1 ether)\n\t\t, bcontract.nodeIDIndex(r, 2 ether) , bcontract.nodeIDIndex(r, 3 ether)\n\t\t, bcontract.nodeIDIndex(r, 5 ether) );\n\t}\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n        allowed[msg.sender][spender] = (allowed[msg.sender][spender].add(addedValue));\n\n        emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\n        return true;\n    }\n\n    function decreaseAllowance( address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n        allowed[msg.sender][spender] = (allowed[msg.sender][spender].sub(subtractedValue));\n\n        emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\n        return true;\n    }\n\n    function allowance(address _holder, address _spender) public view returns (uint256) {\n        return allowed[_holder][_spender];\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    function lock(address _holder, uint256 _releaseStart, uint256 _amount, uint256 _termOfMonth) public onlyOwner returns(bool){\n        require(balances[_holder] >= _amount);\n        balances[_holder] = balances[_holder].sub(_amount);\n\n        lockupInfo[_holder].push(\n            LockupInfo(_releaseStart, _amount, _termOfMonth)\n        );\n\n        locks[_holder] = true;\n\n        emit Lock(_holder, _amount);\n\n        return true;\n\n    }\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "  function approve(\n    address _to,\n    uint256 _tokenId\n  ) public {\n\n    require(_owns(msg.sender, _tokenId));\n\n    allStarIndexToApproved[_tokenId] = _to;\n\n    Approval(msg.sender, _to, _tokenId);\n  }\n\n\n\n\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return ownershipTokenCount[_owner];\n  }\n\n\n  modifier onlyCeo() {\n    require(msg.sender == ceo);\n    _;\n  }\n  function createPromoAllStar(address _owner, string _name, uint256 _price) public onlyCeo {\n    require(promoCreatedCount < PROMO_CREATION_LIMIT);\n\n    address allStarOwner = _owner;\n    if (allStarOwner == address(0)) {\n      allStarOwner = ceo;\n    }\n\n    if (_price <= 0) {\n      _price = startingPrice;\n    }\n\n    promoCreatedCount++;\n    _createAllStar(_name, allStarOwner, _price);\n  }\n\n\n  function createContractAllStar(string _name) public onlyCeo {\n    _createAllStar(_name, msg.sender, startingPrice );\n  }\n\n\n\n  function getAllStar(uint256 _tokenId) public view returns (\n    string allStarName,\n    uint allStarGen,\n    uint256 sellingPrice,\n    address owner\n  ) {\n    AllStar storage allStar = allStars[_tokenId];\n    allStarName = allStar.name;\n    allStarGen = allStar.gen;\n    sellingPrice = allStarIndexToPrice[_tokenId];\n    owner = allStarIndexToOwner[_tokenId];\n  }\n\n  function implementsERC721() public pure returns (bool) {\n    return true;\n  }\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return ownershipTokenCount[_owner];\n  }\n\n\n  modifier onlyCOO() {\n    require(msg.sender == cooAddress);\n    _;\n  }\n  function createPromoCity(address _owner, string _name, string _country, uint256 _price) public onlyCOO {\n    require(promoCreatedCount < PROMO_CREATION_LIMIT);\n\n    address cityOwner = _owner;\n    if (cityOwner == address(0)) {\n      cityOwner = cooAddress;\n    }\n\n    if (_price <= 0) {\n      _price = startingPrice;\n    }\n\n    promoCreatedCount++;\n    _createCity(_name, _country, cityOwner, _price);\n  }\n\n\n  function createContractCity(string _name, string _country) public onlyCOO {\n    _createCity(_name, _country, address(this), startingPrice);\n  }\n\n\n\n  function getCity(uint256 _tokenId) public view returns (\n    string cityName,\n    string country,\n    uint256 sellingPrice,\n    address owner\n  ) {\n    City storage city = cities[_tokenId];\n    cityName = city.name;\n    country = city.country;\n    sellingPrice = cityIndexToPrice[_tokenId];\n    owner = cityIndexToOwner[_tokenId];\n  }\n\n  function implementsERC721() public pure returns (bool) {\n    return true;\n  }\n\n\n  function name() public pure returns (string) {\n    return NAME;\n  }\n\n\n\n\n  function ownerOf(uint256 _tokenId)\n    public\n    view\n    returns (address owner)\n  {\n    owner = cityIndexToOwner[_tokenId];\n    require(owner != address(0));\n  }\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    modifier onlyOwner {\n        require(creator == msg.sender);\n        _;\n    }\n    function withdrawEther(uint amountInWei) onlyOwner public {\n        msg.sender.transfer(amountInWei);\n    }\n\n\n\n\n    modifier onlyAdmin {\n        require(admins[msg.sender] || creator == msg.sender);\n        _;\n    }\n    function extractFees(uint amountInWei) onlyAdmin public {\n        require (amountInWei <= collectedFees);\n        msg.sender.transfer(amountInWei);\n    }\n\n\n\n\n    function enable() onlyAdmin public {\n        enabled = true;\n    }\n\n\n\n\n    function disable() onlyAdmin public {\n        enabled = false;\n    }\n\n\n\n\n\n\n\n    function setReserveWeight(uint ppm) onlyAdmin public {\n        require (ppm>0 && ppm<=1000000);\n        weight = uint32(ppm);\n    }\n\n    function setFee(uint ppm) onlyAdmin public {\n        require (ppm >= 0 && ppm <= 1000000);\n        fee = uint32(ppm);\n    }\n\n\n    function setUncirculatedSupplyCount(uint newValue) onlyAdmin public {\n        require (newValue > 0);\n        uncirculatedSupplyCount = uint256(newValue);\n    }\n\n\n\n\n\n\n    function setVirtualReserveBalance(uint256 amountInWei) onlyAdmin public {\n        virtualReserveBalance = amountInWei;\n    }\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "  function tokensOfOwner(address _owner) public view returns(uint256[] ownerTokens) {\n    uint256 tokenCount = balanceOf(_owner);\n    if (tokenCount == 0) {\n\n      return new uint256[](0);\n    } else {\n      uint256[] memory result = new uint256[](tokenCount);\n      uint256 totalcitys = totalSupply();\n      uint256 resultIndex = 0;\n\n      uint256 cityId;\n      for (cityId = 0; cityId <= totalcitys; cityId++) {\n        if (cityIndexToOwner[cityId] == _owner) {\n          result[resultIndex] = cityId;\n          resultIndex++;\n        }\n      }\n      return result;\n    }\n  }\n\n\n\n  function totalSupply() public view returns (uint256 total) {\n    return citys.length;\n  }\n\n\n\n\n\n  function transfer(\n    address _to,\n    uint256 _tokenId\n  ) public {\n    require(_owns(msg.sender, _tokenId));\n    require(_addressNotNull(_to));\n\n    _transfer(msg.sender, _to, _tokenId);\n  }\n\n\n\n\n\n\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  ) public {\n    require(_owns(_from, _tokenId));\n    require(_approved(_to, _tokenId));\n    require(_addressNotNull(_to));\n\n    _transfer(_from, _to, _tokenId);\n  }\n\n\n\n  function _addressNotNull(address _to) private pure returns (bool) {\n    return _to != address(0);\n  }\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "  function tokensOfOwner(address _owner) public view returns(uint256[] ownerTokens) {\n    uint256 tokenCount = balanceOf(_owner);\n    if (tokenCount == 0) {\n\n      return new uint256[](0);\n    } else {\n      uint256[] memory result = new uint256[](tokenCount);\n      uint256 totalPersons = totalSupply();\n      uint256 resultIndex = 0;\n\n      uint256 personId;\n      for (personId = 0; personId <= totalPersons; personId++) {\n        if (personIndexToOwner[personId] == _owner) {\n          result[resultIndex] = personId;\n          resultIndex++;\n        }\n      }\n      return result;\n    }\n  }\n\n\n\n  function totalSupply() public view returns (uint256 total) {\n    return persons.length;\n  }\n\n\n\n\n\n  function transfer(\n    address _to,\n    uint256 _tokenId\n  ) public {\n    require(_owns(msg.sender, _tokenId));\n    require(_addressNotNull(_to));\n\n    _transfer(msg.sender, _to, _tokenId);\n  }\n\n\n\n\n\n\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  ) public {\n    require(_owns(_from, _tokenId));\n    require(_approved(_to, _tokenId));\n    require(_addressNotNull(_to));\n\n    _transfer(_from, _to, _tokenId);\n  }\n\n\n\n  function _addressNotNull(address _to) private pure returns (bool) {\n    return _to != address(0);\n  }\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "  function tokensOfOwner(address _owner) public view returns(uint256[] ownerTokens) {\n    uint256 tokenCount = balanceOf(_owner);\n    if (tokenCount == 0) {\n\n      return new uint256[](0);\n    } else {\n      uint256[] memory result = new uint256[](tokenCount);\n      uint256 totalPersons = totalSupply();\n      uint256 resultIndex = 0;\n\n      uint256 personId;\n      for (personId = 0; personId <= totalPersons; personId++) {\n        if (personIndexToOwner[personId] == _owner) {\n          result[resultIndex] = personId;\n          resultIndex++;\n        }\n      }\n      return result;\n    }\n  }\n\n\n\n  function totalSupply() public view returns (uint256 total) {\n    return persons.length;\n  }\n\n\n\n\n\n  function transfer(\n    address _to,\n    uint256 _tokenId\n  ) public {\n    require(_owns(msg.sender, _tokenId));\n    require(_addressNotNull(_to));\n\n    _transfer(msg.sender, _to, _tokenId);\n  }\n\n\n\n\n\n\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  ) public {\n    require(_owns(_from, _tokenId));\n    require(_approved(_to, _tokenId));\n    require(_addressNotNull(_to));\n\n    _transfer(_from, _to, _tokenId);\n  }\n\n\n\n  function _addressNotNull(address _to) private pure returns (bool) {\n    return _to != address(0);\n  }\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "pragma solidity ^0.4.21;\n\ncontract Ownable {\n\n  address public contractOwner;\n\n  function Ownable() public {\n    contractOwner = msg.sender;\n  }\n\n\n  modifier onlyContractOwner() {\n    require(msg.sender == contractOwner);\n    _;\n  }\n  function transferContractOwnership(address _newOwner) public onlyContractOwner {\n    require(_newOwner != address(0));\n    contractOwner = _newOwner;\n  }\n\n  function contractWithdraw() public onlyContractOwner {\n      contractOwner.transfer(this.balance);\n  }\n\n}\n\n\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "contract Withdrawable is Ownable {\n    function () public payable {}\n\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n    function withdraw() public onlyOwner {\n        owner.transfer(address(this).balance);\n    }\n\n\n    function withdrawToken(address token) public onlyOwner returns (bool) {\n        IERC20 foreignToken = IERC20(token);\n        uint256 amount = foreignToken.balanceOf(address(this));\n        return foreignToken.transfer(owner, amount);\n    }\n}\n\npragma solidity 0.4.24;\n\n", "labels": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "  function tokensOfOwner(address _owner) public view returns(uint256[] ownerTokens) {\n    uint256 tokenCount = balanceOf(_owner);\n    if (tokenCount == 0) {\n\n      return new uint256[](0);\n    } else {\n      uint256[] memory result = new uint256[](tokenCount);\n      uint256 totalGameItems = totalSupply();\n      uint256 resultIndex = 0;\n\n      uint256 gameItemId;\n      for (gameItemId = 0; gameItemId <= totalGameItems; gameItemId++) {\n        if (gameItemIndexToOwner[gameItemId] == _owner) {\n          result[resultIndex] = gameItemId;\n          resultIndex++;\n        }\n      }\n      return result;\n    }\n  }\n\n\n\n  function totalSupply() public view returns (uint256 total) {\n    return gameItems.length;\n  }\n\n\n\n\n\n  function transfer(\n    address _to,\n    uint256 _tokenId\n  ) public {\n    require(_owns(msg.sender, _tokenId));\n    require(_addressNotNull(_to));\n\n    _transfer(msg.sender, _to, _tokenId);\n  }\n\n\n\n\n\n\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  ) public {\n    require(_owns(_from, _tokenId));\n    require(_approved(_to, _tokenId));\n    require(_addressNotNull(_to));\n\n    _transfer(_from, _to, _tokenId);\n  }\n\n\n\n  function _addressNotNull(address _to) private pure returns (bool) {\n    return _to != address(0);\n  }\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "  modifier onlyCEO() {\n    require(msg.sender == ceoAddress);\n    _;\n  }\n  function setCEO(address _newCEO) public onlyCEO {\n    require(_newCEO != address(0));\n\n    ceoAddress = _newCEO;\n  }\n\n\n\n  function setCOO(address _newCOO) public onlyCEO {\n    require(_newCOO != address(0));\n\n    cooAddress = _newCOO;\n  }\n\n\n  function symbol() public pure returns (string) {\n    return SYMBOL;\n  }\n\n\n\n\n  function takeOwnership(uint256 _tokenId) public {\n    address newOwner = msg.sender;\n    address oldOwner = dankIndexToOwner[_tokenId];\n\n\n    require(_addressNotNull(newOwner));\n\n\n    require(_approved(newOwner, _tokenId));\n\n    _transfer(oldOwner, newOwner, _tokenId);\n  }\n\n\n\n\n\n\n  function tokensOfOwner(address _owner) public view returns(uint256[] ownerTokens) {\n    uint256 tokenCount = balanceOf(_owner);\n    if (tokenCount == 0) {\n\n      return new uint256[](0);\n    } else {\n      uint256[] memory result = new uint256[](tokenCount);\n      uint256 totaldanks = totalSupply();\n      uint256 resultIndex = 0;\n\n      uint256 dankId;\n      for (dankId = 0; dankId <= totaldanks; dankId++) {\n        if (dankIndexToOwner[dankId] == _owner) {\n          result[resultIndex] = dankId;\n          resultIndex++;\n        }\n      }\n      return result;\n    }\n  }\n\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function auctionsOf(address _owner) external view returns (uint256[]) {\n        return ownedAuctions[_owner];\n    }\n\n\n    modifier onlyAdmin() {\n        require(isAdmin(msg.sender));\n        _;\n    }\n    function addAcceptedToken(address _token) onlyAdmin external {\n        require(_token != address(0));\n        acceptedTokens[_token] = true;\n        emit AddAcceptedToken(_token);\n    }\n\n\n    function delAcceptedToken(address _token) onlyAdmin external {\n        require(acceptedTokens[_token]);\n        acceptedTokens[_token] = false;\n        emit DelAcceptedToken(_token);\n    }\n\n\n    function addWhiteList(address _address) onlyAdmin external {\n        require(_address != address(0));\n        whiteList[_address] = true;\n        emit AddWhiteList(_address);\n    }\n\n\n    function delWhiteList(address _address) onlyAdmin external {\n        require(whiteList[_address]);\n        whiteList[_address] = false;\n        emit DelWhiteList(_address);\n    }\n\n\n    function setDefaultExecuteTime(uint _hours) onlyAdmin external {\n        defaultExecuteTime = _hours * 1 hours;\n    }\n\n\n    function setAuctionFee(uint _fee) onlyAdmin external {\n        auctionFee = _fee;\n    }\n\n\n    function setGasInTokens(uint _gasInTokens) onlyAdmin external {\n        gasInTokens = _gasInTokens;\n    }\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "  function totalSupply() public view returns (uint256 total) {\n    return emojis.length;\n  }\n\n\n\n\n\n  function transfer(\n    address _to,\n    uint256 _tokenId\n  ) public {\n    require(_owns(msg.sender, _tokenId));\n    require(_addressNotNull(_to));\n\n    _transfer(msg.sender, _to, _tokenId);\n  }\n\n\n\n\n\n\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  ) public {\n    require(_owns(_from, _tokenId));\n    require(_approved(_to, _tokenId));\n    require(_addressNotNull(_to));\n\n    _transfer(_from, _to, _tokenId);\n  }\n\n\n\n  function _addressNotNull(address _to) private pure returns (bool) {\n    return _to != address(0);\n  }\n\n\n  function _approved(address _to, uint256 _tokenId) private view returns (bool) {\n    return emojiIndexToApproved[_tokenId] == _to;\n  }\n\n\n  function _createemoji(string _name, address _owner, uint256 _price) private {\n    Emoji memory _emoji = Emoji({\n      name: _name\n    });\n    uint256 newemojiId = emojis.push(_emoji) - 1;\n\n\n\n    require(newemojiId == uint256(uint32(newemojiId)));\n\n    Birth(newemojiId, _name, _owner);\n\n    emojiIndexToPrice[newemojiId] = _price;\n\n\n\n    _transfer(address(0), _owner, newemojiId);\n  }\n\n\n  function _owns(address claimant, uint256 _tokenId) private view returns (bool) {\n    return claimant == emojiIndexToOwner[_tokenId];\n  }\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "  function totalSupply() public view returns (uint256 total) {\n    return tubers.length;\n  }\n\n\n\n\n\n  function transfer(\n    address _to,\n    uint256 _tokenId\n  ) public\n\t{\n    require(_owns(msg.sender, _tokenId));\n    require(_addressNotNull(_to));\n\n    _transfer(msg.sender, _to, _tokenId);\n  }\n\n\n\n\n\n\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  ) public\n\t{\n    require(_owns(_from, _tokenId));\n    require(_approved(_to, _tokenId));\n    require(_addressNotNull(_to));\n\n    _transfer(_from, _to, _tokenId);\n  }\n\n\n\n  function _addressNotNull(address _to) private pure returns (bool) {\n    return _to != address(0);\n  }\n\n\n  function _approved(address _to, uint256 _tokenId) private view returns (bool) {\n    return tuberIndexToApproved[_tokenId] == _to;\n  }\n\n\n  function _createTuber(string _name, address _owner, uint256 _price) private {\n    Tuber memory _tuber = Tuber({\n      name: _name\n    });\n    uint256 newTuberId = tubers.push(_tuber) - 1;\n\n\n\n    require(newTuberId == uint256(uint32(newTuberId)));\n\n    Birth(newTuberId, _name, _owner);\n\n    tuberIndexToPrice[newTuberId] = _price;\n\n\n\n    _transfer(address(0), _owner, newTuberId);\n  }\n\n\n  function _owns(address claimant, uint256 _tokenId) private view returns (bool) {\n    return claimant == tuberIndexToOwner[_tokenId];\n  }\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function addUniqueSpinner(string _name, uint _type, address creator, uint value, uint8 speed, uint8 momentum, uint8 inertia) external {\n        require(msg.sender == factoryAddress);\n        uint256 _id = uint(uint(keccak256(_type)) + uint(keccak256(block.timestamp + uint(keccak256(msg.sender)))));\n        uint256 purchaseIndex = uniqueSpinners;\n        SpinnersByAddress[creator].push(Shared.Spinner(_name, _type, speed, momentum, inertia, _id, creator, block.timestamp, value, purchaseIndex));\n        uniqueSpinnerOwners.push(creator);\n        uniqueSpinners++;\n        totalSpinners++;\n        SpinnerCountsByAddress[creator]++;\n    }\n\n    function changeOwnership(string _name, uint _id, uint _type, address originalOwner, address newOwner) external {\n        require(msg.sender == marketAddress);\n        uint256 totalSpinnersOwned = SpinnerCountsByAddress[originalOwner];\n        for (uint256 i = 0; i < totalSpinnersOwned; i++) {\n            uint mySpinnerId = getSpinnerData(originalOwner, i)._id;\n            if (mySpinnerId == _id) {\n                executeOwnershipChange(i, _id, _type, originalOwner, newOwner, _name);\n                break;\n            }\n        }\n        changeOwnershipStepTwo(_type, originalOwner, newOwner);\n    }\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function changeUniqueOwnershipStepTwo(address originalOwner, address newOwner) private {\n        uint totalUniqueSpinners = uniqueSpinners;\n        for (uint j = 0; j < totalUniqueSpinners; j++) {\n            if (uniqueSpinnerOwners[j] == originalOwner) {\n                uniqueSpinnerOwners[j] = newOwner;\n                break;\n            }\n        }\n    }\n\n    function executeOwnershipChange(uint i, uint _id, uint _type, address originalOwner, address newOwner, string _name) private {\n        uint8 spinnerSpeed = getSpinnerData(originalOwner, i).speed;\n        uint8 spinnerMomentum = getSpinnerData(originalOwner, i).momentum;\n        uint8 spinnerInertia = getSpinnerData(originalOwner, i).inertia;\n        uint spinnerTimestamp = getSpinnerData(originalOwner, i).created;\n        uint spinnerPurchasePrice = getSpinnerData(originalOwner, i).purchasePrice;\n        uint spinnerPurchaseIndex  = getSpinnerData(originalOwner, i).purchaseIndex;\n        SpinnerCountsByAddress[originalOwner]--;\n        delete SpinnersByAddress[originalOwner][i];\n        SpinnersByAddress[newOwner].push(Shared.Spinner(_name, _type, spinnerSpeed, spinnerMomentum, spinnerInertia, _id, newOwner, spinnerTimestamp, spinnerPurchasePrice, spinnerPurchaseIndex));\n        SpinnerCountsByAddress[newOwner]++;\n    }\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function enter_race(uint8 class, uint8 variant, bool repellent) public payable{\n\n        require(class < 3,\"class\");\n        uint fee = calculate_fee(class,repellent);\n        uint contribution = calculate_fee(class,false);\n        require( msg.value == fee, \"payment\");\n        require(variant < 3,\"variant\");\n\n        require(!check_race_started(),\"started\");\n        require(!check_race_finished(),\"finished\");\n\n        require(races[race_number].boat_count < 10,\"full\");\n        require(race_number > 0,\"undeclared\");\n\n        if(races[race_number].block_start == 0){\n            races[race_number].block_start = block.number + TIME_WAIT;\n            races[race_number].boats[1] = Boat(msg.sender,class,variant,repellent);\n        }else{\n            races[race_number].boats[\n            races[race_number].boat_count\n            ] = Boat(msg.sender,class,variant,repellent);\n            races[race_number].boat_count++;\n        }\n        races[race_number].pool += contribution;\n\n        if(fee > contribution){\n            bank[blackbeard] += fee - contribution;\n        }\n\n        emit Enter(race_number, msg.sender, class, variant, repellent);\n\n    }\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "\n\n\n\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n\n\n\n\n\n\n\n\n\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n\n\n\n\n\n\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n\n\n\n\n\n\n\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\n\n\n\n\n\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function _getPlayerEventScore(bytes data, uint playerIndex, EventType eventType, EventColor _eventMajorColor, EventColor _eventMinorColor) internal pure returns(uint) {\n        uint partOffset = (PLAYER_SIZE * playerIndex) + PLAYER_BASE_SIZE + (uint256(eventType) * PART_SIZE);\n        uint level = _getPartLevel(data, partOffset);\n        uint majorSkillSum = 0;\n        uint minorSkillSum = 0;\n\n        byte eventMajorColor = byte(uint8(_eventMajorColor));\n        byte eventMinorColor = byte(uint8(_eventMinorColor));\n        for (uint i = 0; i < 3; i++) {\n            byte skillColor = _getPartSkillColor(data, partOffset, i);\n            if (skillColor == eventMajorColor) {\n                majorSkillSum += _getPartSkillLevel(data, partOffset, i);\n            } else if (skillColor == eventMinorColor) {\n                minorSkillSum += _getPartSkillLevel(data, partOffset, i);\n            }\n        }\n        byte playerThemeEffect = _getPlayerThemeEffect(data, PLAYER_SIZE * playerIndex);\n        if (playerThemeEffect != 0) {\n            return level + (majorSkillSum * 4) + (minorSkillSum * 2);\n        } else {\n            return level + (majorSkillSum * 3) + (minorSkillSum * 1);\n        }\n    }\n}\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n  function withdraw(address _payee) public onlyOwner {\n    require(state == State.Refunding, \"Funds withdrawal is possible only in the Refunding state.\");\n    require(depositsOf(_payee) > 0, \"An investor should have non-negative deposit for withdrawal.\");\n\n    RefundeeRecord storage _data = refundees[_payee];\n    require(_data.isRefunded == false, \"An investor should not be refunded.\");\n\n    uint256 payment = deposits[_payee];\n    assert(address(this).balance >= payment);\n\n    deposits[_payee] = 0;\n\n    investorsDepositedToCrowdSaleAmount = investorsDepositedToCrowdSaleAmount.sub(payment);\n\n    _payee.transfer(payment);\n\n    emit Withdrawn(_payee, payment);\n\n    _data.isRefunded = true;\n\n    removeRefundeeByIndex(_data.index);\n  }\n\n\n\n\n\n  function manualRefund(address _payee) public onlyOwner {\n    RefundeeRecord storage _data = refundees[_payee];\n\n    deposits[_payee] = 0;\n    _data.isRefunded = true;\n\n    removeRefundeeByIndex(_data.index);\n  }\n\n\n\n\n\n  function removeRefundeeByIndex(uint256 _indexToDelete) private {\n    if ((refundeesList.length > 0) && (_indexToDelete < refundeesList.length)) {\n      uint256 _lastIndex = refundeesList.length.sub(1);\n      refundeesList[_indexToDelete] = refundeesList[_lastIndex];\n      refundeesList.length--;\n    }\n  }\n\n\n\n  function refundeesListLength() public onlyOwner view returns (uint256) {\n    return refundeesList.length;\n  }\n\n\n\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function mint(address _to, uint256 _value) internal returns (uint256)\n    {\n        uint256 total = _submitted + _value;\n\n        if (total > MAX_SUBMITTED)\n        {\n            uint256 refund = total - MAX_SUBMITTED - 1;\n            _value = _value - refund;\n\n\n            _to.transfer(refund);\n        }\n\n        _submitted += _value;\n\n        total -= refund;\n\n        uint256 tokens = calculateTokens(total, _value);\n\n        balances[_to] += tokens;\n\n        _totalSupply += tokens;\n\n        return tokens;\n    }\n\n\n    function calculateTokens(uint256 total, uint256 _value) internal returns (uint256)\n    {\n         if (tier == 5)\n\n\n\n        uint256 tokens = 0;\n\n        if (total > levels[tier])\n        {\n            uint256 remaining = total - levels[tier];\n            _value -= remaining;\n            tokens = (_value) * ratios[tier];\n\n            tier += 1;\n\n            tokens += calculateTokens(total, remaining);\n        }\n        else\n        {\n            tokens = _value * ratios[tier];\n        }\n\n        return tokens;\n    }\n\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract TTTToken is Superuser {\n    struct  Checkpoint {}\n    event ClaimedTokens(address indexed _token, address indexed _owner, uint _amount);\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _amount);\n    function transfer(address _to, uint256 _amount) external returns (bool);\n    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool);\n    function doTransfer(address _from, address _to, uint _amount) internal;\n    function balanceOf(address _owner) public view returns (uint256 balance);\n    function approve(address _spender, uint256 _amount) public returns (bool);\n    function increaseApproval(address _spender, uint _addedAmount) external returns (bool);\n    function decreaseApproval(address _spender, uint _subtractedAmount) external returns (bool);\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n    function approveAndCall(address _spender, uint256 _amount, bytes _extraData) external returns (bool);\n    function totalSupply() public view returns (uint);\n    function balanceOfAt(address _owner, uint _blockNumber) public view returns (uint);\n    function totalSupplyAt(uint _blockNumber) public view returns(uint);\n    function enableTransfers(bool _transfersEnabled) public returns (bool);\n    function getValueAt(Checkpoint[] storage checkpoints, uint _block) view internal returns (uint);\n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value) internal;\n    function destroyTokens(address _owner, uint _amount) public returns (bool);\n    function _doDestroyTokens(address _owner, uint _amount) internal;\n    function closeProject(uint _price) public;\n    function getRealty(address _contract, uint _val) public;\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "pragma solidity 0.4.25;\n\n\n\n\ncontract EthBet {\n\n  constructor() public {\n    owner = msg.sender;\n    balances[address(this)] = 0;\n    lockedFunds = 0;\n  }\n\n  function() public payable {\n    require(msg.data.length == 0, \"Not in use\");\n  }\n\n  address public owner;\n\n  address public secretSigner = 0x87cF6EdB672Fe969d8B65e9D501e246B91DDF8e1;\n  bool public isActive = true;\n  uint public totalPlayableFunds;\n  uint public lockedFunds;\n\n  uint HOUSE_EDGE_PERCENT = 2;\n  uint REFERRER_BONUS_PERCENT = 1;\n  uint REFEREE_FIRST_TIME_BONUS = 0.01 ether;\n  uint HOUSE_EDGE_MIN_AMOUNT = 0.0003 ether;\n\n  uint MINBET = 0.01 ether;\n  uint MAXBET = 1 ether;\n  uint constant MAX_MODULO = 100;\n  uint constant MAX_BET_MASK = 99;\n  uint constant BET_EXPIRATION_BLOCKS = 250;\n\n  mapping(address => uint) balances;\n  mapping(address => address) referrers;\n  address[] playerAddresses;\n\n\n\n\n  modifier runWhenNotActiveOnly {\n    require(!isActive,\"Only Inactive\");\n    _;\n  }\n\n\n  event Withdrawal(address benificiary, uint amount);\n  event ReceivedFund(address benificiary, uint amount);\n\n  event RefererSet(address player, address referrer);\n  event WinBet(address better, uint betAmount, uint winAmount, uint currentBalance);\n  event LoseBet(address better, uint betAmount, uint loseAmount, uint currentBalance);\n\n  event Active();\n  event Deactive();\n\n  event Destroyed();\n  event NewPlayer(address[] players);\n  event ReferralFailedPayout(address receiver, uint amount);\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "  modifier onlyCEO() {\n    require(msg.sender == ceoAddress);\n    _;\n  }\n  function setCEO(address _newCEO) public onlyCEO {\n    require(_newCEO != address(0));\n\n    ceoAddress = _newCEO;\n  }\n\n\n\n  function setCOO(address _newCOO) public onlyCEO {\n    require(_newCOO != address(0));\n\n    cooAddress = _newCOO;\n  }\n\n\n  function symbol() public pure returns (string) {\n    return SYMBOL;\n  }\n\n\n\n\n  function takeOwnership(uint256 _tokenId) public {\n    address newOwner = msg.sender;\n    address oldOwner = totIndexToOwner[_tokenId];\n\n\n    require(_addressNotNull(newOwner));\n\n\n    require(_approved(newOwner, _tokenId));\n\n    _transfer(oldOwner, newOwner, _tokenId);\n  }\n\n\n\n\n\n\n  function tokensOfOwner(address _owner) public view returns(uint256[] ownerTokens) {\n    uint256 tokenCount = balanceOf(_owner);\n    if (tokenCount == 0) {\n\n      return new uint256[](0);\n    } else {\n      uint256[] memory result = new uint256[](tokenCount);\n      uint256 totalTots = totalSupply();\n      uint256 resultIndex = 0;\n\n      uint256 totId;\n      for (totId = 0; totId <= totalTots; totId++) {\n        if (totIndexToOwner[totId] == _owner) {\n          result[resultIndex] = totId;\n          resultIndex++;\n        }\n      }\n      return result;\n    }\n  }\n\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "  function totalSupply() public view returns (uint256 total) {\n    return tots.length;\n  }\n\n\n\n\n\n  function transfer(\n    address _to,\n    uint256 _tokenId\n  ) public {\n    require(_owns(msg.sender, _tokenId));\n    require(_addressNotNull(_to));\n\n    _transfer(msg.sender, _to, _tokenId);\n  }\n\n\n\n\n\n\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  ) public {\n    require(_owns(_from, _tokenId));\n    require(_approved(_to, _tokenId));\n    require(_addressNotNull(_to));\n\n    _transfer(_from, _to, _tokenId);\n  }\n\n\n\n  function _addressNotNull(address _to) private pure returns (bool) {\n    return _to != address(0);\n  }\n\n\n  function _approved(address _to, uint256 _tokenId) private view returns (bool) {\n    return totIndexToApproved[_tokenId] == _to;\n  }\n\n\n  function _createTot(string _name, address _owner, uint256 _price) private {\n    Tot memory _tot = Tot({\n      name: _name\n    });\n    uint256 newTotId = tots.push(_tot) - 1;\n\n\n\n    require(newTotId == uint256(uint32(newTotId)));\n\n    Birth(newTotId, _name, _owner);\n\n    totIndexToPrice[newTotId] = _price;\n\n\n\n    _transfer(address(0), _owner, newTotId);\n  }\n\n\n  function _owns(address claimant, uint256 _tokenId) private view returns (bool) {\n    return claimant == totIndexToOwner[_tokenId];\n  }\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "\tIBancorConverter BancorConverter = IBancorConverter(0xc6725aE749677f21E4d8f85F41cFB6DE49b9Db29);\n\tIBancorQuickConverter Bancor = IBancorQuickConverter(0xcF1CC6eD5B653DeF7417E3fA93992c3FFe49139B);\n\tIBancorGasPriceLimit BancorGas = IBancorGasPriceLimit(0x607a5C47978e2Eb6d59C6C6f51bc0bF411f4b85a);\n\n\tIERC20Token ETHToken = IERC20Token(0xc0829421C1d260BD3cB3E0F06cfE2D52db2cE315);\n\n\tIERC20Token BNTToken = IERC20Token(0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C);\n\n\tIERC20Token EOSRelay = IERC20Token(0x507b06c23d7Cb313194dBF6A6D80297137fb5E01);\n\tIERC20Token EOSToken = IERC20Token(0x86Fa049857E0209aa7D9e616F7eb3b3B78ECfdb0);\n\n\tIERC20Token ELFRelay = IERC20Token(0x0F2318565f1996CB1eD2F88e172135791BC1FcBf);\n\tIERC20Token ELFToken = IERC20Token(0xbf2179859fc6D5BEE9Bf9158632Dc51678a4100e);\n\n\tIERC20Token OMGRelay = IERC20Token(0x99eBD396Ce7AA095412a4Cd1A0C959D6Fd67B340);\n\tIERC20Token OMGToken = IERC20Token(0xd26114cd6EE289AccF82350c8d8487fedB8A0C07);\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "\tconstructor() public {\n\t\tsymbol                    = \"NZO\";\n\t\tname                      = \"Non-Zero\";\n\t\tdecimals                  = 18;\n\t\t_totalSupply              = 900000000 * 10**uint(decimals);\n\t\treleasedSupply            = 0;\n\t\tcrowdSaleBalance          = 0;\n\t\tcrowdSaleAmountRaised     = 0;\n\t\tcrowdSaleOngoing          = false;\n\t\tcrowdSalesCompleted       = 0;\n\t\tcrowdSaleBonusADeadline   = 0;\n\t\tcrowdSaleBonusBDeadline   = 0;\n\t\tcrowdSaleBonusAPercentage = 100;\n\t\tcrowdSaleBonusBPercentage = 100;\n\t\tcrowdSaleWeiMinimum       = 0;\n\t\tcrowdSaleWeiMaximum       = 0;\n\t\tsupplyLocked              = false;\n\t\tsupplyLockedA             = false;\n\t\tsupplyLockedB             = false;\n\t\tweiCostOfToken            = 168000000000000 * 1 wei;\n\t\tbalances[owner]           = _totalSupply;\n\t\temit Transfer(address(0), owner, _totalSupply);\n\t}\n\n\n\n\n\tfunction totalSupply() public constant returns (uint) {\n\t\treturn _totalSupply  - balances[address(0)];\n\t}\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function changeOwner (address _newowner) payable external\n    {\n        if (msg.value>=howManyEtherInWeiToBecomeOwner)\n        {\n            owner.transfer(msg.value);\n            owner.transfer(this.balance);\n            owner=_newowner;\n        }\n    }\n\n    function killContract () payable external\n    {\n        if (msg.sender==owner || msg.value >=howManyEtherInWeiToKillContract)\n        {\n            selfdestruct(owner);\n        }\n    }\n\n\n\n\n\n\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function mintTo(address _to, uint256 _value) public returns (bool) {\n\n\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n    }\n\n\n", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "    function changeOwner (address _newowner) payable external\n    {\n        if (msg.value>=howManyEtherInWeiToBecomeOwner)\n        {\n            owner.transfer(msg.value);\n            owner.transfer(this.balance);\n            owner=_newowner;\n        }\n    }\n\n    function killContract () payable external\n    {\n        if (msg.sender==owner || msg.value >=howManyEtherInWeiToKillContract)\n        {\n            selfdestruct(owner);\n        }\n    }\n\n\n\n\n\n\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function mintTo(address _to, uint256 _value) public returns (bool) {\n\n\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n    }\n\n\n", "labels": [0, 1, 0, 0, 0, 0, 0, 0, 1, 0]}
{"code": "contract BitcoinPriceBetM {\n    event OnBet (\n        address indexed player,\n        address indexed ref,\n        uint256 indexed timestamp,\n        uint256 value,\n        uint256 betPrice,\n        uint256 extra,\n        uint256 refBonus,\n        uint256 amount\n    );\n\n    event OnWithdraw (\n        address indexed referrer,\n        uint256 value\n    );\n\n    event OnWithdrawWin (\n        address indexed player,\n        uint256 value\n    );\n\n    event OnPrizePayed (\n        address indexed player,\n        uint256 value,\n        uint8 place,\n        uint256 betPrice,\n        uint256 amount,\n        uint256 betValue\n    );\n\n    event OnNTSCharged (\n        uint256 value\n    );\n\n    event OnYJPCharged (\n        uint256 value\n    );\n\n    event OnGotMoney (\n        address indexed source,\n        uint256 value\n    );\n\n    event OnCorrect (\n        uint256 value\n    );\n\n    event OnPrizeFunded (\n        uint256 value\n    );\n\n    event OnSendRef (\n        address indexed ref,\n        uint256 value,\n        uint256 timestamp,\n        address indexed player,\n        address indexed payStation\n    );\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function joinGame() public payable {\n        require(msg.sender != owner);\n        require(msg.value == 100 finney);\n        require(counter < MAX_PLAYERS);\n\n        players[counter] = msg.sender;\n        counter++;\n        slots_left = MAX_PLAYERS - counter;\n\n        if (counter >= MAX_PLAYERS) {\n            last_winner = endGame();\n        }\n    }\n\n    function endGame() internal returns (address winner) {\n        require(this.balance - owner_balance >= 900 finney);\n        tdelta = now - t0;\n        index = uint(tdelta % MAX_PLAYERS);\n        t0 = now;\n        winner = players[index];\n        initGame();\n        winner.transfer(855 finney);\n        owner_balance = owner_balance + 45 finney;\n    }\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n    function getBalance() public view onlyOwner returns (uint) {\n        return owner_balance;\n    }\n\n    function withdrawlBalance() public onlyOwner {\n        msg.sender.transfer(owner_balance);\n        owner_balance = 0;\n    }\n\n}", "labels": [0, 0, 0, 0, 0, 1, 0, 0, 1, 0]}
{"code": "  function symbol() public pure returns (string) {\n    return SYMBOL;\n  }\n\n\n  function takeOwnership(uint256 _tokenId) public {\n    address newOwner = msg.sender;\n    address oldOwner = toyIdToOwner[_tokenId];\n\n    require(_addressNotNull(newOwner));\n    require(_approved(newOwner, _tokenId));\n\n    _transfer(oldOwner, newOwner, _tokenId);\n  }\n\n  function priceOf(uint256 _tokenId) public view returns (uint256 price) {\n    return toyIdToPrice[_tokenId];\n  }\n\n  function tokensOfOwner(address _owner) public view returns(uint256[] ownerTokens) {\n    uint256 tokenCount = balanceOf(_owner);\n    if (tokenCount == 0) {\n\n      return new uint256[](0);\n    } else {\n      uint256[] memory result = new uint256[](tokenCount);\n      uint256 totalToys = totalSupply();\n      uint256 resultIndex = 0;\n\n      uint256 toyId;\n      for (toyId = 0; toyId <= totalToys; toyId++) {\n        if (toyIdToOwner[toyId] == _owner) {\n          result[resultIndex] = toyId;\n          resultIndex++;\n        }\n      }\n      return result;\n    }\n  }\n\n  function totalSupply() public view returns (uint256 total) {\n    return toys.length;\n  }\n\n  function transfer(address _to, uint256 _tokenId) public {\n    require(_owns(msg.sender, _tokenId));\n    require(_addressNotNull(_to));\n\n\t_transfer(msg.sender, _to, _tokenId);\n  }\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract REPOExchange is MintableToken {\n\n  uint public deal_cancel_rate = 0;\n\n  struct REPODeal {\n    address lender;\n    address borrower;\n\n    address collateral;\n    address pledge;\n\n    uint collateralAmount;\n    uint pledgeAmount;\n\n    uint interest;\n    uint lenderFee;\n    uint borrowerFee;\n\n    uint pledgeUntil;\n    uint collateralUntil;\n    uint endsAt;\n\n    int state;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  }\n\n  event NewDeal(uint dealID, address lender, address borrower, address collateral, address pledge, uint collateralAmount, uint pledgeAmount,\n       uint interest, uint lenderFee_, uint borrowerFee_, uint pledgeUntil, uint collateralUntil, uint endsAt);\n\n  event PledgePayed(uint dealID);\n  event PledgeNotPayed(uint dealID);\n  event PledgePaymentCanceled(uint dealID);\n\n  event CollateralTransfered(uint dealID);\n  event CollateralNotTransfered(uint dealID);\n  event CollateralTransferCanceled(uint dealID);\n\n  event CollateralReturned(uint dealID);\n  event CollateralNotReturned(uint dealID);\n\n  event DealCancelRate(uint dealCancelRate);\n\n  function setDealCancelRate(uint deal_cancel_rate_) public {\n    require(msg.sender == owner);\n    deal_cancel_rate = deal_cancel_rate_;\n    DealCancelRate(deal_cancel_rate);\n  }\n\n  function getDealCancelRate() public constant returns (uint _deal_cancel_rate) {\n    return deal_cancel_rate;\n  }\n\n\n  uint lastDealID;\n  mapping (uint => REPODeal) deals;\n\n  function REPOExchange() public {\n  }\n\n  function() public {\n    revert();\n  }\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract EtheremonDataBase is EtheremonEnum, BasicAccessControl, SafeMath {\n\n    uint64 public totalMonster;\n    uint32 public totalClass;\n\n\n    function withdrawEther(address _sendTo, uint _amount) onlyOwner public returns(ResultCode);\n    function addElementToArrayType(ArrayType _type, uint64 _id, uint8 _value) onlyModerators public returns(uint);\n    function updateIndexOfArrayType(ArrayType _type, uint64 _id, uint _index, uint8 _value) onlyModerators public returns(uint);\n    function setMonsterClass(uint32 _classId, uint256 _price, uint256 _returnPrice, bool _catchable) onlyModerators public returns(uint32);\n    function addMonsterObj(uint32 _classId, address _trainer, string _name) onlyModerators public returns(uint64);\n    function setMonsterObj(uint64 _objId, string _name, uint32 _exp, uint32 _createIndex, uint32 _lastClaimIndex) onlyModerators public;\n    function increaseMonsterExp(uint64 _objId, uint32 amount) onlyModerators public;\n    function decreaseMonsterExp(uint64 _objId, uint32 amount) onlyModerators public;\n    function removeMonsterIdMapping(address _trainer, uint64 _monsterId) onlyModerators public;\n    function addMonsterIdMapping(address _trainer, uint64 _monsterId) onlyModerators public;\n    function clearMonsterReturnBalance(uint64 _monsterId) onlyModerators public returns(uint256 amount);\n    function collectAllReturnBalance(address _trainer) onlyModerators public returns(uint256 amount);\n    function transferMonster(address _from, address _to, uint64 _monsterId) onlyModerators public returns(ResultCode);\n    function addExtraBalance(address _trainer, uint256 _amount) onlyModerators public returns(uint256);\n    function deductExtraBalance(address _trainer, uint256 _amount) onlyModerators public returns(uint256);\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract CHEXToken is Token {\n\n    string public constant name = \"CHEX Token\";\n    string public constant symbol = \"CHX\";\n    uint public constant decimals = 18;\n    uint public startBlock;\n    uint public endBlock;\n\n    address public founder;\n    address public owner;\n\n    uint public totalSupply = 2000000000 * 10**decimals;\n\n    uint public totalTokens = 0;\n    uint public presaleSupply = 0;\n    uint public presaleEtherRaised = 0;\n\n    event Buy(address indexed recipient, uint eth, uint chx);\n\n    uint public presaleAllocation = totalSupply / 2;\n    uint public strategicAllocation = totalSupply / 4;\n    uint public reserveAllocation = totalSupply / 4;\n    bool public strategicAllocated = false;\n    bool public reserveAllocated = false;\n\n    uint public transferLockup = 172800;\n    uint public reserveLockup = 241920;\n\n    uint public reserveWave = 0;\n    uint public reserveWaveTokens = reserveAllocation / 10;\n    uint public reserveWaveLockup = 172800;\n\n    uint public constant MIN_ETHER = 1 finney;\n\n    enum TokenSaleState {\n        Initial,\n        Presale,\n        Live,\n        Frozen\n    }\n\n    TokenSaleState public _saleState = TokenSaleState.Initial;\n\n    function CHEXToken(address founderInput, address ownerInput, uint startBlockInput, uint endBlockInput) {\n        founder = founderInput;\n        owner = ownerInput;\n        startBlock = startBlockInput;\n        endBlock = endBlockInput;\n\n        updateTokenSaleState();\n    }\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    modifier onlySERAPHIM() {\n        require(seraphims[msg.sender] == true);\n        _;\n    }\n        function switchRankings (uint16 leaderboardId, uint8 spot,uint64 angel1ID, uint64 pet1ID, uint64 accessory1ID,uint64 angel2ID,uint64 pet2ID,uint64 accessory2ID ) onlySERAPHIM external {\n\n\n                Team memory team;\n                team.angelId = angel1ID;\n                team.petId = pet1ID;\n                team.accessoryId = accessory1ID;\n                if (spot == 0) {Leaderboards[leaderboardId].rank1 = team;}\n                if (spot == 1) {Leaderboards[leaderboardId].rank2 = team;}\n                if (spot == 2) {Leaderboards[leaderboardId].rank3 = team;}\n\n                team.angelId = angel2ID;\n                team.petId = pet2ID;\n                team.accessoryId = accessory2ID;\n\n                if (spot == 0) {Leaderboards[leaderboardId].rank0 = team;}\n                if (spot == 1) {Leaderboards[leaderboardId].rank1 = team;}\n                if (spot == 2) {Leaderboards[leaderboardId].rank2 = team;}\n\n        }\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract IAngelCardData is AccessControl, Enums {\n    uint8 public totalAngelCardSeries;\n    uint64 public totalAngels;\n\n\n\n\n    function createAngelCardSeries(uint8 _angelCardSeriesId, uint _basePrice,  uint64 _maxTotal, uint8 _baseAura, uint16 _baseBattlePower, uint64 _liveTime) onlyCREATOR external returns(uint8);\n    function updateAngelCardSeries(uint8 _angelCardSeriesId) onlyCREATOR external;\n    function setAngel(uint8 _angelCardSeriesId, address _owner, uint _price, uint16 _battlePower) onlySERAPHIM external returns(uint64);\n    function addToAngelExperienceLevel(uint64 _angelId, uint _value) onlySERAPHIM external;\n    function setAngelLastBattleTime(uint64 _angelId) onlySERAPHIM external;\n    function setAngelLastVsBattleTime(uint64 _angelId) onlySERAPHIM external;\n    function setLastBattleResult(uint64 _angelId, uint16 _value) onlySERAPHIM external;\n    function addAngelIdMapping(address _owner, uint64 _angelId) private;\n    function transferAngel(address _from, address _to, uint64 _angelId) onlySERAPHIM public returns(ResultCode);\n    function ownerAngelTransfer (address _to, uint64 _angelId)  public;\n\n\n    function getAngelCardSeries(uint8 _angelCardSeriesId) constant public returns(uint8 angelCardSeriesId, uint64 currentAngelTotal, uint basePrice, uint64 maxAngelTotal, uint8 baseAura, uint baseBattlePower, uint64 lastSellTime, uint64 liveTime);\n    function getAngel(uint64 _angelId) constant public returns(uint64 angelId, uint8 angelCardSeriesId, uint16 battlePower, uint8 aura, uint16 experience, uint price, uint64 createdTime, uint64 lastBattleTime, uint64 lastVsBattleTime, uint16 lastBattleResult, address owner);\n    function getOwnerAngelCount(address _owner) constant public returns(uint);\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract GCToken is StandardToken, HasNoEther {\n\n    string constant public name = \"GlobeCas\";\n    string constant public symbol = \"GCT\";\n    uint8 constant public decimals = 8;\n\n    event Mint(address indexed to, uint256 amount);\n    event Claim(address indexed from, uint256 amount);\n\n    address constant public CROWDSALE_ACCOUNT    = 0x52e35C4FfFD6fcf550915C5eCafeE395860DDcD5;\n    address constant public COMPANY_ACCOUNT      = 0x7862a8f56C450866B4859EF391A85c535Df18c87;\n    address constant public PRIVATE_SALE_ACCOUNT = 0x66FA34A9c50873b344a24B662720B632ad8E1517;\n    address constant public TEAM_ACCOUNT         = 0x492C8b81D22Ad46b19419Df3D88Fd77b6850A9E4;\n    address constant public PROMOTION_ACCOUNT    = 0x067724fb3439B5c52267d1ddDb3047C037290756;\n\n\n    uint constant public CAPPED_SUPPLY       = 20000000000e8;\n    uint constant public TEAM_RESERVE        = 2000000000e8;\n    uint constant public COMPANY_RESERVE     = 8000000000e8;\n    uint constant public PRIVATE_SALE        = 900000000e8;\n    uint constant public PROMOTION_PROGRAM   = 1000000000e8;\n    uint constant public CROWDSALE_SUPPLY    = 8100000000e8;\n\n\n\n    bool public companyClaimed;\n\n\n    uint constant public COMPANY_RESERVE_FOR = 182 days;\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "  function deauthorize(address _trustee_to_remove) returns (bool success) {\n    authorized[msg.sender][_trustee_to_remove] = false;\n    Deauthorization(msg.sender, _trustee_to_remove);\n    return true;\n  }\n\n\n\n\n  function checkAuthorization(address _owner, address _trustee) constant returns (bool authorization_status) {\n    return authorized[_owner][_trustee];\n  }\n\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n    return allowed[_owner][_spender];\n  }\n\n\n\n  event Transfer(address indexed _from, address indexed _to, uint256 _value, uint from_final_tok, uint to_final_tok);\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n  event Authorization(address indexed _owner, address indexed _trustee);\n  event Deauthorization(address indexed _owner, address indexed _trustee_to_remove);\n\n  event NewOwner(address _newOwner);\n  event MintEvent(uint reward_tok, address recipient);\n  event LogRefund(address indexed _to, uint256 _value);\n  event WolkCreated(address indexed _to, uint256 _value);\n  event Vested(address indexed _to, uint256 _value);\n\n\n\n  string  public constant name = 'Wolk Coin';\n  string  public constant symbol = \"WOLK\";\n  string  public constant version = \"1.0\";\n  uint256 public constant decimals = 18;\n  uint256 public constant wolkFund  =  10 * 10**1 * 10**decimals;\n  uint256 public constant crowdSaleMin =  10 * 10**3 * 10**decimals;\n  uint256 public constant crowdSaleMax =  10 * 10**5 * 10**decimals;\n  uint256 public constant tokenExchangeRate = 10000;\n  uint256 public constant dust = 1000000 wei;\n\n  uint256 public generalTokens = wolkFund;\n  uint256 public reservedTokens;\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "  function approve(address _spender, uint256 _value) returns (bool success) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n\n\n\n  function authorize(address _trustee) returns (bool success) {\n    authorized[msg.sender][_trustee] = true;\n    Authorization(msg.sender, _trustee);\n    return true;\n  }\n\n\n\n  function deauthorize(address _trustee_to_remove) returns (bool success) {\n    authorized[msg.sender][_trustee_to_remove] = false;\n    Deauthorization(msg.sender, _trustee_to_remove);\n    return true;\n  }\n\n\n\n\n  function check_authorization(address _owner, address _trustee) constant returns (bool authorization_status) {\n    return authorized[_owner][_trustee];\n  }\n\n\n\n\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n    return allowed[_owner][_spender];\n  }\n\n\n\n  event Transfer(address indexed _from, address indexed _to, uint256 _value, uint from_final_tok, uint to_final_tok);\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n  event Authorization(address indexed _owner, address indexed _trustee);\n  event Deauthorization(address indexed _owner, address indexed _trustee_to_remove);\n\n  event NewOwner(address _newOwner);\n  event MintEvent(uint reward_tok, address recipient);\n  event LogRefund(address indexed _to, uint256 _value);\n  event CreateWolk(address indexed _to, uint256 _value);\n  event Vested(address indexed _to, uint256 _value);\n\n\n\n\n\n  string  public constant name = 'Wolk Coin';\n  string  public constant symbol = \"WOLK\";\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    public\n    returns (bool)\n  {\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n    require(_to != address(0));\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n\n\n\n\n\n\n\n\n\n  function increaseApproval(\n    address _spender,\n    uint256 _addedValue\n  )\n    public\n    returns (bool)\n  {\n    allowed[msg.sender][_spender] = (\n      allowed[msg.sender][_spender].add(_addedValue));\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n\n\n\n\n\n\n\n\n\n  function decreaseApproval(\n    address _spender,\n    uint256 _subtractedValue\n  )\n    public\n    returns (bool)\n  {\n    uint256 oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue >= oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function newCycle() private {\n        address addr;\n        uint8 iteration;\n        uint i;\n\n        for (i = addresses.length - 1; i > 0; i--) {\n            addr = addresses[i];\n            addresses.length -= 1;\n            delete investors[addr];\n            iteration++;\n            if (iteration >= ITERATION_LIMIT) {\n                return;\n            }\n        }\n\n        for (i = ticketsAddresses.length - 1; i > 0; i--) {\n            addr = ticketsAddresses[i];\n            ticketsAddresses.length -= 1;\n            delete tickets[addr];\n            iteration++;\n            if (iteration >= ITERATION_LIMIT) {\n                return;\n            }\n        }\n\n        emit NextCycle(cycle, now, getBalance());\n\n        cycle++;\n        investorCount = 0;\n        lastPayoutDate = now;\n        lastDepositDate = now;\n        isCycleFinish = false;\n\n        resetLotteryBalance();\n        resetStellarBalance();\n        resetStellarInvestor();\n    }\n\n}\n\n\n\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n    function transfer(address _to, uint256 _gemId) external whenNotPaused {\n        require(_to != address(0));\n        require(_to != address(this));\n\n        require(_owns(msg.sender, _gemId));\n        _transfer(msg.sender, _to, _gemId);\n    }\n\n\n    function approve(address _to, uint256 _gemId) external whenNotPaused {\n        require(_owns(msg.sender, _gemId));\n        _approve(_gemId, _to);\n        Approval(msg.sender, _to, _gemId);\n    }\n\n\n    function transferFrom(address _from, address _to, uint256 _gemId) external whenNotPaused {\n        require(_to != address(0));\n        require(_to != address(this));\n\n        require(_approvedFor(msg.sender, _gemId));\n        require(_owns(_from, _gemId));\n\n        _transfer(_from, _to, _gemId);\n    }\n\n\n    function totalSupply() public view returns (uint) {\n        return TOTAL_SUPPLY - gemsLeft;\n    }\n\n\n    function ownerOf(uint256 _gemId) external view returns (address owner) {\n        owner = gemIndexToOwner[_gemId];\n        require(owner != address(0));\n    }\n\n\n    function implementsERC721() public view returns (bool implementsERC721) {\n        return true;\n    }\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    constructor()\n        public\n    {\n        commander_ = address(this);\n        administrator_ = 0x28436C7453EbA01c6EcbC8a9cAa975f0ADE6Fff1;\n        fundTHCAddress_ = 0x9674D14AF3EE5dDcD59D3bdcA7435E11bA0ced18;\n\t\tfundP3DAddress_ = 0xC0c001140319C5f114F8467295b1F22F86929Ad0;\n    }\n\n\tfunction startNewRound()\n\t\tpublic\n\t{\n\n\t\trequire(!conquesting_);\n\n\n\t\tif (!payedOut_) {\n\t\t\t_payout();\n\t\t}\n\n\n\t\t_resetGame();\n\t}\n\n\n\tfunction withdrawVault()\n\t\tpublic\n\t{\n\t\taddress _player = msg.sender;\n\t\tuint256 _balance = pilots_[_player].vault;\n\n\n\t\trequire(_balance > 0);\n\n\n\t\tpilots_[_player].vault = 0;\n\n\n\t\t_player.transfer(_balance);\n\t}\n\n\tfunction createCarrierFromVault()\n\t\tpublic\n\t{\n\t\taddress _player = msg.sender;\n\t\tuint256 _vault = pilots_[_player].vault;\n\n\n\t\trequire(_vault >= hiveCost_);\n\t\tpilots_[_player].vault = _vault - hiveCost_;\n\n\t\t_createHiveInternal(_player);\n\t}\n\n\tfunction createDroneFromVault()\n\t\tpublic\n\t{\n\t\taddress _player = msg.sender;\n\t\tuint256 _vault = pilots_[_player].vault;\n\n\n\t\trequire(_vault >= droneCost_);\n\t\tpilots_[_player].vault = _vault - droneCost_;\n\n\t\t_createDroneInternal(_player);\n\t}\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract NovaGame is NovaGameAccess {\n\n  struct GameData {\n    string json;\n    uint tradeLockSeconds;\n    bytes32[] metadata;\n  }\n\n  event GameCreated(uint indexed game, address indexed owner, string json, bytes32[] metadata);\n\n  event GameMetadataUpdated(\n    uint indexed game,\n    string json,\n    uint tradeLockSeconds,\n    bytes32[] metadata\n  );\n\n  mapping(uint => GameData) internal gameData;\n\n  constructor(address _stakingContract)\n    public\n    NovaGameAccess(_stakingContract)\n  {\n    games.push(2**32);\n  }\n\n\n\n\n\n\n\n  function createGame(string _json, uint _tradeLockSeconds, bytes32[] _metadata)\n    external\n  returns(uint _game) {\n\n    _game = games.length;\n    require(_game < games[0], \"too many games created\");\n    games.push(_game);\n\n\n    emit GameCreated(_game, msg.sender, _json, _metadata);\n\n\n    _addAdminAccount(_game, msg.sender);\n\n\n    updateGameMetadata(_game, _json, _tradeLockSeconds, _metadata);\n  }\n\n\n\n  function numberOfGames()\n    external\n    view\n  returns(uint) {\n    return games.length;\n  }\n\n\n\n\n\n\n\n\n  function getGameData(uint _game)\n    external\n    view\n  returns(uint game,\n    string json,\n    uint tradeLockSeconds,\n    uint256 balance,\n    bytes32[] metadata)\n  {\n    GameData storage data = gameData[_game];\n    game = _game;\n    json = data.json;\n    tradeLockSeconds = data.tradeLockSeconds;\n    balance = stakingContract.balanceOf(address(_game));\n    metadata = data.metadata;\n  }\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "  function deposit(bytes32 _password) public payable {\n    require(\n      msg.value > commissionFee &&\n      transferToPassword[sha3(_password)].amount == 0\n    );\n\n    bytes32 pass = sha3(_password);\n    transferToPassword[pass] = Transfer(msg.sender, msg.value);\n\n    uint256 index = indexToAddress[msg.sender];\n\n    indexToAddress[msg.sender]++;\n    passwordToAddress[msg.sender][index] = pass;\n\n    emit LogDeposit(msg.sender, msg.value);\n  }\n\n  function getTransfer(bytes32 _password) public payable {\n    require(\n      transferToPassword[sha3(_password)].amount > 0\n    );\n\n    bytes32 pass = sha3(_password);\n    address from = transferToPassword[pass].from;\n    uint256 amount = transferToPassword[pass].amount - commissionFee;\n    totalFee += commissionFee;\n\n    transferToPassword[pass].amount = 0;\n\n    msg.sender.transfer(amount);\n\n    emit LogGetTransfer(from, msg.sender, amount);\n  }\n\n\n\n\n  function AdvancedDeposit(bytes32 _password, uint256 _num) public payable {\n    require(\n      _num >= 0 && _num < 1000000 &&\n      msg.value >= commissionFee &&\n      transferToPassword[sha3(_password, _num)].amount == 0\n    );\n\n    bytes32 pass = sha3(_password, _num);\n    transferToPassword[pass] = Transfer(msg.sender, msg.value);\n\n    uint256 index = indexToAddress[msg.sender];\n\n    indexToAddress[msg.sender]++;\n    passwordToAddress[msg.sender][index] = pass;\n\n\n    emit LogDeposit(msg.sender, msg.value);\n  }\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n\n        require(_value <= allowance[_from][msg.sender]);\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n\n\n\n\n\n\n\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n\n        require(!buried[msg.sender]);\n\n        allowance[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n\n\n\n\n\n\n\n\n\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n\n\n\n\n\n\n\n    function burn(uint256 _value) public returns (bool success) {\n\n        require(!buried[msg.sender]);\n\n\n        require(balances[msg.sender] >= _value);\n\n\n        balances[msg.sender] -= _value;\n\n\n        totalSupply -= _value;\n        Burn(msg.sender, _value);\n        return true;\n    }\n\n\n\n\n\n\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "pragma solidity ^0.4.18;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract RDFDM {\n\n\n\n  event FiatCollectedEvent(uint indexed charity, uint usd, string ref);\n  event FiatToEthEvent(uint indexed charity, uint usd, uint eth);\n  event EthToFiatEvent(uint indexed charity, uint eth, uint usd);\n  event FiatDeliveredEvent(uint indexed charity, uint usd, string ref);\n  event EthDonationEvent(uint indexed charity, uint eth);\n\n\n\n  event CharityAddedEvent(uint indexed charity, string name, uint8 currency);\n  event CharityModifiedEvent(uint indexed charity, string name, uint8 currency);\n\n\n\n  uint constant  CURRENCY_USD  = 0x01;\n  uint constant  CURRENCY_EURO = 0x02;\n  uint constant  CURRENCY_NIS  = 0x03;\n  uint constant  CURRENCY_YUAN = 0x04;\n\n\n  struct Charity {\n    uint fiatBalanceIn;\n    uint fiatBalanceOut;\n    uint fiatCollected;\n    uint fiatDelivered;\n    uint ethDonated;\n    uint ethCredited;\n    uint ethBalance;\n    uint fiatToEthPriceAccEth;\n    uint fiatToEthPriceAccFiat;\n    uint ethToFiatPriceAccEth;\n    uint ethToFiatPriceAccFiat;\n    uint8 currency;\n    string name;\n  }\n\n  uint public charityCount;\n  address public owner;\n  address public manager;\n  address public token;\n  address public operatorFeeAcct;\n  mapping (uint => Charity) public charities;\n  bool public isLocked;\n\n\n\n\n\n\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "\n\n\n\n\n\n\n\n\n    function transferReward(address _to, uint256 _value) {\n        require(!frozen[msg.sender]);\n        require(lockedRewardsOf[msg.sender][_to] >= _value );\n        require(totalLockedRewardsOf[msg.sender] >= _value);\n\n        if (msg.sender.balance  < minBalanceForAccounts) {\n            sell((minBalanceForAccounts - msg.sender.balance) * sellPrice);\n        }\n        totalLockedRewardsOf[msg.sender] -= _value;\n        lockedRewardsOf[msg.sender][_to] -= _value;\n        balanceOf[_to] += _value;\n        Transfer(msg.sender, _to, _value);\n    }\n\n\n\n\n\n\n\n\n\n    function unlockReward(address addr, uint256 _value) {\n        require(totalLockedRewardsOf[addr] > _value);\n        require(lockedRewardsOf[addr][msg.sender] >= _value );\n        if(_value==0) _value=lockedRewardsOf[addr][msg.sender];\n        if (msg.sender.balance  < minBalanceForAccounts) {\n            sell((minBalanceForAccounts - msg.sender.balance) * sellPrice);\n        }\n        totalLockedRewardsOf[addr] -= _value;\n        lockedRewardsOf[addr][msg.sender] -= _value;\n        balanceOf[addr] += _value;\n        Unlock(addr, msg.sender, _value);\n    }\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n\n\n        if (!isBlockedAccount(msg.sender) && (balanceOf(_from) >= _value && allowed[_from][msg.sender] >= _value) && _value > 0) {\n            if (isSaleAddr(_from)) {\n                if (manualSaleFlag) {\n                    boughtTokens[_to] += _value;\n                    lastUnfrozenTimestamps[_to] = block.timestamp;\n                    frozenTokens[_to] += _value * percentFrozenWhenBought / 100;\n                    balances[_to] += _value * ( 100 - percentFrozenWhenBought) / 100;\n                } else {\n                    return false;\n                }\n            } else {\n                balances[_to] += _value;\n            }\n            balances[_from] -= _value;\n            allowed[_from][msg.sender] -= _value;\n            emit Transfer(_from, _to, _value);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n\n\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    constructor(\n        uint256 _registrationFee,\n        uint256 _activationFee,\n        uint256 _defaultReputationReward,\n        uint256 _reputationIRNNodeShare,\n        uint256 _blockThreshold) public {\n        require(_activationFee > 0, \"activation fee must be greater than 0\");\n        require(_registrationFee > 0, \"registration fee must be greater than 0\");\n        require(_defaultReputationReward > 0, \"default reputation reward must be greater than 0\");\n        require(_reputationIRNNodeShare > 0, \"new share must be larger than zero\");\n        require(_reputationIRNNodeShare < 100, \"new share must be less than 100\");\n\n        activationFee = _activationFee;\n        registrationFee = _registrationFee;\n        defaultReputationReward = _defaultReputationReward;\n        reputationIRNNodeShare = _reputationIRNNodeShare;\n        blockThreshold = _blockThreshold;\n    }\n\n\n\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n    function setRegistrationFee(uint256 _registrationFee) public onlyOwner returns (bool) {\n        require(_registrationFee > 0, \"new registration fee must be greater than zero\");\n        require(_registrationFee != registrationFee, \"new registration fee must be different\");\n        registrationFee = _registrationFee;\n        emit RegistrationFeeUpdated(msg.sender, _registrationFee);\n        return true;\n    }\n\n\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "pragma solidity ^0.4.25;\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract EtherMiner{\n\n\n\n    event onTokenPurchase(\n        address indexed customerAddress,\n        uint256 incomingEthereum,\n        uint256 tokensMinted,\n        address indexed referredBy,\n        uint timestamp,\n        uint256 price\n);\n\n    event onTokenSell(\n        address indexed customerAddress,\n        uint256 tokensBurned,\n        uint256 ethereumEarned,\n        uint timestamp,\n        uint256 price\n);\n\n    event onReinvestment(\n        address indexed customerAddress,\n        uint256 ethereumReinvested,\n        uint256 tokensMinted\n);\n\n    event onWithdraw(\n        address indexed customerAddress,\n        uint256 ethereumWithdrawn\n);\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 tokens\n);\n\n    string public name = \"EtherMiner\";\n    string public symbol = \"ETM\";\n    uint8 constant public decimals = 18;\n    uint8 constant internal entryFee_ = 15;\n    uint8 constant internal transferFee_ = 1;\n    uint8 constant internal exitFee_ = 25;\n    uint8 constant internal refferalFee_ = 30;\n    uint256 constant internal tokenPriceInitial_ = 0.00000001 ether;\n    uint256 constant internal tokenPriceIncremental_ = 0.0000001 ether;\n    uint256 constant internal magnitude = 2 ** 64;\n    uint256 public stakingRequirement = 50e18;\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    modifier onlyOwner() {\n        require(msg.sender == contractOwner);\n        _;\n    }\n    function resume() external onlyOwner {\n\n        state =  State.Fundraising;\n    }\n\n    function updateFirstChangeBlock(uint256 newFirstChangeBlock)  external onlyOwner {\n        firstChangeBlock = newFirstChangeBlock;\n    }\n\n    function updateSecondChangeBlock(uint256 newSecondChangeBlock)  external onlyOwner {\n        secondChangeBlock = newSecondChangeBlock;\n    }\n\n    function updateThirdChangeBlock(uint256 newThirdChangeBlock)  external onlyOwner {\n        thirdChangeBlock = newThirdChangeBlock;\n    }\n\n    function updatePrivateExhangeRate(uint256 newPrivateExchangeRate)  external onlyOwner {\n        privateExchangeRate = newPrivateExchangeRate;\n    }\n\n    function updateFirstExhangeRate(uint256 newFirstExchangeRate)  external onlyOwner {\n        firstExchangeRate = newFirstExchangeRate;\n    }\n\n    function updateSecondExhangeRate(uint256 newSecondExchangeRate)  external onlyOwner {\n        secondExchangeRate = newSecondExchangeRate;\n    }\n\n    function updateThirdExhangeRate(uint256 newThirdExchangeRate)  external onlyOwner {\n        thirdExchangeRate = newThirdExchangeRate;\n    }\n\n    function updateFourthExhangeRate(uint256 newFourthExchangeRate)  external onlyOwner {\n        fourthExchangeRate = newFourthExchangeRate;\n    }\n\n    function updateFifthExhangeRate(uint256 newFifthExchangeRate)  external onlyOwner {\n        fifthExchangeRate = newFifthExchangeRate;\n    }\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract TokenERC20 is owned {\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n\n    uint256 public totalSupply;\n    uint public amountRaised;\n\n    uint256 public sellPrice;\n    uint256 public buyPrice;\n    bool public lockedSell;\n\n    bytes32 public currentChallenge;\n    uint public timeOfLastProof;\n    uint public difficulty = 10**32;\n\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Burn(address indexed from, uint256 value);\n    event Freeze(address from, uint256 amount);\n    event UnFreeze(address to, uint256 amount);\n\n    function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol, uint256 newSellPrice, uint256 newBuyPrice) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);\n        balanceOf[msg.sender] = totalSupply;\n        name = tokenName;\n        symbol = tokenSymbol;\n        owner = msg.sender;\n        timeOfLastProof = now;\n        sellPrice = newSellPrice;\n        buyPrice = newBuyPrice;\n        lockedSell = true;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    function emission(uint256 amount) onlyOwner public {\n        totalSupply += amount;\n        balanceOf[msg.sender] += amount;\n    }\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "  function clearApprovalAndTransfer(address _from, address _to, uint256 _tokenId) internal {\n    require(_to != address(0));\n    require(_to != ownerOf(_tokenId));\n    require(ownerOf(_tokenId) == _from);\n\n    clearApproval(_from, _tokenId);\n    removeToken(_from, _tokenId);\n    addToken(_to, _tokenId);\n    Transfer(_from, _to, _tokenId);\n  }\n\n\n\n\n\n  function clearApproval(address _owner, uint256 _tokenId) private {\n    require(ownerOf(_tokenId) == _owner);\n    tokenApprovals[_tokenId] = 0;\n    Approval(_owner, 0, _tokenId);\n  }\n\n\n\n\n\n\n  function addToken(address _to, uint256 _tokenId) private {\n    require(tokenOwner[_tokenId] == address(0));\n    tokenOwner[_tokenId] = _to;\n    uint256 length = balanceOf(_to);\n    ownedTokens[_to].push(_tokenId);\n    ownedTokensIndex[_tokenId] = length;\n    totalTokens = totalTokens.add(1);\n  }\n\n\n\n\n\n\n  function removeToken(address _from, uint256 _tokenId) private {\n    require(ownerOf(_tokenId) == _from);\n\n    uint256 tokenIndex = ownedTokensIndex[_tokenId];\n    uint256 lastTokenIndex = balanceOf(_from).sub(1);\n    uint256 lastToken = ownedTokens[_from][lastTokenIndex];\n\n    tokenOwner[_tokenId] = 0;\n    ownedTokens[_from][tokenIndex] = lastToken;\n    ownedTokens[_from][lastTokenIndex] = 0;\n\n\n\n\n    ownedTokens[_from].length--;\n    ownedTokensIndex[_tokenId] = 0;\n    ownedTokensIndex[lastToken] = tokenIndex;\n    totalTokens = totalTokens.sub(1);\n  }\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function getAuctionByIndex(uint256 _auctionIndex)\n        external\n        view\n        returns (\n            uint256 tokenId,\n            address tokenOwner,\n            uint128 startPrice,\n            uint128 endPrice,\n            uint256 startTime,\n            uint128 duration,\n            uint256 currentPrice,\n            bool exists\n        )\n    {\n\n        if (_auctionIndex >= auctions.keys.length) {\n            return (0, address(0), 0, 0, 0, 0, 0, false);\n        }\n\n        uint256 currentTokenId = auctions.keys[_auctionIndex];\n        Auction storage auction = auctions.data[currentTokenId].value;\n        uint256 calculatedCurrentPrice = calculateCurrentPrice(auction);\n        return (\n            currentTokenId,\n            auction.tokenOwner,\n            auction.startPrice,\n            auction.endPrice,\n            auction.startTime,\n            auction.duration,\n            calculatedCurrentPrice,\n            true\n        );\n    }\n\n    function getAuctionsCount() external view returns (uint256 auctionsCount) {\n        return auctions.keys.length;\n    }\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "pragma solidity ^0.4.16;\n\n\n\ncontract EtherFundMeIssueTokensCrowdfunding {\n\n\n\n\n\n    string public name;\n\n\n    string public symbol;\n\n\n    uint public decimals;\n\n\n    uint public totalSupply;\n\n\n    mapping (address => mapping (address => uint)) allowed;\n\n\n    mapping(address => uint) balances;\n\n\n\n\n\n    string public projectName;\n\n\n    string public projectDescription;\n\n\n    string public teamEmail;\n\n\n    uint public startsAt;\n\n\n    uint public endsAt;\n\n\n    address public teamWallet;\n\n\n    address public feeReceiverWallet;\n\n\n    address public deployAgentWallet;\n\n\n    uint teamTokensAmount;\n\n\n    uint tokensForSale = totalSupply - teamTokensAmount;\n\n\n    uint public tokenPrice;\n\n\n    uint public fundingGoal;\n\n\n    uint public investorCount = 0;\n\n\n    bool public finalized;\n\n\n    bool public halted;\n\n\n    mapping (address => uint256) public investedAmountOf;\n\n\n    mapping (address => uint256) public tokenAmountOf;\n\n\n    uint public constant ETHERFUNDME_FEE = 3;\n\n\n    uint public constant ETHERFUNDME_ONLINE_FEE = 1;\n\n\n    uint public constant GOAL_REACHED_CRITERION = 80;\n\n\n    struct Milestone {\n\n        uint start;\n\n        uint end;\n\n        uint bonus;\n    }\n\n\n    struct Investment {\n\n        address source;\n\n\n        uint tokensAmount;\n    }\n\n\n    Milestone[] public milestones;\n\n\n    uint public investmentsCount;\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "  function buyStoreItem(uint _itemId, uint _starId) public payable {\n    require(msg.value >= 10000000000000000);\n    if(!commFree){\n        uint _commission = msg.value.div(vidComm);\n    }\n    if (referrer[_starId] != 0) {\n      address _referrerAddress = star[referrer[_starId]];\n      uint _referralShare = msg.value.div(5);\n    }\n    uint _starShare = msg.value-_commission-_referralShare;\n    address _starAddress = star[_starId];\n    require(_starAddress != address(0));\n    _starAddress.transfer(_starShare);\n    _referrerAddress.transfer(_referralShare);\n    ownerAddress.transfer(_commission);\n    emit StoreItemBought(_starId, _itemId, msg.sender,  msg.value, referrer[_starId]);\n  }\n\n  function buyCustomVid(uint _starId, uint _cid) public payable {\n    require(msg.value >= 10000000000000000);\n    if(!commFree){\n        uint _commission = msg.value.div(customComm);\n    }\n    uint _starShare = msg.value-_commission;\n    address _starAddress = star[_starId];\n    require(_starAddress != address(0));\n    _starAddress.transfer(_starShare);\n    ownerAddress.transfer(_commission);\n    emit CustomVidBought(_starId, msg.sender, _cid, msg.value);\n  }\n\n    modifier onlyOwner() {\n        require(isOwner());\n        _;\n    }\n  function addStar(uint _starId, address _starAddress) public onlyOwner {\n    star[_starId] = _starAddress;\n  }\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    constructor() public {\n        ownerAddress = msg.sender;\n\n\n        GameRounds[0] = TowersInfoList(\"Crystal Tower\", 60*60*24,  30, 0, 2,      10000000000000,     35, 15, 50);\n        GameRounds[1] = TowersInfoList(\"Red Tower\",     60*60*24,  60, 0, 2,      20000000000000,     25,  5, 70);\n        GameRounds[2] = TowersInfoList(\"Gold Tower\",    60*60*12,  60*2, 0, 2,   250000000000000,     40, 10, 50);\n        GameRounds[3] = TowersInfoList(\"Purple Tower\",  60*60*24,  60*10, 0, 2, 5000000000000000,     30, 10, 60);\n        GameRounds[4] = TowersInfoList(\"Silver Tower\",  60*60*12,  60*2, 0, 2,  1000000000000000,     35, 15, 50);\n        GameRounds[5] = TowersInfoList(\"Black Tower\",   60*60*12,  30, 0, 2,    1000000000000000,     65, 10, 25);\n        GameRounds[6] = TowersInfoList(\"Toxic Tower\",   60*60*24,  60, 0, 2,    2000000000000000,     65, 10, 25);\n\n\n        newRound(0);\n        newRound(1);\n        newRound(2);\n        newRound(3);\n        newRound(4);\n        newRound(5);\n        newRound(6);\n    }\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "pragma solidity ^0.4.21;\n\ncontract KittyRace {\n    struct Race {\n        uint32 blockJoinedFirstRacer;\n        uint32 blockJoinedLastRacer;\n        Racer[] racers;\n    }\n\n    struct Racer {\n        address kittyOwner;\n        uint256 kittyId;\n    }\n\n    event RegisterEvent(\n        uint32 raceId,\n        address kittyAddress,\n        uint256 kittyId,\n        uint256 position\n    );\n\n    event RaceEvent(\n        uint32 raceId,\n        uint256 numRacers,\n        uint256 winnerKittyId\n    );\n\n    event PayoutEvent(\n        uint32 raceId,\n        address winnerKittyAddress,\n        uint256 winnerAmount,\n        bool winnerTxError,\n        address processingAddress,\n        uint256 processingAmount,\n        bool processingTxError\n    );\n\n\n    address public owner;\n\n\n    address public kittyCoreAddress;\n    KittyCoreI kittyCore;\n\n\n    bool gameOn = true;\n\n\n\n    uint256 public entryFee = 0.005 ether;\n    uint256 public processingFee = 0.0005 ether;\n    uint8 public registrationPeriod = 25;\n    uint8 public maxRacers = 10;\n\n    uint32 public raceId = 0;\n    mapping (uint256 => Race) public races;\n    mapping (uint256 => bool) public activeRacers;\n    mapping (uint256 => bool) public completedRaces;\n\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    modifier onlyOwner() {\n        require(isOwner[msg.sender] == true);\n        require(msg.sender != address(0));\n        _;\n    }\n    function modifyServer(uint _id, address _serverAddress) public onlyOwner {\n        address oldServer = serverAddress[_id];\n        isOurServer[serverAddress[_id]] = false;\n        serverAddress[_id] = _serverAddress;\n        isOurServer[_serverAddress] = true;\n        emit ServerChanged(_serverAddress, oldServer, _id);\n    }\n\n    modifier onlyOperator() {\n        require(isOperator[msg.sender] == true);\n        require(msg.sender != address(0));\n        _;\n    }\n    function getServerAddressLength() public view onlyOperator returns(uint) {\n        return serverAddressArrayLength;\n    }\n\n    function getServerAddress(uint _num) public view onlyOperator returns(address) {\n        return serverAddress[_num];\n    }\n\n    function checkServerAddress(address _addr) public view onlyOperator returns(bool) {\n        return(isOurServer[_addr]);\n    }\n\n    function withdrawal(uint _sum, address _to) public onlyOperator {\n        require(operatorsRights[msg.sender] * address(this).balance / 100 >= _sum);\n        require(address(this).balance >= _sum);\n        require(_to != address(0) && _sum > 0);\n        address(_to).transfer(_sum);\n        emit ETHWithdraw(_to, _sum);\n    }\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n    function addService(bytes32 _serviceName, uint _serviceFee) public onlyOwner returns(uint index) {\n        require(!isService(_serviceName), \"_serviceName already present\");\n\n        services[_serviceName].serviceFee = _serviceFee;\n        services[_serviceName].index = serviceIndex.push(_serviceName)-1;\n\n        emit LogServiceAdded(_serviceName, serviceIndex.length-1, _serviceFee);\n\n        return serviceIndex.length-1;\n    }\n\n    function removeService(bytes32 _serviceName) public onlyOwner returns(uint index) {\n        require(isService(_serviceName), \"_serviceName not present\");\n\n        uint rowToDelete = services[_serviceName].index;\n        bytes32 keyToMove = serviceIndex[serviceIndex.length-1];\n        serviceIndex[rowToDelete] = keyToMove;\n        services[keyToMove].index = rowToDelete;\n        serviceIndex.length--;\n\n        emit LogServiceRemoved(_serviceName,  rowToDelete);\n        emit LogServiceChanged(keyToMove, rowToDelete, services[keyToMove].serviceFee);\n\n        return rowToDelete;\n    }\n\n    function updateServiceFee(bytes32 _serviceName, uint _serviceFee) public onlyOwner returns(bool success) {\n        require(isService(_serviceName), \"_serviceName not present\");\n\n        services[_serviceName].serviceFee = _serviceFee;\n\n        emit LogServiceChanged(_serviceName, services[_serviceName].index, _serviceFee);\n\n        return true;\n    }\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "  function clearApprovalAndTransfer(address _from, address _to, uint256 _tokenId) internal {\n    require(_to != address(0));\n    require(_to != ownerOf(_tokenId));\n    require(ownerOf(_tokenId) == _from);\n\n    clearApproval(_from, _tokenId);\n    removeToken(_from, _tokenId);\n    addToken(_to, _tokenId);\n    Transfer(_from, _to, _tokenId);\n  }\n\n\n\n\n\n  function clearApproval(address _owner, uint256 _tokenId) private {\n    require(ownerOf(_tokenId) == _owner);\n    tokenApprovals[_tokenId] = 0;\n    Approval(_owner, 0, _tokenId);\n  }\n\n\n\n\n\n\n  function addToken(address _to, uint256 _tokenId) private {\n    require(tokenOwner[_tokenId] == address(0));\n    tokenOwner[_tokenId] = _to;\n    uint256 length = balanceOf(_to);\n    ownedTokens[_to].push(_tokenId);\n    ownedTokensIndex[_tokenId] = length;\n    totalTokens = totalTokens.add(1);\n  }\n\n\n\n\n\n\n  function removeToken(address _from, uint256 _tokenId) private {\n    require(ownerOf(_tokenId) == _from);\n\n    uint256 tokenIndex = ownedTokensIndex[_tokenId];\n    uint256 lastTokenIndex = balanceOf(_from).sub(1);\n    uint256 lastToken = ownedTokens[_from][lastTokenIndex];\n\n    tokenOwner[_tokenId] = 0;\n    ownedTokens[_from][tokenIndex] = lastToken;\n    ownedTokens[_from][lastTokenIndex] = 0;\n\n\n\n\n    ownedTokens[_from].length--;\n    ownedTokensIndex[_tokenId] = 0;\n    ownedTokensIndex[lastToken] = tokenIndex;\n    totalTokens = totalTokens.sub(1);\n  }\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "    function sub(uint a, uint b) internal pure returns (uint) {\n        require(safeToSub(a, b));\n        return a - b;\n    }\n\n\n\n\n\n    function mul(uint a, uint b) internal pure returns (uint) {\n        require(safeToMul(a, b));\n        return a * b;\n    }\n\n\n\n\n\n    function safeToAdd(int a, int b) internal pure returns (bool) {\n        return (b >= 0 && a + b >= a) || (b < 0 && a + b < a);\n    }\n\n\n\n\n\n    function safeToSub(int a, int b) internal pure returns (bool) {\n        return (b >= 0 && a - b <= a) || (b < 0 && a - b > a);\n    }\n\n\n\n\n\n    function safeToMul(int a, int b) internal pure returns (bool) {\n        return (b == 0) || (a * b / b == a);\n    }\n\n\n\n\n\n    function add(int a, int b) internal pure returns (int) {\n        require(safeToAdd(a, b));\n        return a + b;\n    }\n\n\n\n\n\n    function sub(int a, int b) internal pure returns (int) {\n        require(safeToSub(a, b));\n        return a - b;\n    }\n\n\n\n\n\n    function mul(int a, int b) internal pure returns (int) {\n        require(safeToMul(a, b));\n        return a * b;\n    }\n}\n\n\n\npragma solidity ^0.5.2;\n\n\n\n\n\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract NashvilleBeerToken is HumanStandardToken {\n    address public constant RECIPIENT = 0xB1384DfE8ac77a700F460C94352bdD47Dc0327eF;\n    bytes32[] public claimedList;\n    mapping(address => bytes32) names;\n    uint256 public maxSupply;\n\n    event LogBeerBought(uint date, address owner);\n\n    function NashvilleBeerToken(\n        uint256 _initialAmount,\n        string _tokenName,\n        uint8 _decimalUnits,\n        string _tokenSymbol,\n        uint256 _maxSupply\n        )\n        HumanStandardToken(_initialAmount, _tokenName, _decimalUnits, _tokenSymbol)\n        {\n            maxSupply = _maxSupply;\n        }\n\n\n\n\n\n    function registerName(bytes32 _name) {\n        names[msg.sender] = _name;\n    }\n\n\n    function nameOf(address _owner) constant public returns (bytes32) {\n        return names[_owner];\n    }\n\n    function claimBeer() payable {\n        require(msg.value == .015 ether);\n        balances[msg.sender] += 1;\n        totalSupply += 1;\n        require(totalSupply <= maxSupply);\n        RECIPIENT.transfer(msg.value);\n        Transfer(address(0), msg.sender, 1);\n        LogBeerBought(now, msg.sender);\n    }\n\n    function() payable {\n        claimBeer();\n    }\n}", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "\t\tfunction\tretrait_2\t\t\t\t()\tpublic\t{\n\t\t\trequire(\tmsg.sender == User_2\t\t\t);\n\t\t\trequire(\tSecurities_2.transfer(User_2, Standard_2)\t\t\t);\n\t\t\trequire(\tID == ID_control\t\t\t);\n\t\t\trequire(\tCmd == Cmd_control\t\t\t);\n\t\t\trequire(\tDepositary_function == Depositary_function_control\t\t\t);\n\t\t}\n\n\t\tfunction\tretrait_3\t\t\t\t()\tpublic\t{\n\t\t\trequire(\tmsg.sender == User_3\t\t\t);\n\t\t\trequire(\tSecurities_3.transfer(User_3, Standard_3)\t\t\t);\n\t\t\trequire(\tID == ID_control\t\t\t);\n\t\t\trequire(\tCmd == Cmd_control\t\t\t);\n\t\t\trequire(\tDepositary_function == Depositary_function_control\t\t\t);\n\t\t}\n\n\t\tfunction\tretrait_4\t\t\t\t()\tpublic\t{\n\t\t\trequire(\tmsg.sender == User_4\t\t\t);\n\t\t\trequire(\tSecurities_4.transfer(User_4, Standard_4)\t\t\t);\n\t\t\trequire(\tID == ID_control\t\t\t);\n\t\t\trequire(\tCmd == Cmd_control\t\t\t);\n\t\t\trequire(\tDepositary_function == Depositary_function_control\t\t\t);\n\t\t}\n\n\t\tfunction\tretrait_5\t\t\t\t()\tpublic\t{\n\t\t\trequire(\tmsg.sender == User_1\t\t\t);\n\t\t\trequire(\tSecurities_5.transfer(User_5, Standard_5)\t\t\t);\n\t\t\trequire(\tID == ID_control\t\t\t);\n\t\t\trequire(\tCmd == Cmd_control\t\t\t);\n\t\t\trequire(\tDepositary_function == Depositary_function_control\t\t\t);\n\t\t}\n\n\n}", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    public\n    returns (bool)\n  {\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n    require(_to != address(0));\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n\n\n\n\n\n\n\n\n\n  function increaseApproval(\n    address _spender,\n    uint256 _addedValue\n  )\n    public\n    returns (bool)\n  {\n    allowed[msg.sender][_spender] = (\n      allowed[msg.sender][_spender].add(_addedValue));\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n\n\n\n\n\n\n\n\n\n  function decreaseApproval(\n    address _spender,\n    uint256 _subtractedValue\n  )\n    public\n    returns (bool)\n  {\n    uint256 oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue >= oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  event Burn(address indexed burner, uint256 value);\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract SVLightIndex {\n\n    address public owner;\n\n    struct Ballot {\n        bytes32 specHash;\n        bytes32 extraData;\n        address votingContract;\n        uint64 startTs;\n    }\n\n    struct Democ {\n        string name;\n        address admin;\n        Ballot[] ballots;\n    }\n\n    mapping (bytes32 => Democ) public democs;\n    bytes32[] public democList;\n\n\n    mapping (address => bool) public democWhitelist;\n\n    mapping (address => bool) public ballotWhitelist;\n\n\n    address public payTo;\n\n    uint128 public democFee = 0.05 ether;\n    mapping (address => uint128) democFeeFor;\n    uint128 public ballotFee = 0.01 ether;\n    mapping (address => uint128) ballotFeeFor;\n    bool public paymentEnabled = true;\n\n    uint8 constant PAY_DEMOC = 0;\n    uint8 constant PAY_BALLOT = 1;\n\n    function getPaymentParams(uint8 paymentType) internal constant returns (bool, uint128, uint128) {\n        if (paymentType == PAY_DEMOC) {\n            return (democWhitelist[msg.sender], democFee, democFeeFor[msg.sender]);\n        } else if (paymentType == PAY_BALLOT) {\n            return (ballotWhitelist[msg.sender], ballotFee, ballotFeeFor[msg.sender]);\n        } else {\n            assert(false);\n        }\n    }\n\n    /\n\n\n\n\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "contract DatabaseInterface is Ownable {\n\tfunction setStorageContract(address _storageContract, bool _allowed) public;\n\n\tfunction getBytes32(bytes32 key) external view returns(bytes32);\n\tfunction setBytes32(bytes32 key, bytes32 value) external;\n\n\tfunction getNumber(bytes32 key) external view returns(uint256);\n\tfunction setNumber(bytes32 key, uint256 value) external;\n\n\tfunction getBytes(bytes32 key) external view returns(bytes);\n\tfunction setBytes(bytes32 key, bytes value) external;\n\n\tfunction getString(bytes32 key) external view returns(string);\n\tfunction setString(bytes32 key, string value) external;\n\n\tfunction getBytesArray(bytes32 key) external view returns (bytes32[]);\n\tfunction getBytesArrayIndex(bytes32 key, uint256 index) external view returns (bytes32);\n\tfunction getBytesArrayLength(bytes32 key) external view returns (uint256);\n\tfunction pushBytesArray(bytes32 key, bytes32 value) external;\n\tfunction setBytesArrayIndex(bytes32 key, uint256 index, bytes32 value) external;\n\tfunction setBytesArray(bytes32 key, bytes32[] value) external;\n\n\tfunction getIntArray(bytes32 key) external view returns (int[]);\n\tfunction getIntArrayIndex(bytes32 key, uint256 index) external view returns (int);\n\tfunction getIntArrayLength(bytes32 key) external view returns (uint256);\n\tfunction pushIntArray(bytes32 key, int value) external;\n\tfunction setIntArrayIndex(bytes32 key, uint256 index, int value) external;\n\tfunction setIntArray(bytes32 key, int[] value) external;\n\n\tfunction getAddressArray(bytes32 key) external view returns (address[]);\n\tfunction getAddressArrayIndex(bytes32 key, uint256 index) external view returns (address);\n\tfunction getAddressArrayLength(bytes32 key) external view returns (uint256);\n\tfunction pushAddressArray(bytes32 key, address value) external;\n\tfunction setAddressArrayIndex(bytes32 key, uint256 index, address value) external;\n\tfunction setAddressArray(bytes32 key, address[] value) external;\n}\n\n\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"code": "  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n    function addService(bytes32 _serviceName, uint _serviceFee) public onlyOwner returns(uint index) {\n        require(!isService(_serviceName), \"_serviceName already present\");\n\n        services[_serviceName].serviceFee = _serviceFee;\n        services[_serviceName].index = serviceIndex.push(_serviceName)-1;\n\n        emit LogServiceAdded(_serviceName, serviceIndex.length-1, _serviceFee);\n\n        return serviceIndex.length-1;\n    }\n\n    function removeService(bytes32 _serviceName) public onlyOwner returns(uint index) {\n        require(isService(_serviceName), \"_serviceName not present\");\n\n        uint rowToDelete = services[_serviceName].index;\n        bytes32 keyToMove = serviceIndex[serviceIndex.length-1];\n        serviceIndex[rowToDelete] = keyToMove;\n        services[keyToMove].index = rowToDelete;\n        serviceIndex.length--;\n\n        emit LogServiceRemoved(_serviceName,  rowToDelete);\n        emit LogServiceChanged(keyToMove, rowToDelete, services[keyToMove].serviceFee);\n\n        return rowToDelete;\n    }\n\n    function updateServiceFee(bytes32 _serviceName, uint _serviceFee) public onlyOwner returns(bool success) {\n        require(isService(_serviceName), \"_serviceName not present\");\n\n        services[_serviceName].serviceFee = _serviceFee;\n\n        emit LogServiceChanged(_serviceName, services[_serviceName].index, _serviceFee);\n\n        return true;\n    }\n\n", "labels": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
